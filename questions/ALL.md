## Common questions  

+ [Как работает статическая типизация в Java](#Как-работает-статическая-типизация-в-Java)
+ [Потоки, создающиеся при старте программы по умолчанию](#Потоки-создающиеся-при-старте-программы-по-умолчанию)
+ [Двочиная и другие системы исчисления](#Двочиная-и-другие-системы-исчисления)
+ [Логические и побитовые операции](#Логические-и-побитовые-операции)

## Как работает статическая типизация в Java  

+ Статическая типизация — проверка безопасности типов программы на этапе компиляции
 (путем анализа исходного кода программы).
+ Динамическая типизация — проверка безопасности типов программы во время ее выполнения.  

Java использует статическую проверку типов, то есть анализ программы во время ее компиляции.
Основная идея выбора такого подхода проверки типов состоит в том, чтобы проверять типы только 1 раз при компиляции,
тем самым повышая скорость выполнения программы. Также это позволяет обнаруживать возможные ошибки.  
Статическая типизация в Java  

Давайте рассмотрим простой пример статической типизации в Java. Есть два класса: Alpha и Beta с методами, которые что-то делают:

```java
class Alfa {
	Alfa getThis() {
		return this;
	}
 
	public void doAlfa() {
		System.out.println("что-то делаем в Alfa");
	}
}
 
class Beta extends Alfa {
	public void doBeta() {
		System.out.println("что-то делаем в Beta");
	}
}

class Omega extends Alfa{
	public void doOmega() {
		System.out.println("что-то делаем с Omega");
	}
}
```
Примеры:  
+ new Beta().getThis()? - работает, т.к. B - наследник А (кастинг вверх) 
+ new Beta().getThis().doBeta(); - ошибка компиляции  
Проблема заключается в том, что ее исходный тип Аlfa и компилятор не знает реальный тип во время компиляции, 
поэтому он видит объект типа Аlfa. Исходя из этого нам не доступен метод doBeta().
+ ((Beta) new Beta().getThis()).doBeta(); - обошли проблему с помощью приведения типов к Beta:
+ ((Omega) new Beta().getThis()).doOmega(); - ройдет статическую компиляцию, т.к. альфа можно привести к омега, но упадет во время выполнения    
Так написать можно и это даже пройдет статическую проверку типов (по той же причине, что и с new Beta().getThis().doBeta();), 
однако во время выполнения будет брошено исключение «java.lang.ClassCastException:
Beta cannot be cast to Omega«, так как Beta не может быть приведена к Omega.  

[подробнее](https://javadevblog.com/kak-rabotaet-staticheskaya-tipizatsiya-v-java.html)  

[к оглавлению](#Common-questions)  



## Логические и побитовые операции  
[подробнее](https://javarush.ru/groups/posts/logicheskie-operacii-v-java#%D0%9F%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_1)  
   
## Двочиная-и-другие-системы-исчисления 
В java левый бит числа отвечает за знак (для byte - 16 бит слева, для int - 32 бит слева)   
Как перевести в двоичную - проще расписать следующим образом:  
128  64 32 16   8   4   2   1
1   1   1   1   1   1   1   1  
последовательного деления в столбик на основу системы счисления (2). Остатки от деления на каждом шагу, 
записанные в обратном порядке, и дадут нам искомое двоичное число.  

**Отрицательные двоичные числа**
Присутствует знаковый бит: 0 обозначает +,  1 - .   

1. Записываем число -13 в так называемом “прямом коде”. Для этого меняем старший разряд числа на 1.  10000000 0000000 0000000 00001101    
2. Далее инвертируем все разряды (меняем 0 на 1, а 1 на 0) кроме знакового разряда. Его, по сути, мы уже поменяли. 11111111 11111111 11111111 11110010
3. Прибавляем к получившемуся числу 1. 11111111 11111111 11111111 11110011      

Числа в byte:    
  -128      -2       -1      0        127  
10000000 11111110 11111111 00000000 01111111  

Вычитание двоичных чисел (длля понмиания отрицательных)  
[подробнее](https://ru.wikihow.com/%D0%B2%D1%8B%D1%87%D0%B8%D1%82%D0%B0%D1%82%D1%8C-%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%B0)    
  
Посчитаем 2 - 1 =1 :   
0000 0010 -     
0000 0001 =    
0000 0001  

Посчитаем 0 - 1 = -1:  
0000 0000  -  
0000 0001  = 
1111 1111 

Посчитаем 2 - 10 = -8:  
0000 0010 -  
0000 1010 = 
1111 1000  

**Т.е. можн опросто вычесть из 0 нужное число**   
Посчитаем 0 - 8 = -8:  
0000 0000 -  
0000 1000 = 
1111 1000  
Чтобы в java использовать двоичное число, добавляем перед ним 0b.
byte:  0b00001000  
System.out.println(Integer.toBinaryString(-73)); - получить двоиную форму  
  
**Для вычитания большего числа из меньшего, вычтите меньшее число из большего, а к ответу припишите знак «минус».**   
Например, чтобы вычислить 11 - 100, вычислите 100 - 11, а затем к ответу припишите знак «минус» 
(это правило относится к вычитанию чисел в любой системе счисления, а не только в двоичной системе).  
т.е. чтобы поменять знак надо обратить число и прибавить 1.  
Пример:    
0010 0001 - 0110 1010 = - (01101010 - 00100001)  
0110 1010 -   
0010 0001 =  
0100 1001 
считаем - 0100 1001 - обращаем: 1011 0110, прибавляем 1: 1011 0111


[к оглавлению](#Common-questions)  

**Логические и побитовые операторы** 
Приоритет логических операций  
1. !  
2. &  
3. ^  
4. | 
5. &&  
6. ||    
Унарные операторы выше по приоритету, чем бинарные, т.к. должен быть вычислен второй операнд, например, сразу для инициализации переменной, 
но если бы бинарные были приоритетнее, то унарный оператор просто мог бы быть пропущен. 
Поменять порядок приоритета можно, просто примените скобки, прямо в школьной математике.  
Т.к. || - выполняется в конце, то если оно равно true, то можно сразу сделать вывод, что общее выражение равно true.   

+ ^ (логическое вычитание) - XOR — исключающее ИЛИ - возвращает true, если один и только один из операндов равен true. (исключающее - только один операнд должен быть тру)   
Возвращает false, если оба операнда равны true или false. 
**По сути, возвращает true, если операнды — разные.**  **true ^ false == true;**  true ^ true == false;  false ^ false == false;  
(в | для тру должен быть **хотя бы** один операндн быть тру, а в  ^ - **только один** операнд - отсюда исключающее)  
+ && (логическое умножение) -  То же самое, что и &, но если операнд, находящийся слева от & является false, данный оператор возвращает false без проверки второго операнда.  
Если представить, что true — это число 1, а false — 0, то оператор & работает точно так же, как обычное умножение.  
+ || (логическое сложение) - То же самое, что и |, но если оператор слева является true, оператор возвращает true без проверки второго операнда.  

**Поразрядные (побитовые) операторы**  
&, | и ^ можно употреблять по отношению к целочисленным типам Java, в таком случае они являются поразрядными (побитовыми) операторами.  
Их можно применять как минимум для организации эффективного деления и умножения, а профессионалы их используют для 
кодирования/декодирования, шифрования, генерации случайных чисел.  
Помимо &, | и ^ в Java также используются поразрядные операторы:
+ "~" поразрядный оператор отрицания (аналог "!")
+ ">>" побитовый сдвиг вправо (сохраняет знак)  
+ ">>>" беззнаковый побитовый сдвиг вправо (не сохраняет знак)
+ "<<" побитовый сдвиг влево     
Поразрядные операторы &, | или ^ “видят” числа-операнды в их двоичной форме. И затем применяют логические операторы &, | или ^
к соответствующим друг другу разрядам (битам) обоих чисел.  
 
byte a = 13  
**Побитовый сдвиг влево "<<"**
a << 1 смещает все биты двоичного представления числа a влево на 1 бит, и освободившийся справа бит заполняется нулем  
было:   1101 = 13  
стало: 11010 = 26    
a << 2 дописываем 2 нуля справа, В результате мы получим число 52.      
**Побитовый сдвиг a влево на n позиций работает как умножение числа a на 2 в степени n.**  
Это же касается и отрицательных чисел. Так -13 << 3 выдаст результат -104. (= 13*2^3) 
  
**Побитовый сдвиг вправо ">>"**  
a >> n смещает двоичное представление число на n позиций вправо.  
Например, 13 >> 1
Превращает число 1101 в число 0110, то есть, 6. А 13 >> 2 даст в результате 3.  
То есть по сути, тут мы делим число на 2 в степени n, где n — количество сдвигов вправо, но с одним нюансом: если число нечётное, 
мы при этой операции как бы обнуляем последний бит числа.  
А вот с отрицательными  дело обстоит несколько иначе:  
-13 >> 1  
11110011 = -13  
11111001 =  -7  
  
**Беззнаковый сдвиг вправо ">>>"**  
a >>> n — эта операция является беззнаковым сдвигом, то есть она сдвигает двоичное представление числа a вправо на n разрядов,
но освободившиеся слева n разрядов заполняет не единицами, как оператор >>, а нулями.  
-13 = 11111111 11111111 11111111 11110011 -> 01111111 11111111 11111111 11111001 = 2147483641  


  
