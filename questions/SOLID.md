## SOLID

+ [Что такое SOLID?](#Что-такое-SOLID)
+ [Для чего используются JavaDoc?](#Для-чего-используются-JavaDoc)
+ [Как писать JavaDoc?](#Как-писать-JavaDoc)
+ [Что такое Java code convention?](#Что-такое-Java-code-convention)
+ [Антипаттерн Божественный Объект](#Антипаттерн-Божественный-Объект)
+ [Расскажите про принципы составления Java класса.](#Расскажите-про-принципы-составления-Java-класса)
+ [Что такое SRP?](#Что-такое-SRP)
+ [Расскажите о нарушениях принципе SRP?](#Расскажите-о-нарушениях-принципе-SRP)
+ [Последствия нарушения SRP?](#Последствия-нарушения-SRP)
+ [Что такое OCP?](#Что-такое-OCP)
+ [Расскажите о нарушениях принципе OCP?](#Расскажите-о-нарушениях-принципе-OCP)
+ [Последствия нарушения OCP?](#Последствия-нарушения-OCP)
+ [Что такое LSP?](#Что-такое-LSP)
+ [Расскажите о нарушениях принципе LSP?](#Расскажите-о-нарушениях-принципе-LSP)
+ [Последствия нарушения LSP?](#Последствия-нарушения-LSP)
+ [Что такое ISP?](#Что-такое-ISP)
+ [Расскажите о нарушениях принципе ISP?](#Расскажите-о-нарушениях-принципе-ISP)
+ [Последствия нарушения ISP?](#Последствия-нарушения-ISP)
+ [Что такое DIP?](#Что-такое-DIP)
+ [Расскажите о нарушениях принципе DIP?](#Расскажите-о-нарушениях-принципе-DIP)
+ [Последствия нарушения DIP?](#Последствия-нарушения-DIP)
+ [Dry, Kiss, Yagni](#AJAX)
+ [AJAX](#Dry-Kiss-Yagni)
+ [Water Flow](#Water_Flow)
+ [AGILE](#AGILE)
+ [SCRUM](#SCRUM)
+ [Расскажите что такое автоматическое тестирование?](#Расскажите-что-такое-автоматическое-тестирование)
+ [Как в Java осуществляется автоматическое тестирование?](#Как-в-Java-осуществляется-автоматическое-тестирование)
+ [Что такое JUnit? Как использовать для тестирования?](#Что-такое-JUnit-Как-использовать-для-тестирования)
+ [Что такое функциональное тестирование чем отличается от модульного?](#Что-такое-функциональное-тестирование-чем-отличается-от-модульного)
+ [Расскажите про принцип TDD?](#Расскажите-про-принцип-TDD)
+ [Расскажите про принцип BDD?](#Расскажите-про-принцип-BDD)
+ [Что такое тестирование черным ящиком](#Что-такое-тестирование-черным-ящиком)


## Что такое SOLID
[подробнее](https://javarush.ru/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java)  https://habr.com/ru/company/mailru/blog/412699/ 
[подробнее](https://habr.com/ru/company/mailru/blog/412699/)  

Это аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании.
  + Single responsibility, 
  + Open-closed, 
  + Liskov substitution, 
  + Interface segregation 
  + Dependency inversion
  
  Цель принципов — проектировать модули, которые:   
  + легко расширяемы
  + легко понимаемы
  + повторно используемы
  + исключают эффект домино при изменении в коде    

[к оглавлению](#SOLID)

## Для чего используются JavaDoc  
Как правило, все существующие среды разработки IDE приложений Java предлагают решение по связыванию кода с документацией
в процессе разработки с использованием javadoc. Для этого необходимо соответствующим образом написать комментарий к коду, 
т.е. документировать. Java комментарии необходимы как для комментирования программы, так и для составления или оформления документации.    

**Javadoc - инструмент для создания из комментариев документации, обрабатывая файл с исходным текстом программы,
выделяет помеченную документацию из комментариев и связывает с именами соответствующих классов, методов и полей.**
Написание ряда комментариев не влияет на производительность программы Java, так как все комментарии удаляются во время компиляции.    

Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java.
Javadoc также предоставляет API для создания доклетов и тэглетов, которые позволяют программисту анализировать структуру Java-приложения.

Doclet — программы работающие со средством Javadoc для генерации документации по исходному коду написанному на Java:  
**Сгенирировать javadoc в виде html - файлов в Идее: Tools | Generate JavaDoc**          
Утилита javadoc в качестве входных данных принимает файл с исходным кодом программы, для которого генерируется НТМL файл.
Документация для каждого класса содержится в отдельном НТМL файле. Кроме этого, создается дерево индексов и иерархии.
Могут быть сгенерированы и другие НТМL файлы.  
 
Не надо увлекаться Javadoc - ХОРОШЕЕ НАЗВАНИЕ + ТЕСТЫ = ДОКУМЕНТАЦИЯ!  
[подробнее](https://habr.com/ru/post/97320/) 
[подробнее](https://www.jetbrains.com/help/idea/working-with-code-documentation.html#generate-javadoc)
[подробнее](http://espressocode.top/what-is-javadoc-tool-and-how-to-use-it/)
[подробнее](http://java-online.ru/java-javadoc.xhtml)  
[к оглавлению](#SOLID)

## Как писать JavaDoc

Утилита javadoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. 
НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.  
Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. 
В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело комментариев; заканчивается комбинацией символов */.

В тело комментариев можно вставлять различные дескрипторы. Каждый дескриптор, начинающийся с символа '@' должен стоять первым в строке. 
Несколько дескрипторов одного и того же типа необходимо группировать вместе. 
Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого описания.

```java
/** 
 * Класс продукции со свойствами <b>maker</b> и <b>price</b>.
 * @autor Киса Воробьянинов
 * @version 2.1
*/
class Product
{
    /** Поле производитель */
    private String maker;

    /** Поле цена */
    public double price;

    /** 
     * Конструктор - создание нового объекта
     * @see Product#Product(String, double)
     */
    Product()
    {
        setMaker("");
        price=0;
    }

    /** 
     * Конструктор - создание нового объекта с определенными значениями
     * @param maker - производитель
     * @param price - цена
     * @see Product#Product()
     */
    Product(String maker,double price){
        this.setMaker(maker);
        this.price=price;
    }

    /**
     * Функция получения значения поля {@link Product#maker}
     * @return возвращает название производителя
     */
    public String getMaker() {
        return maker;
    }

   /**
     * Процедура определения производителя {@link Product#maker}
     * @param maker - производитель
     */
    public void setMaker(String maker) {
        this.maker = maker;
    }
}
```

[к оглавлению](#SOLID)

## Что такое Java code convention

Это документ Oracle по правилам оформления кода.
Соглашения по офрмлению кода важны для программистов по ряду причин:

+ Соглашения по оформлению кода делают исходный код программ более удобочитаемым, позволяя инженерам быстрее и лучше понимать новый код.
+ Если вы предоствляете исходный код как продукт, вы должны убедится, что он хорошо оформлен и упакован как любой другой продукт, который вы создаете
+ Вряд ли какое-либо программное обеспечение все время поддерживается первоначальным разработчиком.
+ 80% от стоимости программного обеспечения приходится на его обслуживание.  
[Code conventions](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf)

[к оглавлению](#SOLID)  

## Антипаттерн Божественный Объект

Боже́ственный объе́кт (англ. God object) — антипаттерн объектно-ориентированного программирования, описывающий объект, 
который хранит в себе «слишком много» или делает «слишком много».  
Основная идея модульного программирования состоит в том, что большая задача делится на меньшие относительно независимые подзадачи
(принцип «разделяй и властвуй»). В развитии модульного программирования — объектно-ориентированном программировании — 
этот принцип выражается в создании множества объектов, каждый из которых решает только свою собственную задачу.  
Подход «божественного объекта» противоположен этому принципу: основная часть функциональности программы кодируется в одном объекте.
Так как этот объект хранит большое количество данных и имеет много методов, его роль в программе становится «божественной» (всеобъемлющей). 
Вместо того, чтобы общаться друг с другом непосредственно, другие объекты полагаются на божественный объект.   
Так как на божественный объект ссылается так много кода, его обслуживание (внесение изменений) становится сложным: 
велик риск сломать существующую функциональность.  
Хотя божественные объекты считаются плохой практикой программирования, поскольку вредят поддерживаемости кода, 
они могут быть полезны для работы при ограниченных ресурсах (в микроконтроллерах или мобильных телефонах), 
где производительность важнее, чем поддерживаемость кода.  

[к оглавлению](#SOLID)  

## Расскажите про принципы составления Java класса

+ **Принцип единственной ответственности (SRP).** Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.
+ **Принцип открытости/закрытости (OCP)** программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
+ **Принцип подстановки Барбары Лисков (LSP)** Это вариация принципа открытости/закрытости, о котором говорилось ранее. 
Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.  
+ **Принцип разделения интерфейса (ISP)** клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
+ **Принцип инверсии зависимостей (DIP)** зависимости внутри системы строятся на основе абстракций

[к оглавлению](#SOLID)

## Что такое SRP
A module should have one, and only one, reason to change  
Каждый объект решает только свою собственную задачу.  
  
Принцип единственной ответственности  — каждый объект должен иметь одну ответственность и эта ответственность
должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.    

Мартин определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только одну причину для изменений.
Например, представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:  
может измениться формат отчёта и может измениться формат печати.    
Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. 
SRP говорит, что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна ответственность.           

Формализм 1. Определение SRP  
Разделяйте элементы так, чтобы каждый из них был ответственен за что-то одно.
Ответственность расшифровывается как "повод для изменения". То есть каждый элемент имеет только один повод для изменения, в терминах бизнес логики.
Потенциальные изменения бизнес логики должны быть локализованы. Изменяемые вместе элементы должны быть рядом.  

Формализм 2. Необходимые критерии самопроверки.  
1. Задайте себе вопрос — что делает этот класс/метод/модуль/сервис. вы должны ответить на него простым определением.  
2. Фикс некоторого бага или добавление новой фичи затрагивает минимальное количество файлов/классов. В идеале — один.  
3. Если несколько разработчиков работают над разными фичами вашего проекта, то вероятность мердж -конфликта, 
то есть вероятность того, что один и тот же файл/класс будет изменен у нескольких разработчиков одновременно — минимальна.  
(Если при добавлении новой операции "Вылить водку под стол" вам нужно затронуть логировщик, операцию выпивания и выливания — 
то похоже, что ответственности разделены криво. Безусловно, это не всегда возможно, но нужно стараться снизить этот показатель.)  
4. При уточняющем вопросе про бизнес логику (от разработчика или менеджера) вы лезете строго в один класс/файл и получаете информацию только от туда.
(Фичи, правила или алгоритмы компактно написаны каждая в одном месте, а не разбросаны флагами по всему пространству кода.)  
5. Нейминг понятен.(Наш класс или метод ответственен за что-то одно, и ответственность отражена в его названии)  

Ошибаться можно по разному:  
+ Сделать слишком большие объекты, склеив разные ответственности
+ Передробить, разделив единую ответственность на много разных типов
+ Неверно определить границы ответственности  
Важно запомнить правило: "ошибаться лучше в большую сторону", или "не уверены — не дробите".
Если, например, ваш класс собирает в себе две ответственности — то он по прежнему понятен и его можно распилить 
на два с минимальным изменением клиентского кода. Собирать же из осколков стекла стакан, как правило,
сложнее из-за размазанного по нескольким файлам контекста и отсутствия необходимых зависимостей в клиентском коде.    
     
[подробнее](https://habr.com/ru/post/454290/)    

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе SRP

Например, рассмотрим этот код:

```java
class Animal {
Animal[] animals; 

    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
```

Класс Animal, представленный здесь, описывает какое-то животное. Этот класс нарушает принцип единственной ответственности.  
В соответствии с принципом единственной ответственности класс должен решать лишь какую-то одну задачу. 
Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя свойствами объекта в конструкторе и в методе getAnimalName.

Как такая структура класса может привести к проблемам?  
Если изменится порядок работы с хранилищем данных, используемым приложением, то придётся вносить изменения во все классы, работающие с хранилищем.
Такая архитектура не отличается гибкостью, изменения одних подсистем затрагивают другие, что напоминает эффект домино.  

Для того чтобы привести вышеприведённый код в соответствие с принципом единственной ответственности, 
создадим ещё один класс, единственной задачей которого является работа с хранилищем, в частности — сохранение в нём объектов класса Animal:

```java
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
}
class AnimalDB {
    getAnimal(a: Animal) { }
    saveAnimal(a: Animal) { }
}
```

Последствия нарушения SRP

**Вместо изменения в одном месте, придется вносить одни и те же изменения в разных местах. Если где-то пропустить, это приведет к ошибке.**  

Следующие приёмы позволяют соблюдать принцип единственной ответственности:  
Разработка через тестирование  
Шаблон «Выделение класса»  
Шаблон «Фасад»  
Шаблон «Proxy»  
DAO  

[к оглавлению](#SOLID)

## Что такое OCP
Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения.  
**Это особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение пересмотра кода,
модульного тестирования и других подобных процедур, чтобы получить право на использование его в программном продукте.
Код, подчиняющийся данному принципу, не изменяется при расширении и поэтому не требует таких трудозатрат.**  
   
Термин «принцип открытости/закрытости» имеет два значения:    
+ Принцип открытости/закрытости Мейера (наследование):  
Идея была в том, что однажды разработанная реализация класса в дальнейшем требует только исправления ошибок,
а новые или изменённые функции требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса 
через механизм наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса.      
+ Полиморфный принцип открытости/закрытости:  
Принцип открытости/закрытости стал де-факто переопределён для применения с абстрактными интерфейсами,
реализации которых могут быть изменены, и могут быть созданы множественные реализации и полиморфно замещены одна на другую.
В противоположность применения Мейером, это определение поддерживает идею наследования от абстрактных базовых классов. 
Спецификации интерфейсов могут быть переиспользованы через наследование, но реализации изменяться не должны. 
Существующий интерфейс должен быть закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот интерфейс.   
 
A software artifact should be open for extension but closed for modification.
(You should be able to extend a classes behavior, without modifying it)   

Это определенно может ввести в ступор. Как можно расширить поведение класса без его модификации? 
В текущей формулировке Роберт Мартин оперирует понятием артефакт, т.е. jar, dll, gem, npm package. 
Чтобы расширить поведение, нужно воспользоваться динамическим полиморфизмом.  
Например, наше приложение должно отправлять уведомления. Используя dependency inversion, наш модуль объявляет только интерфейс отправки уведомлений, но не реализацию. 
Таким образом, логика нашего приложения содержится в одном dll файле, а класс отправки уведомлений, реализующий интерфейс — в другом. 
Таким образом, мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы отправки уведомлений.

Этот принцип тесно связан с LSP и DIP, которые мы рассмотрим далее.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе OCP

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. 
Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его
и переопределить некоторые функции.  

Рассмотри на примере класса OrderRepository.

```java
class OrderRepository
{
	public function load($orderID)
	{
		$pdo = new PDO($this->config->getDsn(), $this->config->getDBUser(), $this->config->getDBPassword());
		$statement = $pdo->prepare('SELECT * FROM `orders` WHERE id=:id');
		$statement->execute(array(':id' => $orderID));
		return $query->fetchObject('Order');	
	}
	public function save($order){/*...*/}
	public function update($order){/*...*/}
	public function delete($order){/*...*/}
}
```

В данном случае хранилищем у нас является база данных. например, MySQL. 
Но вдруг мы захотели подгружать наши данные о заказах, например, через API стороннего сервера, который, допустим, берёт данные из 1С. 
Какие изменения нам надо будет внести? Есть несколько вариантов, например, непосредственно изменить методы класса OrderRepository, 
но этот не соответствует принципу открытости/закрытости, так как класс закрыт для модификации, 
да и **внесение изменений в уже хорошо работающий класс нежелательно.** 
Значит, можно наследоваться от класса OrderRepository и переопределить все методы, но это решение не самое лучше, 
так как при добавлении метода в OrderRepository нам придётся добавить аналогичные методы во все его наследники. 
Поэтому для выполнения принципа открытости/закрытости лучше применить следующее решение — создать интерфейc IOrderSource, 
который будет реализовываться соответствующими классами MySQLOrderSource, ApiOrderSource и так далее.

[к оглавлению](#SOLID)

## Последствия нарушения OCP  
+ Вам нужно написать тест для старого класса - это плохо, лучше написать тест для нового класса.  
(потому что написать короткий тест на отдельно добавленный функционал гораздо проще, чем разбираться и переписывать кучу чужих тестов)
+ Вам необходимо повторно развернуть приложение, если есть два клиента: A (которым не нужны новые функции) и B (кому нужны новые функции)  
Т.е. если бы OCP выполнялось, клиент А мог бы дальше использовать приложение.  
+ Вы можете допустить ошибку в работающей системе.    
Т.е. проще отследить ошибку в добавленном отдельно фукционале, чем перебирать весь проект, пытаясь понять, на что повлияли новые изменения.    

Если нам нужно добавить новые реализации поведения функции, то при модификации кода, а не расширении, мы сильно усложним код.
(читаемость, слабую связанность итд) Также может появится необходимость изменить связанные классы.    

[к оглавлению](#SOLID)

## Что такое LSP

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе LSP

Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, 
чтобы не нарушалась функциональность с точки зрения клиента. 
То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

Предположим у нас есть класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. 
У данного класса есть метод isValid который возвращает true или false:

```java
public class OrderStockValidator {

    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }

        return true;
    }
}
```

Также предположим, что некоторые заказы нужно валидировать иначе: проверять, 
все ли товары заказа находятся на складе и все ли товары упакованы. 
Для этого мы расширили класс OrderStockValidator классом OrderStockAndPackValidator:

```java
public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if ( !item.isInStock() || !item.isPacked() ){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }

        return true;
    }
}
```

Однако в данном классе мы нарушили принцип LSP, так как вместо того, чтобы вернуть false, если заказ не прошел валидацию, 
наш метод бросает исключение IllegalStateException. Клиенты данного кода не рассчитывают на такое: они ожидают возвращения true или false. 
Это может привести к ошибкам в работе программы.

[к оглавлению](#SOLID)

## Последствия нарушения LSP

Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

[к оглавлению](#SOLID)

## Что такое ISP

Make fine grained interfaces that are client specific.

Разделение интерфейса облегчает использование и тестирование модулей.
Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
Клиенты не должны зависеть от интерфейсов, которые они не используют.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе ISP

Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

[к оглавлению](#SOLID)

## Последствия нарушения ISP

Рассмотрим пример. Разработчик Алекс создал интерфейс "отчет" и добавил два метода: generateExcel() и generatedPdf(). 
Теперь клиент А хочет использовать этот интерфейс, но он намерен использовать отчеты только в PDF-формате, а не в Excel. 
Устроит ли его такая функциональность?

Нет. Он должен будет реализовать два метода, один из которых по большому счету не нужен и существует только благодаря Алексу — дизайнеру программного обеспечения. 
Клиент воспользуется либо другим интерфейсом, либо оставит поле для Excel пустым.

Так в чем же решение? Оно состоит в разделении существующего интерфейса на два более мелких. 
Один — отчет в формате PDF, второй — отчет в формате Excel. Это даст пользователю возможность использовать только необходимый для него функционал.

Также классы, реализующие толстые интерфейсы сложнее тестировать, т.к. в них сразу несолько функциональностей (отсюда сразу еще и нарушение SRP).

[к оглавлению](#SOLID)

## Что такое DIP

Depend on abstractions, not on concretions.

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Что такое модули верхних уровней? Как определить этот уровень? Как оказалось, все очень просто. 
Чем ближе модуль к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с BD, интерфейсом пользователя, низкого уровня. 
А модули, реализующие бизнес-логику — высокого уровня.

Что такое зависимость модулей? Это ссылка на модуль в исходном коде, т.е. import, require и т.п. 
С помощью динамического полиморфизма в runtime можно обратить эту зависимость.

Есть модуль Logic, реализующий логику, который должен отсылать уведомления. 
В этом же пакете объявляется интерфейс ISender, который используется Logic. 
Уровнем ниже, в другом пакете объявляется ConcreteSender, реализующий ISender. 
Получается, что в момент компиляции Logic не зависит от ConcreteSender. 
В runtime, например, через конструктор в Logic устанавливается экземпляр ConcreteSender.

Отдельно стоит отметить частый вопрос “Зачем плодить абстракции, если мы не собираемся заменять базу данных?”.
Логика тут следующая. На старте проекта, мы знаем, что будем использовать реляционную базу данных, и это точно будет Postgresql, 
а для поиска — ElasticSearch. Мы даже не планируем их менять в будущем. Но мы хотим отложить принятие решений о том, 
какая будет схема таблиц, какие будут индексы, и т.п. до момента, пока это не станет проблемой. 
И на этот момент мы будем обладать достаточной информацией, чтобы принять правильное решение. 
Также мы можем раньше отладить логику нашего приложения, реализовать интерфейс, собрать обратную связь от заказчика, 
и минимизировать последующие изменения, ведь многое реализовано только в виде заглушек.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе DIP
Вместо зависимостей на конкретные реализации нужно использовать абстракции.  

**Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции.**

Попробуем продемонстрировать это на примере. Говоря о принципе единственной ответственности, мы рассматривали некоторый OrderProcessor. 
Взглянем еще раз на код данного класса: 

```java
public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

}
``` 

В данном примере наш OrderProcessor зависит от двух конкретных классов MySQLOrderRepository и ConfirmationEmailSender

Правильный вариант:

```java
public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```

[к оглавлению](#SOLID)

## Последствия нарушения DIP

Вместо замены реализации, придется изменять сам класс.

[к оглавлению](#SOLID)  

## Dry, Kiss, Yagni  

**DRY – Don’t repeat yourself (не повторяй себя)**  
  
Код, имеющий опредленную функциональность должен находиться в одном месте. (+ модульность компонентов)   
**DRY призван уменьшать сложность, разделяя систему на управляемые компоненты.**  
Сухой принцип формулируется так: "каждая часть знания должна иметь единую, однозначную, авторитетную репрезентацию внутри системы".  

Фишка DRY — как можно больше атомарной реализации. 
Основная причина, имхо — сложность поддержки двух и более одинаковых кусков кода 
(нашли баг в одном куске — нужно не забыть исправить в других местах, где этот же код используется).   

**KISS – keep it simple stupid (делайте вещи проще)**  
KISS следует применять на этапе определения требований. Стараясь реализовать требования клиента в вашем коде, попытайтесь выделить следующее:  
Функционал, который имеет нецелесообразное отношение между затратами и профитом.  
Функционал, который жестко зависит от другого.  
Функционал, который, с большой вероятностью, склонен расти, и становиться сложнее.  
Заменять необоснованно сложные решения на простые.  
Пример, использование CSV вместо Excel в статье, т.к. большинство функций Excel не понадобится в программе.     

**You ain’t gonna need it – вам это не понадобится**  
В большей степени это относится к коммерческой разработке, где нужно получить результат здесь и сейчас в сжатых условиях.  

Пример: не делать мобильную версию приложения вообще, а сделать только десктопную, чтобы не тратить лишние ресурсы. (если это не критично)  
Или не делать лишних абстракций и сооответственно лишнего кода:        
  
Это значит, что то, что не задумано в системе, не должно появляться в коде. 
Достаточно часто доступ к БД осуществляется через абстракцию, которая может иметь реализацию для разных драйверов – MySQL, PostgreSQL, Oracle. 
Если вы работаете над сайтом, который размещается на LAMP стеке – какова вероятность того, что клиент сменит БД? 
Не забывайте, что концепт всегда пишется под бюджет – верно? Если в бюджете не предусмотрена абстракция для БД – этой абстракции не должно быть в системе. 
Если вдруг клиенту понадобится переехать на другую БД, довольно очевидно, что это повлечет затраты на изменение системы.  
**Вы, должно быть, заметили разницу между YAGNI и DRY системами. 
Последняя призвана уменьшать сложность, разделяя систему на управляемые компоненты, в то время, как первая уменьшает сложность, 
уменьшая количество этих компонент. 
Принцип YAGNI похож на KISS – он старается делать вещи как можно проще. 
Но KISS старается искать простые решения, а YAGNI просто не делает никаких решений!**  
Т.е. нас учили смотреть наперед, учитывая все возможные изменения. Иногда это критично для больших проектов, но никак не для маленьких. 
Перестаньте думать о будущем! Если вдруг небольшому сайту потребуются радикальные изменения, будет лучше начать все с нуля.
И это не такая уж и проблема, учитывая общие инвестиции.  

"Если вы хотите быть опытным и востребованным разработчиком, вам нужно отточить ваши навыки в принципе YAGNI. 
Если вы хотите сохранить вашу страсть, вам придется постоянно сопротивляться ему."     

[подробнее](https://habr.com/ru/post/144611/)    

[к оглавлению](#SOLID)  

## AJAX  

AJAX (аббревиатура от Asynchronous JavaScript and XML) – это технология взаимодействия с сервером без перезагрузки страницы.
Поскольку не требуется каждый раз обновлять страницу целиком, повышается скорость работы с сайтом и удобство его использования.      
   
[подробнее](https://yandex.ru/turbo/wiki.rookee.ru/s/ajax/)    

[к оглавлению](#SOLID)  

## Water Flow  
[подробнее](https://skillbox.ru/media/management/waterfall/)  
Waterfall — модель «Водопад», водопадная или каскадная разработка продуктов.
Она подобно потоку воды направляет команды решать задачи последовательно и строго по изначальному плану.     
Классическая методология Waterfall — это работа по заранее написанному и согласованному ТЗ.
Waterfall - жесткая последовательная модель, в которой главным элементом является ТЗ, по которому нужно следовать и не отходить от него.    

До появления Scrum в мире разработки программного обеспечения было принято использовать «водопадный подход». 
Работа над продуктом велась по следующему плану:  
+ Определить требования к продукту.
+ Спланировать весь проект от начала до конца.
+ Написать код.
+ Протестировать продукт.  
Разработчики согласовывали план работы с заказчиком и четко следовали техническому заданию. Когда продукт был готов, 
его тестировали, но уже не было возможности что-то поменять. Поэтому если выявлялись ошибки, 
приходилось начинать все сначала, а сроки работы увеличивались.  

Принципы водопадной модели разработки  
Документы и инструкции — это важно, всё должно быть зафиксировано.  
Следующий этап работы не начинается, пока не закончится предыдущий.  
Пропускать этапы нельзя.  
Если требования к продукту изменились после согласования — переписываем ТЗ.  
Нельзя возвращаться на предыдущий этап, чтобы что-то изменить.  
Нет итераций, есть один общий процесс создания продукта.  
Выявлять и исправлять ошибки — только на этапе тестирования.  
Клиент не участвует в создании продукта после постановки ТЗ.   
 
## AGILE  
[подробнее](https://skillbox.ru/media/management/chto_takoe_agile/)  
Agile — это способ командного взаимодействия, позволяющий совместно создавать продукты».  
Agile - гибкая модель, в которой требования к проекту могут меняться, Работающая часть продукта после первой итерации, 
Клиент видит и может влиять на промежуточный результат.  

Неудобные вопросы  
Как сделать так, чтобы задержка в работе одного отдела не останавливала остальных?  
Как справиться с тем, чтобы разработка плана проекта не занимала до 30% времени от всего объема его реализации?
  
Пока другие только готовят документацию, agile-команды стремятся представить работоспособный прототип.    
  
Манифест гибкой разработки ПО 
+ Люди важнее инструментов.
+ Качество продукта важнее документации.
+ Взаимодействие с заказчиком важнее контракта.
+ Готовность к изменениям важнее установленного плана.  
  
Эти четыре пункта стали основой для появления Agile, гибкого процесса разработки программного обеспечения. 
Позже были созданы 12 принципов, которые и сейчас используются в любой agile-методологии. 
 
12 принципов Agile  
1. Главное — хорошее ПО и довольный заказчик.
2. Готовность к изменениям в любой момент.
3. Полностью рабочее ПО — как можно чаще.
4. Встреча команды — лучше всего для обмена информацией.
5. Заказчик и команда разработки должны работать вместе.
6. Доверять людям делать свою работу.
7. Есть рабочее ПО — есть прогресс.
8. Гибкие процессы — непрерывное развитие.
9. Внимание к качеству способствует гибкости.
10. Простота процесса позволяет не делать лишней работы.
11. Самоорганизующаяся команда лучше работает.
12. Постоянное стремление к большей эффективности.  

Как внедрить Agile?  
Во-первых, вам предстоит упразднить иерархичность и при этом добиться того,
чтобы все участники процессов смогли на равных разделить ответственность за результат.  
Во-вторых, переход к итеративной разработке заставит сосредоточиться на том, 
чтобы каждый из этапов гарантированно привносил в продукт что-то новое. Это непросто, 
инерция плановой разработки будет преследовать вас первые несколько месяцев.    

## SCRUM 
[подробнее](https://otus.ru/nest/post/838/)   
[подробнее](https://skillbox.ru/media/management/kak_ponyat_scrum/)  
  
Scrum - методология гибкого процесса разработки программного обеспечения, которая базируется на agile-принципах.  
Основные принципы Scrum.    
Scrum всегда ориентируется на клиента, который должен получить желаемый продукт вовремя и с минимальными затратами.  
Product Backlog содержит необходимые для выполнения рабочие задачи (такие как Story, Bug, Task и др.), отсортированные в порядке приоритета (срочности).  
 
Этого можно достичь при соблюдении нескольких обязательных принципов.    
+ Работа короткими циклами (спринтами)  
Планируйте один спринт, а не весь проект сразу. Каждый спринт — период времени,
за который команда работает над полностью законченной частью продукта.  
+ Гибкость. «Проверять и адаптироваться»  
Гибкость процесса и тестирование продукта после каждого спринта. Если что-то идет не так, 
команда всегда готова сменить стратегию разработки или пересмотреть бэклог продукта. (план может корректироваться в отличии л ьводопадного подхода)  
+ Участие заказчика и пользователей в создании продукта.  
Заказчик не стоит в стороне, а полностью задействован в работе. Для это существует роль владельца продукта, 
которую выполняет сам заказчик или его представитель. Именно через него команда взаимодействует с пользователями. 
Так как разработка ведется короткими этапами, пользователи подключаются к тестированию почти сразу.
После первичного тестирования им открывают доступ к продукту, а владелец продукта собирает обратную связь. 
Так команда может совершенствовать результат.
+ Взаимодействие команды  

Состав  Scrum-команды:  
+ Владелец продукта. Человек, который представляет продукт и является посредником между заказчиком, пользователями и командой разработчиков.
Иногда им может быть сам заказчик.
+ Scrum-мастер. Чаще всего — специально нанятый сотрудник, который ведет команду к результату. 
Он не управляет командой, но наблюдает за исполнением основных принципов Scrum. 
Его задача — не давить, не делать всю работу самому и не распределять обязанности, но помогать, направлять и решать вопросы, которые тормозят процесс разработки.
+ Разработчики. В составе scrum-команды всегда есть люди с разным набором навыков. 
Так, команда из пяти-девяти человек ведет весь проект от начала до конца. Одна команда — один готовый продукт.  

Процесс работы scrum-команды:    
Планирование бэклога спринта  
Scrum-митинг, или совещание на ходу  
Когда что-то идет не так  
Scrum-доска  
Обзор результата  

[к оглавлению](#SOLID)  

## Kanban  
[подробнее](https://geekbrains.ru/posts/kanban_howto)  
Канбан (яп. カンバン камбан) — система организации производства и снабжения, позволяющая реализовать принцип «точно в срок».     

В основе Kanban’а лежит простая мысль: объем незавершенной работы надо ограничивать. Любую новую задачу можно начинать не ранее, 
чем выполнена одна из начатых. Это не значит, что в работе должна быть только одна задача, — их может быть несколько. 
Принципиально, чтобы это количество было ограничено.  

Чтобы контролировать выполнение задач было проще, процесс визуализируют на доске, разделенной на несколько колонок. 
Важное правило: количество задач-листков, находящихся в работе, ограничено. Точный максимум определяют, исходя из возможностей коллектива.
 Взяться за следующую задачу разработчик сможет не раньше, чем закончит работу с предыдущей.  
 
Искусственное ограничение выглядит контрэффективным, но на практике оно вырабатывает совершенно иной подход и отношение к незавершенным делам. 
Любая задержка, промедление в выполнении работы благодаря Kanban-доске будут сразу заметны — не только самому разработчику, но и всем коллегам.  

Поскольку количество задач в колонках Kanban-доски ограничено, время выполнения каждой меньше зависит от внеплановых работ и завалов.
Для всех задач можно измерить среднее время выполнения и сделать разработку более предсказуемой и удобной в планировании. 
Кроме того, это позволяет выявить проблемы и сложности, замедляющие работу, и избавиться от них.  
1. Сделайте работу наглядной.  

Разделите на задачи.  
Каждую запишите на стикер.
Распределите стикеры по графам на доске.
2. Ограничьте объем незавершенной работы.

Вычислите, какое количество незавершенных задач будет оптимальным на каждом этапе.

3. Измеряйте время

Вычислите оперативное время, которое в среднем требуется для выполнения каждой задачи.
Оптимизируйте работу, чтобы свести оперативное время к минимуму.
Прогнозируйте работу над задачами.  
 
[к оглавлению](#SOLID)
## Расскажите что такое автоматическое тестирование

Это часть процесса тестирования на этапе контроля качества в процессе разработки программного обеспечения. 
Оно использует программные средства для выполнения тестов и проверки результатов выполнения, что помогает сократить время тестирования и упростить его процесс.

[к оглавлению](#SOLID)

## Как в Java осуществляется автоматическое тестирование

С помощью библиотек для автоматического тестирования (например):  

+ **Junit**	JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.  
+ **Selenium**	Selenium is a set of different software tools each with a different approach to supporting test automation of web applications across many platforms.  
Сделать на Selenium можно практически все, что и юзер.  Много примеров на java.  
+ **QTP* - один из ведущих инструментов автоматизации функционального тестирования.  
Включает в себя: Selenium WebDriver, Selenium Server, Selenium IDE.  
Selenium IDE – плагин к браузеру Firefox, который может записывать действия пользователя.  
Selenium WebDriver – это программная библиотека для управления браузерами.(отправляет команды непосредственно в браузер и получает результаты)     
Selenium Server – это сервер, который позволяет управлять браузером с удалённой машины, по сети.  
[подробнее](https://habr.com/ru/post/152653/) 
[подробнее](https://coderlessons.com/tutorials/kachestvo-programmnogo-obespecheniia/uchitsia-selen/selen-kratkoe-rukovodstvo ) 

[к оглавлению](#SOLID)  
[подробнее](http://java-online.ru/blog-junit.xhtml)  

## Что такое JUnit Как использовать для тестирования  
JUnit — библиотека для модульного тестирования программ Java, т. е. тестирования отдельных участков кода, например, методов или классов.  
JUnit позволяет в любой момент быстро убедиться в работоспособности кода.  
Юнит тесты классов и функций являются своего рода документацией к тому, что ожидается в результате их выполнения.  
Юнит тестирование по определению является тестированием белого ящика.  
 
+ Аннотация @BeforeClass обозначает методы, которые будут вызваны до создания экземпляра тест-класса; 
методы должны быть public static void. Данную аннотацию (метод) имеет смысл использовать для тестирования в случае,
когда класс содержит несколько тестов, использующих различные предустановки, либо когда несколько тестов используют одни и те же данные,
чтобы не тратить время на их создание для каждого теста.
+ Аннотация @AfterClass связана по смыслу с @BeforeClass, но выполняет методы после тестирования класса. Как и в случае с @BeforeClass,
 методы должны быть public static void. 
+ Аннотация @Test обозначает тестовые методы.  Здесь размещаются сами проверки. Кроме того, в данной аннотации можно использовать два параметра,
expected — задает ожидаемое исключение и timeout — задает время, по истечению которого тест считается провалившимся.  
@Test(timeout = 1000)  
  public void infinity() {  
      while (true);}  
+ Если один из тестов по какой-либо серьезной причине необходимо отключить, например, тест постоянно завершается с ошибкой. 
Исправление теста можно отложить до светлого будущего аннотированием @Ignore. Если поместить эту аннотацию на класс, то все тесты в этом классе будут отключены.  
+ JUnit позволяет использовать определенные разработчиком правила до и после выполнения теста, которые расширяют функционал. 
Например, есть встроенные правила для задания таймаута для теста (Timeout), для работы с временными файлами(TemporaryFolder),
для задания ожидаемых исключений (ExpectedException) -здесь можно проверить дополнительные моменты, например, 
текстовое сообщение ошибки [подробнее](https://coderlessons.com/articles/java/pravilo-junit-expectedexception-vne-osnov) и др.
Для объявления правила необходимо создать public не static поле типа производного от MethodRule и аннотировать его с помощью ключевого слова Rule.
+  Тестовые классы, которые содержат в себе тестовые методы, можно объединить в наборы тестов (Suite).  
+ Аннотация Theories параметризирует тестовый метод, а не конструктор. Данные помечаются с помощью @DataPoints и @DataPoint, тестовый метод — с помощью @Theory.  
+ Если необходимо выполнить тест в определенном порядке, то можно воспользоваться аннотацией @FixMethodOrder(MethodSorters.NAME_ASCENDING)       

```java
import org.junit.Test;
import junit.framework.Assert;
 
public class MathTest {
    @Test
    public void testEquals() {
        Assert.assertEquals(4, 2 + 2);
        Assert.assertTrue(4 == 2 + 2);
    }
}  
```  

Список типов проверок Asserts:  
+ fail(), fail(String message) - прерывание теста с ошибкой, т.е. тест будет неудачным  
+ assertArrayEquals(byte[] expecteds, byte[] actuals) - проверка массивов на равенство    
 
[к оглавлению](#SOLID)

## Что такое функциональное тестирование чем отличается от модульного

Обычно используют два вида автоматических тестов:
+ **Модульное тестирование** (тестирование отдельных частей продукта, обычно отдельных функций/методов);    
+ **Интеграцио́нное тести́рование** — тестирование взаимодействия и совместной работы компонентов;    
Обычно интеграционное тестирование проводится после модульного тестирования и предшествует функциональному тестированию.
+ **Функциональное тестирование** — тестирование всей системы как целого;
(тестирование некого функционала продукта, при этом продукт воспринимается как единый «чёрный ящик»)  
+ приемное тестирование — итоговое тестирование готовой системы на соответствие требованиям.  

Самое главное — даже успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: 
ведь одна и та же функция может быть использована в различных частях системы, 
в то время как юнит-тест писался для неё с оглядкой лишь на один вариант использования.   

Юнит тестирование прежде всего нужно самим разработчикам, для быстрого нахождения ошибок или проверки последствий рефакторинга.    
Функциональные тесты полностью определяют работоспособность продукта. И прежде всего нужны заказчику/руководителю разработки.   

[к оглавлению](#SOLID)

## Расскажите про принцип TDD
Разработка на основе тестов.  

Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, 
которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, 
покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, 
и под конец проводится рефакторинг нового кода к соответствующим стандартам.

[к оглавлению](#SOLID)

## Расскажите про принцип BDD  
Разработка на основе поведения, тесты пишутся на ествественном языке (почти англ-ий), перечисляя последовательность действий с программой и желаемый результат.  
**Критерии приёмки должны быть описаны через сценарий, который реализует пользователь, чтобы достигнуть результата.**   
 
BDD (Behavior-driven development) — это методология разработки ПО, являющаяся ответвлением TDD.  
Основной идеей данной методологии является совмещение в процессе разработки чисто технических интересов и интересов бизнеса, 
позволяя тем самым управляющему персоналу и программистам говорить на одном языке. 
Для общения между этими группами персонала используется предметно-ориентированный язык, основу которого представляют конструкции из естественного языка, 
понятные неспециалисту, обычно выражающие поведение программного продукта и ожидаемые результаты.  
    
BDD - это разработка, основанная на описании поведения. То есть, есть специальный человек(или люди), который пишет описания вида: 
"я как пользователь хочу, когда нажали кнопку пуск, тогда показывалось меню как на картинке". (там есть специально выделенные ключевые слова). 
Программисты давно написали специальные тулы (например, cucumber), которые подобные описания переводят в тесты (иногда совсем прозрачно для программиста).

В чем преимущество BDD?  
тесты читаемые для не программистов.  
их легко изменять. Они часто пишутся почти на чистом английском.  
их теперь может писать product owner или другие заинтересованные лица.  
результаты выполнения тестов более "человечные".  
тесты не зависят от целевого языка программирования. Миграция на другой язык сильно упрощается.    
[подробнее](https://medium.com/@lucyhackwrench/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-tdd-%D0%B8-bdd-%D0%BD%D0%B0-%D0%BF%D0%B0%D0%BB%D1%8C%D1%86%D0%B0%D1%85-%D0%B8-%D1%87%D1%82%D0%BE-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BE-%D0%BD%D0%B8%D1%85-%D1%84%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4%D0%B5%D1%80-701a10e06bb9)   
[подробнее](https://ru.stackoverflow.com/questions/655063/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-bdd-%D0%B2-%D1%87%D1%91%D0%BC-%D0%B5%D0%B3%D0%BE-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BE%D1%82-tdd)

[к оглавлению](#SOLID)

## Что такое тестирование черным ящиком

тестирование черного ящика – это:
+ тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента или системы.
+ тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа 
функциональной или нефункциональной спецификации компонента или системы  без знания ее внутреннего устройства.

Почему именно «черный ящик»? Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит. 
Целью этой техники является поиск ошибок в таких категориях:

+ неправильно реализованные или недостающие функции;
+ ошибки интерфейса;
+ ошибки в структурах данных или организации доступа к внешним базам данных;
+ ошибки поведения или недостаточная производительности системы;

Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. 
Нужно концентрироваться на том, что программа делает, а не на том, как она это делает.

[к оглавлению](#SOLID)

