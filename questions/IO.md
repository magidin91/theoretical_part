Отредактировать, добавить из ворда    
1. Расскажите общее идею что такое поток ввода-вывода?
2. Что такое Java IO?
3. Что такое Java NIO?
4. Что такое Scanner? 
5. Как работает Scanner внутри?
6. Какие базовые методы существуют в Scanner?
7. Что такое байтовый поток? Как он реализован внутри?
8. Что такое символьный поток? Как он реализован внутри?
9. Что такое буферизированный поток? 
10. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вызов?
11. Как осуществлятся ввод и вывод из командной строки?
12. Что такое класс Console? Расскажите его АПИ.
13. Что такое поток данных? Data stream.
14. Что такое поток объектов, Object stream.
15. Что такое Path? Как он реализуется на разных ОС?
16. Как получить список файлов? (Files.walkFileTree)
17. Как проверить что файловая сущность является файлом или папкой?
18. Как удалить файл?
19. Как переместить файл?
20. Как управлять аттрибутами файла?
21. Как создать файл? 
22. Как создать директорию?
23. Как записать в файл?
24. Как прочитать данные из файла?

Ответы:
1. Расскажите общее идею что такое поток ввода-вывода?
Поток – это  абстракция, которая используется для чтения или записи данных.
Объект, из которого можно считать данные, называется потоком ввода, а объект, в который можно записывать данные - потоком вывода.

2. Что такое Java IO?
IO API – это библиотека, которая предоставляет апи для для чтения и записи данных в ресурс. Для этих целей предусмотрены потоки ввода и вывода, классы которых определены в этом пакете.

3. Что такое Java NIO?
https://www.tune-it.ru/web/ivanuskov/blog/-/blogs/java-nio
Java NIO:
1.	Неблокирующий
Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.

Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.
2.	Асинхронный – сразу получает данные из источника (в io – получает данные только при вызове методов read/write) 
3.	Буфер-ориентированный -Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Буфер-ориентированный : Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. 
https://habr.com/ru/post/235585/

4. Что такое Scanner? 
Класс Scanner имеет богатый набор API, это класс для считывания данных из потока, который обычно используется для разбиения входных данных на токены, т.е. для анализа пользовательского ввода (метод hasNext) Часто используется для консольного ввода.

5. Как работает Scanner внутри?
radix – это число уникальных символов в системе счисления или алфавите, в 10-значной = 10, в двоичной = 2 итд. 
the radix used to interpret the token as an int value
hasNextInt – проверяет radix,  парсит строку,  сохраняет ее в кеш.
// A cache of the last primitive type scanned
private Object typeCache = null;

nextInt – проверяет есть ли значение, проверяет является ли кеш нужным типом, если да то отдает значение, если кеша нет парсит строку.
( это не точно)
eturns true if the next token in this scanner's input can be
 * interpreted as an int value in the default radix using the
 * {@link #nextInt} method. The scanner does not advance past any input.
 *
 * @return true if and only if this scanner's next token is a valid
 *         int value
 * @throws IllegalStateException if this scanner is closed
 */
public boolean hasNextInt() {
    return hasNextInt(defaultRadix);
}


https://en.wikipedia.org/wiki/Radix
6. Какие базовые методы существуют в Scanner?
hasNextInt() — метод проверяет, является ли следующая порция введенных данных числом, или нет (возвращает, соответственно, true или false). 
hasNextLine() — проверяет, является ли следующая порция данных строкой. 
hasNextByte(), hasNextShort(), hasNextLong(), hasNextFloat(), hasNextDouble() — все эти методы делают то же для остальных типов данных.
nextXXX – считывает данные
next() – считывает данные до пробела.
public String findInLine(Pattern pattern)
Attempts to find the next occurrence of the specified pattern ignoring
* delimiters. If the pattern is found before the next line separator, the
* scanner advances past the input that matched and returns the string that
* matched the pattern.

7. Что такое байтовый поток? Как он реализован внутри?
В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода)
Класс InputStream implements Closeable
Класс InputStream является базовым для всех классов, управляющих байтовыми потоками ввода. Рассмотрим его основные методы:
int read(): возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1.
Класс OutputStream
Класс OutputStream является базовым классом для всех классов, которые работают с бинарными потоками записи. Свою функциональность он реализует через следующие методы:
void flush(): очищает буфер вывода, записывая все его содержимое

8. Что такое символьный поток? Как он реализован внутри?
Классы – наследники Reader и Writer предоставляют функционл для записи и чтения текстовых данных.
FileWriter, PrintWriter, FileReader, InputStreamReader

Абстрактные классы Reader и Writer
Абстрактный класс Reader предоставляет функционал для чтения текстовой информации. Рассмотрим его основные методы:
absract void close(): закрывает поток ввода
int read(): возвращает целочисленное представление следующего символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число -1
Класс Writer определяет функционал для всех символьных потоков вывода. Его основные методы:
void write(String str): записывает в поток строку

9. Что такое буферизированный поток? 
Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.
В библиотеке java.io.* предусмотрены классы BufferedOutputStream и BufferedInputStream, специально предназначенные для буферизации ввода/вывода приложений Java.
Как ими пользоваться?
Очень просто. Вы можете передать конструкторам этих классов ссылки на потоки, которые необходимо буферизовать. 
BufferedOutputStream bos; 
bos = new BufferedOutputStream(new FileOutputStream("myfile.txt"));
Буферизация символьных потоков. BufferedReader и BufferedWriter
Класс BufferedWriter записывает текст в поток, предварительно буферизируя записываемые символы, тем самым снижая количество обращений к физическому носителю для записи данных.

Класс BufferedWriter имеет следующие конструкторы:
BufferedWriter(Writer out) 
BufferedWriter(Writer out, int sz)
Класс BufferedReader имеет следующие конструкторы:

	BufferedReader(Reader in) 
BufferedReader(Reader in, int sz) 
Второй конструктор, кроме потока ввода, из которого производится чтение, также определяет размер буфера, в который будут считываться символы.
Так как BufferedReader наследуется от класса Reader, то он может использовать все те методы для чтения из потока, которые определены в Reader. И также BufferedReader определяет свой собственный метод readLine(), который позволяет считывать из потока построчно.
А также Stream<String> lines(), который возвразщает поток строк из источника.

Как понятно из названия, буферизованный поток – это поток, имеющий буфер.
Буфер подцепляется к источнику и записывает данные большим блоком.(т.е. если пишем данные, то сначала записываем в буфер, а потом буфер большими блоками пишет в источник)
Предположим, Вы записываете какие-то данные на диск, вызывая метод write(...) потока. При использовании буферизованного потока, после вызова write(...) данные не пишутся на диск, они сохраняются в буфере потока. На диск данные попадают либо при явном вызове flush(), либо при закрытии потока.
В чем выгода? – В том, что при каждом вызове write(...) Вы не трогаете диск, а пишите на него бОльшими блоками данных.
Аналогично, при чтении, считывается бОльший блок данных, чем нужен Вам. При последующем чтении Вы получаете информацию не с диска, а из буфера.
В общем случае выгода заключается в том, что при каждом чтении/записи Вы не трогаете сам непосредственный источник данных, чтение/запись на который происходит медленнее, чем чтение/запись из буфера.

Если ввод не буферизовать, а вместо этого читать файлы по байту за раз, получится очень медленно — при каждом чтении где-то внутри будет вызываться системный read(), а системные вызовы в целом медленнее. К тому же, в целом с данными вообще лучше работать большими группами за раз.

10. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вызов?
Форматируемый вывод. PrintStream и PrintWriter

Эти классы имеют метод printf, с помощью которого можно записать отформатированную строку, используя другие объекты в ней.

Соответственно этот метод есть в System.out, т.к. его тип PrintStream.
public PrintWriter printf(String format, Object ... args) {
    return format(format, args);
}
Разница между PrintStream и PrintWriter
Это может показаться легкомысленным, но PrintStream печатает в OutputStream, а PrintWriter печатает в Writer. Хорошо, я сомневаюсь, что получу какие-либо баллы за утверждение очевидного. Но там больше.
Основным отличием в том, что OutputStream - это поток байтов, а Writer - это поток символов.
Если OutputStream имеет дело с байтами, как насчет PrintStream.print(String)? Он преобразует символы в байты, используя кодировку платформы по умолчанию. 
Использование кодировки по умолчанию, как правило, плохо, так как это может привести к ошибкам при переходе с одной платформы на другую, особенно если вы генерируете файл на одной платформе и используете его на другой.
При использовании Writer вы обычно указываете используемую кодировку, избегая любых зависимостей платформы.
Зачем беспокоиться о наличии PrintStream в JDK, поскольку основной целью является написание символов, а не байтов? PrintStream предшествовал JDK 1.1, только  после были представлены потоки символов Reader/Writer. Я полагаю, что Sun заменил  бы PrintStream  на PrintWriter  если бы только тот факт, что он так широко используется. (В конце концов, вы бы не хотели, чтобы каждый вызов System.out генерировал устаревшее предупреждение API! Кроме того, изменение типа с PrintStream на PrintWriter в стандартных выходных потоках нарушило бы существующие приложения.)
С PrintStream вы придерживаетесь стандартного кодирования платформы.
С PrintWriter вы можете передать OutputStreamWriter с определенным кодированием.

Основное логическое отличие, что PrintWriter не имеет метода write(byte buf[]) и соответственно не может записывать сырые байты в поток. Также PrintStream пишет только в потоки байтов, в то время как в PrintWriter добавлена возможность писать в поток символов (Writer).
В целом в настоящее время PrintStream имеет смысл использовать, только когда мы хотим записать в поток сырые байты.
Для вывода информации в выходной поток PrintStream использует следующие методы:
•	println(): вывод строковой информации с переводом строки
•	print(): вывод строковой информации без перевода строки
•	printf(): форматированный вывод
PrintStream – символьно-байтовый поток.
В документации к JDK версии 1.1 вместо класса PrintStream, использование которого демонстрировалось в предыдущем примере, рекомендуется применять новый класс PrintWriter. В нем есть все методы для форматированного вывода данных, предусмотренные в классе PrintStream.
В чем же отличие класса PrintWriter от PrintStream?
Прежде всего, в классе PrintWriter применен усовершенствованный способ работы с символами UNICODE и другой механизм буферизации вывода. Остановимся на буферизации.
В классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод print или println. При использовании класса PrintWriter вы можете отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода flush.
Кроме того, методы класса PrintWriter никогда не создают исключений. Для проверки ошибок вы должны вызывать метод checkError.


11. Как осуществлятся ввод и вывод из командной строки?
По умолчанию ввод с клавиатуры, вывод на монитор.
Класс System содержит также три переменные предопределенных потоков ввода-вывода: in, out и err
•	Переменная System.out ссылается на стандартный поток вывода. По умолчанию это консоль.
•	Переменная System.in ссылается на стандартный поток ввода, которым по умолчанию является клавиатура.
•	System.err - для ошибок.

12. Что такое класс Console? Расскажите его АПИ.
в идее не фурычит, нужно использовать командную строку напрмиер.
http://espressocode.top/java-io-console-class-java/
https://coderlessons.com/tutorials/java-tekhnologii/izuchite-paket-java-io/java-io-console-klass
Альтернатива стандратным потокам ввода / вывода класс Console.
Для создание экземпляра используется System.console(). Метод может вернуть NULL если консоль недоступна. Консоль позволяет вводить пароль используя метод readPassword (не видны символы при вводе, не сохраняется в памяти).
•	flush(): выводит на консоль все данные из буфера
•	format(): выводит на консоль строку с использованием форматирования
•	printf(): выводит на консоль строку с использованием форматирования (фактически то же самое, что и предыдущий метод)
•	String readLine(): считывает с консоли введенную пользователем строку
•	char[] readPassword(): считывает с консоли введенную пользователем строку, при этом символы строки не отображаются на консоли
Важно, что доступ к консоли мы можем получить только из самой консоли. При запуске, например, в Netbeans вызов System.console() будет возвращать значение null. Поэтому при работе с консолью желательно проверять полученное значение на null.

Console используется для чтения и записи на консоль, если таковая существует.
Консоль — это в первую очередь вспомогательный класс, поскольку большая часть ее функций доступна через System.in и System.out. Однако его использование может упростить некоторые типы взаимодействий с консолью, особенно при чтении строк из консоли.
Консоль не предоставляет конструкторов. Вместо этого объект Console получается путем вызова System.console (), который показан здесь:
printf: удобный метод для записи отформатированной строки в выходной поток этой консоли, используя указанную строку формата и аргументы.
readLine: предоставляет отформатированное приглашение, затем читает одну строку текста из консоли. (ждет ввода и читает строку)
str = con.readLine("Enter your name: ");

13. Что такое поток данных? Data stream.
Классы DataOutputStream и DataInputStream позволяют записывать и считывать данные примитивных типов.(а также строку в формате UTF-8)

Объект DataOutputStream в конструкторе принимает поток вывода: DataOutputStream (OutputStream out).

writeBoolean(boolean v) : записывает в поток булевое однобайтовое значение
writeByte(int v): записывает в поток 1 байт, которые представлен в виде целочисленного значения
….
writeUTF(String str): записывает в поток строку в кодировке UTF-8


14. Что такое поток объектов, Object stream.
Сериализация представляет процесс записи состояния объекта в поток, соответственно процесс извлечения или восстановления состояния объекта из потока называется десериализацией. Сериализация очень удобна, когда идет работа со сложными объектами.
Сразу надо сказать, что сериализовать можно только те объекты, которые реализуют интерфейс Serializable. Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.
Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.
Для создания объекта ObjectOutputStream в конструктор передается поток, в который производится запись:
ObjectOutputStream(OutputStream out)
void writeObject(Object obj): записывает в поток отдельный объект
try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.dat")))
        {
            Person p = new Person("Sam", 33, 178, true);
            oos.writeObject(p);
        }
        catch(Exception ex){
             
            System.out.println(ex.getMessage());
        } 
Если нужно сериализовать список объектов, можно использовать ArrayList этих объектов, тогда мы запишем в поток только один объект ArrayList и будет проще прочитать его из потока.
Класс ObjectInputStream отвечает за обратный процесс - чтение ранее сериализованных данных из потока. В конструкторе он принимает ссылку на поток ввода:
	ObjectInputStream(InputStream in)

Модификатор Transient может применяться к переменным-членам класса, чтобы отключить сериализацию для этих переменных-членов. Каждое поле, помеченное как переходное, не будет сериализовано. При десериалзации в поле будет null.
У каждого класса, реализующего Serializable, должно быть поле, содержащее уникальный идентификатор версии сериализованного класса, оно объявляется следующим образом:
private static final long serialVersionUID = 1L;
Значение идентификатора (в данном случае 1, но может быть любым) должно быть разным у разных классов. Оно вычисляется по содержимому класса - полям, методам и порядку их объявления. И если мы поменяем в нашем классе тип поля или количество полей, то идентификатор изменится. Идентификатор тоже записывается в файл при сериализации класса.
Когда мы пытаемся провести десериализацию, то есть восстановить объект из набора байт, значение идентификатора сравнивается со значением serialVersionUID класса в нашей программе. Если значения не совпадают, будет выброшено исключение java.io.InvalidClassException. Чтобы избежать таких ситуаций, мы просто вручную задаем для нашего класса этот идентификатор (иначе его значение будет непредсказуемо генерироваться компилятором).
Помимо стандартной сериализации, можно создать свою, записывающую данные в нужном формате. Для этого вместо Serializable класс должен реализовывать интерфейс Externalizable с 2 методами writeExternal (сериализация) и readExternal (десериализация). Идентификатор в этом случае не нужен.


15. Что такое Path? Как он реализуется на разных ОС?
https://javarush.ru/groups/posts/2275-files-path !!!
Java 7 представляет новую абстракцию для пути, а именно интерфейс Path. Он используется в новых функциях и API, по всему NIO.2. Объект пути содержит имена каталогов и файлов, которые составляют полный путь до файла/каталога, представленного объектом Path; Path содержит методы для извлечения элементов пути, манипуляций с ними и их добавления.
Это произошло из-за того, что у класса File был ряд недостатков. Например, в нем не было метода copy(), который позволил бы скопировать файл из одного места в другое (казалось бы, явно необходимая функция). Кроме того, в классе File было достаточно много методов, которые возвращали boolean-значения. При ошибке такой метод возвращает false, а не выбрасывает исключение, что делает диагностику ошибок и установление их причин очень непростым делом.
Files — это утилитный класс, куда были вынесены статические методы из класса File. Files — это примерно то же, что и Arrays или Collections, только работает он с файлами, а не с массивами и коллекциями :) Он сосредоточен на управлении файлами и директориями. Используя статические методы Files, мы можем создавать, удалять и перемещать файлы и директории.
Path имеет несколько реализаций под определенные файловые системы.
Формат записи пути к файлу отличается, и то что будет работать в windows не обязательно будет работать в linux или какой то другой ос. Чтобы максимально сгладить эту проблему, в javadoc прописан способ указания путей.

Path path = FileSystems.getDefault().getPath("logs", "access.log");
BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
Так же есть способ с использованием разделителя, который зависит от текущей файловой системы.
String path = "dir" + File.pathSeparator + "file.txt";

Да я тоже видел этот пример в доках Path path = FileSystems.getDefault().getPath("logs", "access.log"); но не понял синтаксис аргументов. Так-то вроде понятно что logs это папка, а access.log это имя файла. НО в итоге то какой разделитель использовать если у меня ("/a/b/c/logs","/a/b/c/logs/access.log") ??? как применить этот кейс не понятно??? – Pavel 17 дек '16 в 17:15
•	
В этом то и фишка, что туда можно передать произвольное количество строк, которые будут разделяться между собой символом. А этот символ уже определяется в зависимости от файловой системы. – Artem Konovalov 18 дек '16 в 6:51
•	1
В вашем примере будет что то вроде .getPath("a","b","c","logs","access.log") – Artem Konovalov 18 дек '16 в 6:53


Путь к файлу, в разных системх может записываться по разному, \ или / поэтому лучше использовать File.separator для построения пути
// Cоздание объекта Path через вызов статического метода get() класса Paths 
Path testFilePath = Paths.get("/home/heorhi/testfile.txt"); 
         
//Пример строки создания объекта Path пути для запуска в Windows 
Path testFilePath = Paths.get("D:\\test\\testfile.txt");

16. Как получить список файлов?
https://javarush.ru/groups/posts/2275-files-path
Через File[] listFiles(): 
возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
Через Files.walk API 
•	try (Stream<Path> paths = Files.walk(Paths.get("/home/you/Desktop"))) {
    paths
        .filter(Files::isRegularFile)
        .forEach(System.out::println);
}

Через Files.walkFileTree()
https://javarush.ru/groups/posts/2275-files-path
Во-первых, нам понадобится FileVisitor. FileVisitor — это специальный класс, в котором инкапсулируется вся логика обхода дерева файлов.
, т.е. Реализуем интерфейс FileVisitor с его методами, и передаем объект этой реализации в метод Files.walkFileTree(Paths.get("C:\\Users\\Username\\Desktop\\testFolder"), new MyFileVisitor());
(public class MyFileVisitor extends SimpleFileVisitor<Path> {

   @Override
   public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {

       List<String> lines = Files.readAllLines(file);
       for (String s: lines) {
           if (s.contains("This is the file we need")) {
               System.out.println("Нужный файл обнаружен!");
               System.out.println(file.toAbsolutePath());
           }
       }

       return FileVisitResult.CONTINUE;
   }
}
В данном случае наш класс наследуется от SimpleFileVisitor. Это упрощенная версия FileVisitor, в которой нужно переопределить всего один метод: visitFile(). Здесь мы и описываем что нужно делать с каждым файлом в каждой директории. Если тебе нужна более сложная логика обхода, стоит наследоваться от FileVisitor. Там понадобится реализовать еще 3 метода: 
•	preVisitDirectory() — логика, которую надо выполнять перед входом в папку;
•	visitFileFailed() — что делать, если вход в файл невозможен (нет доступа, или другие причины);
•	postVisitDirectory() — логика, которую надо выполнять после захода в папку.


17. Как проверить что файловая сущность является файлом или папкой?
boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог
boolean isFile(): возвращает значение true, если по указанному пути находится файл

18. Как удалить файл?
boolean delete(): удаляет каталог или файл по пути, который передан в конструктор. При удачном удалении возвращает true.
19. Как переместить файл?
Т.е. создаем новый файл, с новым путем файла и передаем его в метод file.renameTo(movedFile)
File movedFile = new File("src\\main\\java\\shildt\\io\\NewDir\\moved_notes3.txt");
if(renamed_file.renameTo(movedFile)){
    System.out.println("Файл переименован успешно");;
}else{
    System.out.println("Файл не был переименован");
}
Или скопировать содержимое этого файла в новый.
https://javadevblog.com/kak-pereimenovat-fajl-v-java.html
также в NIO есть метод move

20. Как управлять аттрибутами файла?
стр. 863 Шилдт
NIO
Есть 2 способа:
1)	Получаем объект, реализующий нужный интерфейс атрибута. Files.readAttributes
DosFileAttributes dosFileAttributes = Files.readAttributes(path, DosFileAttributes.class);
System.out.println(dosFileAttributes.isReadOnly());

2)	Получаем объект представления нужного класса атрибута. Files.getFileAttributeView
Path path = FileSystems.getDefault().getPath("src\\main\\java\\shildt\\io", "created_file.txt");
BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);

Также есть некоторые методы в самом классе Files.

С файлами связан ряд атрибутов, обозначающих время создания файла, время
его последней модификации, размер файла или каталог. Система ввода-вывода
NIO организует атрибуты файлов в виде иерархии различных интерфейсов, определенных
в пакете j ava. nio. f i le. at tribute. На вершине этой иерархии находится
интерфейс BasicFileAttributes, инкапсулирующий ряд атрибутов,
которые обычно применяются в большинстве файловых систем. (содержит проверку является файл каталогом файл, время создания итд)

Производными от интерфейса BasicFileAttributes являются следующие
интерфейсы: DosFileAttributes и PosixFileAttributes. 
DosFileAttributes:
boolean isArchive()
boolean isHidden()
boolean isReadOnly()
boolean isSystem()
PosixFileAttributes:
GroupPrincipal group()
UserPrincipal owner()
Set<PosixFilePermission>
permissions()

Существуют разные способы доступа к атрибутам файлов. В частности, вызвав
статический метод readAttributes (),определенный в классе Files, можно
получить объект, инкапсулирующий атрибуты файла. Ниже приведена одна из общих форм объявления этого метода.
static <А extends BasicFileAttributes> А readAttributes(Path путь, Class<A> тип_атрибута,
LinkOption ... параметры) throws IOException
Получение DosFileAttributes:
DosFileAttributes dosFileAttributes = Files.readAttributes(path, DosFileAttributes.class);
System.out.println(dosFileAttributes.isReadOnly());
Еще один способ доступа к атрибутам файла состоит в том, чтобы вызвать метод
getFileAttributeView (),определенный в классе Files. В системе ввода-
вывода NIO определяется несколько интерфейсов для представлений атрибутов,
в том числе AttributeView, BasicFileAttributeView, DosFile
At tributeView и PosixFileAttributeView.

Следует, однако, иметь в виду, что допустимые атрибуты файлов поддерживаются
полностью не во всех файловых системах. Например, атрибуты файлов
DOS относятся к файловой системе FAT, хотя первоначально они были определены
в файловой системе DOS. Те атрибуты, которые применяются в обширном
ряде файловых систем, описаны в интерфейсе BasicFileAttributes. Поэтому
именно они и употребляются в примерах из этой главы.

Path path = FileSystems.getDefault().getPath("src\\main\\java\\shildt\\io", "created_file.txt");
BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
System.out.println(basicView.readAttributes().lastAccessTime().toMillis());


21. Как создать файл? 
 Создаем объект, инкапсулирующий путь с к файлу (сам файлможет быть уже создан)
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");
file1.createNewFile(); - непосредственно создаем файл по указанному пути.

22. Как создать директорию?
File dir1 = new File("src\\main\\java\\shildt\\io\\NewDir");
dir1.mkdir();
dir1.mkdirs(); - создает каталог и создает всю иерархию родительских каталогов, указанных в пути.

23. Как записать в файл?
1) FileWriter(File file)
2)  FileOutputStream(File file)
Или обернуть его для удобства в PrintWriter
PrintWriter out = new PrintWriter(new FileOutputStream(target))
out.print(“XXX”)

24. Как прочитать данные из файла?
IO:
1)	FileReader(File file)
BufferedReader read = new BufferedReader(new FileReader(source)
 read.lines().forEach(line ->…)
2)	FileInputStream(String fileName)
NIO:
Но класс Files позволяет не только управлять самими файлами, но и работать с его содержимым. Для записи данных в файл у него есть метод write(), а для чтения — целых 3: read(), readAllBytes() и readAllLines() Мы подробно остановимся на последнем. Почему именно на нем? Потому что у него есть очень интересный тип возвращаемого значения — List<String>!
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

import static java.nio.charset.StandardCharsets.UTF_8;

public class Main {

   public static void main(String[] args) throws IOException {

       List<String> lines = Files.readAllLines(Paths.get("C:\\Users\\Username\\Desktop\\pushkin.txt"), UTF_8);

       for (String s: lines) {
           System.out.println(s);
       }
   }
}
Также можно использоварть стримы:
Stream<String> stream = Files.lines(Paths.get("C:\\Users\\Username\\Desktop\\pushkin.txt"));

public class Main {

   public static void main(String[] args) throws IOException {

       Stream<String> stream = Files.lines(Paths.get("C:\\Users\\Username\\Desktop\\pushkin.txt"));

       List<String> result  = stream
               .filter(line -> line.startsWith("Как"))
               .map(String::toUpperCase)
               .collect(Collectors.toList());
       result.forEach(System.out::println);
   }
}
NIO, канальный ввод:

//Использовать канал ввода-вывода для чтения файла
puЬlic class ExplicitChannelRead
puЬlic static void main(String args[])
int count;
Path filepath = null;
// сначала получить путь к файлу
try {
filepath = Paths.get("test.txt");
catch(InvalidPathException е) {
System.out.println("Path Error" + е);
return;
// затем получить канал к этому файлу в
/!блоке оператора try с ресурсами
try (SeekaЬleByteChannel fChan =
Files.newByteChannel(filepath))
// выделить память под буфер
ByteBuffer mBuf = ByteBuffer.allocate(128);
do {
//читать данные из файла в буфер
count = fChan.read(mBuf);
//прекратить чтение по достижении конца файла
if(count != -1) {
//подготовить буфер к чтению из него данных
mBuf. rewind () ;
//читать байты данных из буфера и
/! выводить их на экран как символы
for(int i=O; i < count; i++)
System.out.print( (char)mBuf.get());
while(count != -1);
System.out.println();
catch (IOException е)
System.out.println("Oшибкa ввода-вывода" + е);
Работа в сети. Сокеты.
Хортсман. Библиотека Профессионала, том 2, стр 191
В основу работы в сети, поддерживаемой в Java, положено понятие сокета, обозначающего конечную точку в сети.
InetAddress
Этот класс служит для инкапсуляции как числового IР-адреса, так и его доменного
имени.
• static InetAddress getByName(String host)
• static InetAddress[] getAllByName(String host)
Конструируют объект типа InetAddress или массив всех межсетевых адресов для заданного имени хоста.
• static InetAddress getLocalHost()
Конструирует объект типа InetAddress для локального хоста.
• byte[] getAddressO
Возвращает массив байтов, содержащий числовой адрес.
• String getHostAddress()
Возвращает адрес хоста в виде символьной строки с десятичными числами, разделенными точками, например "132.163.4.102ч.
• String getHostName()
Возвращает имя хоста.

Продемонстрировать применение класса InetAddress:
import java.net.*;
class InetAddressTest
{
puЬlic static void main(String args[J)
throws UnknownHostException
InetAddress Address = InetAddress.getLocalHost();
System.out.println(Address);
Address = InetAddress.getByName("www.HerbSchildt.com");
System.out.println(Address);
InetAddress SW [] = InetAddress. getAllByName ( "www. nba. сот");
Глава 23. Работа в сети 893
for (int i=O; i<SW . length; i++)
System.out.println(SW[i]);
Ниже приведен результат, выводимый этой проrраммой. Безусловно, код, который
вы увидите на своей машине, может несколько отличаться от приведенноrо ниже.
default/166.203 . 115.212
www.HerbSchildt.com/2 16.92.65.4
www.nba.com/23.3.98.74
www.nba.com/23.3.98.75







Клиент
• Socket(String host, int port)
Создает сокет для соединения с указанным хостом или портом.
• InputStream getlnputStream()
• OutputStream getOutputStream ()
Получают поток ввода для чтения данных из сокета или записи данных в сокет.
Пример Клиента:
 
После открытия сокета метод getlnputStream () из класса java.net. Socket возвращает объект типа InputStream, который можно использовать как любой другой поток ввода. Получив поток ввода, рассматриваемая здесь программа приступает к выводу каждой введенной символьной строки в стандартный поток вывода. Этот процесс продолжается до тех пор, пока не завершится поток ввода или не разорвется соединение с сервером.
Класс Socket очень удобен для работы в сети, поскольку он скрывает все сложности и подробности установления сетевого соединения и передачи данных по сети, реализуемые средствами библиотеки Java. А пакет j ava. net, по существу, предоставляет тот же самый программный интерфейс, который используется для работы с файлами.

Ожидание ответа от сервера.
Socket s = new Socket(. . .);
s.setSoTimeout(10000); // истечение времени ожидания через 10 секунд.
Если величина времени ожидания была задана для сокета, то при выполнении всех последующих операций чтения и записи данных будет генерироваться исключение типа SocketTimeoutException по истечении времени ожидания до фактического завершения текущей операции.
Сервер
• ServerSocket(int port)
• Создает сокет на стороне сервера, контролирующего указанный порт.
• Socket accept()
• Ожидает соединения. Этот метод блокирует (т.е. переводит в режим ожидания) текущий поток до
тех пор, пока не будет установлено соединение. Возвращает объект типа Socket, через который программа может взаимодействовать с подключаемым клиентом.
• void close()
• Закрывает сокет на стороне сервера.















Пример Сервера:
 
http://localhost:9000/?msg=What чтобы отправить сообщение “What” на сервер из браузера.
Ответ сервера по протоколу http нужно писать в следующем виде (стандартный вид отправдяемого http файла):
out.write("HTTP/1.1 200 OK\r\n\r\n".getBytes()); //заголовок
 out.write("Hello, dear friend.".getBytes()); //тело



Многопоточный сервер:

 

 











Полузакрытие сокета

 


Прерываемые сокеты (не донца понял) стр. 206 Хортсман 2 том


java.net.InetSocketAddress 
• InetSocketAddress(String hostname, int port)
• Создает объект адреса с указанными именем сетевого узла (хоста) и номером порта, преобразуя имя узла в адрес при установлении соединения. Если преобразовать имя сетевого узла в адрес не
удается, устанавливается логическое значение true свойства unresolved.
• boolean isUnresolved()
• Возвращает логическое значение true, если для данного объекта не удается преобразовать имя сетевого узла в адрес.

java.nio.channels.SocketChannel 
• static SocketChannel open(SocketAddress address)
• Открывает канал для сокета и связывает его с удаленным сетевым узлом по указанному адресу.

java.nio.channels.Channels 
• static InputStream newInputStream(ReadableByteChannel channel)
• Создает поток ввода для чтения данных из указанного канала.
• static OutputStream newOutputStream(WritableByteChannel


Получение данных из Интернета (не вникал)
Классы URL и URLConnection инкапсулируют большую часть внутреннего механизма извлечения данных с удаленного веб-сайта. Объект типа URL создается следующим образом:
URL url = new URL (символьная строка с URL); 
Единый указатель ресурса (англ. Uniform Resource Locator— единообразный локатор (определитель местонахождения) ресурса. Он относится только к WEB – всемирной паутине. URI – более широков множество, в него входит не только WEB локаторы.
Если требуется только извлечь содержимое из указанного ресурса, достаточно вызвать метод openStream() из класса URL. Этот метод возвращает объект типа Input St ream. Поток ввода данного типа можно использовать обычным образом, например, создать объект типа Scanner:
InputStream inStream = url.openStream();
Scanner in = new Scanner(inStream);
java.net.URL 1.0
•
InputStream openStreamO
Открывает поток ввода для чтения данных из ресурса.
•
URLConnection openConnection();
Возвращает объект типа URLConnection, управляющий соединением с ресурсом.
Получение данных из Интернета 2 2 3
java.net.URLConnection 1.О
• void setDoInput(boolean dolnput)
• boolean getDoInputO
Если параметр dolnput принимает логическое значение.true, пользователь может принимать вводимые данные из текущего объекта типа URLConnection.
• void setDoOutput(boolean doOutput)
• boolean getDoOutput()
Если параметр doOutput принимает логическое значение true, пользователь может передавать выводимые данные в текущий объект типа URLConnection.
• void setlfModifiedSince(long time)
• long getlfModifiedSince()
Свойство ifModif iedSince настраивает данный объект типа URLConnection на извлечение только тех данных, которые были изменены после указанного момента времени. Время задается в секундах, начиная с полуночи 1 января 1970 г. по Гринвичу.
• void setUseCaches(boolean useCaches)
• boolean getUseCaches()
Если параметр useCaches принимает логическое значение true, данные можно извлечь из локального кеша. Следует, однако, иметь в виду, что кеш не поддерживается самим объектом типа
URLConnection. Поэтому кеш должен быть предоставлен внешней программой, например, браузером.
• void setAllowUserlnteraction(boolean allowUsrelnteraction)
• boolean getAllowUserlnteraction()
Если параметр allowUserlnteraction принимает логическое значение, у пользователя может
запрашиваться пароль. Следует, однако, иметь в виду, что у самого объекта типа URLConnection отсутствуют средства, требующиеся для выполнения подобных запросов. Поэтому запрос пароля должен быть организован во внешней программе, например, в браузере или подключаемом модуле.
• void setConnectTimeout(int timeout) 5.0
• int getConnectTimeout() 5.0
Устанавливают или возвращают величину времени ожидания (в миллисекундах) для соединения. Если время ожидания истечет до установления соединения, метод connect () из соответствующего потока ввода сгенерирует исключение типа SocketTimeoutException.
• void setReadTimeout(int timeout) 5.0
• int getReadTimeout() 5.0
Устанавливают или возвращают величину времени ожидания [в миллисекундах) для чтения данных. Если время ожидания истечет до успешного завершения операции чтения, метод read О сгенерирует исключение типа SocketTimeoutException.
• void setRequestProperty(String key, String value)
Устанавливает значение в поле заголовка.
• Map<String,List<String>> getRequestProperties() 1.4
Возвращает отображение со свойствами запроса. Все свойства одного и того же ключа вносятся в список.
• void connect()
Устанавливает соединение с удаленным ресурсом и получает данные заголовка из ответа.
• Map<String,List<String>> getHeaderFields() 1.4
Возвращает отображение с полями заголовка из ответа. Все свойства одного и того же ключа вносятся в список.
• String getHeaderFieldKey(int л)
Возвращает ключ л-го поля заголовка из ответа или пустое значение null, если л меньше или равно нулю или превышает количество полей.
• String getHeaderField(int л)
Возвращает значение л-го поля заголовка из ответа или пустое значение null, если л меньше или равно нулю или превышает количество полей.
• int getContentLength()
Возвращает длину доступного содержимого или -1, если длина неизвестна.
• String getContentType()
Возвращает тип содержимого, например, text/plain или image/gif.
• String getContentEncoding()
Возвращает кодировку содержимого, например gzip. Применяется редко, потому что используемая по умолчанию кодировка не всегда указывается в поле identity заголовка Content- Encoding.
• long getDateO
• long getExpiration()
• long getLastModifed()
Возвращают время создания, последней модификации ресурса или время, когда срок действия ресурса истекает. Время указывается в секундах, начиная с 1 января 1970 г. по Гринвичу.
• InputStream getlnputStream()
• OutputStream getOutputStream()
Возвращают поток ввода для чтения данных из ресурса или вывода для записи данных в ресурс.
• Object getContentO
Выбирает подходящий обработчик содержимого для чтения данных из ресурса. Этот метод вряд ли
полезен для чтения данных стандартного типа, например, text/plain или image/gif, кроме тех случаев, когда требуется создать собственный обработчик этих типов данных.
NIO
https://javarush.ru/groups/posts/2275-files-path
Система ввода-вывода NIO построена на двух основополагающих элементах буферах и каналах. В буфере хранятся данные, а канал предоставляет открытое соединение с устройством ввода-вывода, например файлом или сокетом. В общем, для применения системы ввода-вывода NIO требуется получить канал для устройства ввода-вывода и буфер для хранения данных. После этого можно оперировать буфером, вводя или выводя данные по мере надобности.
Про неблокируемость
Когда читаешь данные, то в блокирующем IO, если данные ещё недоступны, то поток блокируется. Например, если HDD их ещё недочитал. Или сетевой интерфейс их ещё не прислал. Заблокированый поток останавливает свою работу, поэтому разработчику нужно больше потоков, чтобы компенсировать простои CPU во время IO блокировок.
В неблокирующем IO, при чтении, просто возращается ноль новых данных, сообщая разработчику, что их нет. Поток не блокируется и его можно занять чем-то полезным, пока не появятся данные. Неблокирующее IO позволяет использовать меньше потоков, чтобы более эффективно использовать CPU и сэкономить на переключении конктекста. Это особенно критично для большого серверов с большим количеством клиентов.
Вы сразу строите конечный автомат для задачи "есть много сокетов с неопределёнными моментами получения-передачи данных".
Переход: "если данных нет - работаем со следующим сокетом" становится частью такого КА. Вместе с решением задачи "выбор рабочего сокета из набора имеющихся".
Буферы
Буферы определяются в пакете j ava. nio. Все буферы являются подклассами производными от класса Bu f f er, в котором определяются основные функциональные бвозможности, характерные для каждого буфера, в том числе текущая позиция, предел и емкость. Текущая пози11ия определяет индекс в буфере, с которого в следующий раз начнется операция чтения или записи данных. Текущая позиция перемещается после выполнения большинства операций чтения или записи. Предел определяет значение индекса за позицией последней доступной ячейки в буфере. Емкость определяет количество элементов, которые можно хранить в буфере. Зачастую предел равен емкости буфера. В классе Bu f f er поддерживается также отметка и очистка буфера.
 

Каналы
Каналы определены в пакете j ava. nio. channels. Канал представляет открытое соединение с источником или адресатом ввода-вывода. Классы каналов реализуют интерфейс Channel.

 
Еще один способ получения канала подразумевает использование одного из статических методов, определенных в классе Files. Например, используя класс Files, можно получить байтовый канал при вызове метода newByteChannel ().Он возвращает канал типа SeekaЬleByteChannel, т.е. интерфейса, реализуемого классом FileChannel. (Более подробно класс Files рассматривается далее в этой главе.
Объединение двух путей
Path newPath = path.resolve(childPath);
FileVisitor
public class Renamer {
    public static void main(String[] args) throws IOException {
       Files.walkFileTree(Paths.get("C:\\Users\\Misha\\Java\\other\\Test_directory"), new MyFileVisitor());
    }
}

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;

public class MyFileVisitor implements FileVisitor<Path> {
    private int plusNumber;

    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
       /* file.resolveSibling("KEK"+ Math.random())) - переменовывает тольтко файлы и только их имена,
        т.е. file.txt->newFile.txt*/
        plusNumber++;
        Files.move(file, file.resolveSibling("KEK_" + plusNumber + ".txt"));
//       List<String> lines = Files.readAllLines(file);
//       for (String s: lines) {
//           if (s.contains("This is the file we need")) {
//               System.out.println("Нужный файл обнаружен!");
//               System.out.println(file.toAbsolutePath());
//           }
//       }
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        plusNumber++;
        //объединяем два пути методом resolve
        Path newFile = dir.getParent().resolve("KEK_" + plusNumber);
        //переименовываем файл
        Files.move(dir, newFile);
        return FileVisitResult.CONTINUE;
    }
}

Следует также иметь в виду, что при обновлении унаследованного кода, в котором используется класс Filе, определенный в пакете jаvа.iо, экземпляр класса F i l е можно преобразовать в экземпляр интерфейса Р а t h, вызвав метод t о Р а t h ( ) для объекта типа File. Кроме того, экземпляр класса File можно получить, вызвав метод toFile (),определяемый в интерфейсе Path.
Files
В Java 7 создатели языка решили изменить работу с файлами и каталогами.
Это произошло из-за того, что у класса File был ряд недостатков. Например, в нем не было метода copy(), который позволил бы скопировать файл из одного места в другое (казалось бы, явно необходимая функция).
Кроме того, в классе File было достаточно много методов, которые возвращали boolean-значения. При ошибке такой метод возвращает false, а не выбрасывает исключение, что делает диагностику ошибок и установление их причин очень непростым делом.
Вместо единого класса File появились целых 3 класса: Paths, Path и Files. Ну а если быть точным, Path — это интерфейс, а не класс.

static Path copy(Path источник, Path адресат CopyOption…. способ) throws IOException:
Копирует файл из источника по указанному адресату заданным способом.
static Boolean isRegularFile(Path путь, LinkOptions … параметры) - Возвращает логическое значение true, если параметр путь определяет файл, а иначе - логическое значение false. Если же аргумент параметры не определен, то используются символические ссылки. С целью предотвратить следование по символическим ссылкам аргумент параметры должен принимать значение NOFOLLOW LINКS
 
 

 








Ввод с помощью каналов
 




Автоматически отобраем (считываем файл в буфер)

 







Запись в файл:

 





Второй вариант:
 
Как видите, в данном примере отсутствуют явные операции записи непосредственно в канал. Буфер mBu f сопоставляется с файлом, поэтому изменения в буфере автоматически отражаются в основном файле.
 


 












Перечисление содержимого каталога
DirectoryStream<Path> - поток, который содержит path всех файлов и папок в этой папке. Его можно перебрать черз цикл for each, т.к. поток реализует интерфейс Iterable.

 
Содержимое каталога можно отфильтровать двумя способами. 
Самый простой из них- воспользоваться следующей общей формой метода newDirectory
Stream (): static DirectoryStream<Path> newDirectoryStream(Path путь_к_каталогу, String шаблон) throws IOException
В этой форме получаются только те файлы, имена которых совпадают с заданным шаблоном.

 


 
Селекторы
https://www.codeflow.site/ru/article/java-nio-selector
http://javatutor.net/articles/working-with-selectors
https://hr-vector.com/java/nio-selector
Селектор предоставляет механизм для мониторинга одного или нескольких каналов NIO и определения, когда один или несколько каналов становятся доступными для передачи данных.
Таким образом, один поток может использоваться для управления несколькими каналами и, следовательно, несколькими сетевыми подключениями.
Создаем селектор, регистрируем каналы, далее получаем ключи, перебираем эти ключи, получая из них готовые к действию каналы, записываем данные, удаляем ключ, смотрим следующий.

Селектор Java NIO — это компонент, который может проверять один или несколько экземпляров Java NIO Channel и определять, какие каналы готовы, например, для чтения или записи. Таким образом, один поток может управлять несколькими каналами и, следовательно, несколькими сетевыми подключениями.
Создание селектора
Вы создаете Selector, вызывая метод Selector.open(), например так:
1	Selector selector = Selector.open();
Регистрация каналов с помощью селектора
Чтобы использовать канал с селектором, вы должны зарегистрировать канал с помощью селектора. Это делается с помощью метода SelectableChannel.register(), например:
	channel.configureBlocking(false);
	 

	SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
Канал должен находиться в неблокирующем режиме для использования с селектором. Это означает, что вы не можете использовать FileChannel с селектором, поскольку FileChannel нельзя переключить в неблокирующий режим. Сокетные каналы будут работать нормально.
Есть прекрасный класс в Nio java.nio.channels.Selector, который позволяет избежать создания большого числа потоков, следя за активностью каналов. Подписавшись на некое событие, можно получить ключи каналов, которые это действие совершили, и дальше уже работать с ними. Отслеживание активности каналов и возвращение только нужных берет на себя Selector. Таким образом, можно работать с несколькими канал
  