## Garbage Collection

+ [JRE, JVM, JDK](#JRE-JVM-JDK)
+ [Расскажите о Stack, Heap, Metaspace](#расскажите-о-stack-heap-metaspace)
+ [Чем java отличается от с++](#Чем-java-отличается-от-с)
+ [Что такое менеджер памяти](#Что-такое-менеджер-памяти)
+ [Какой механизм используется в Java для управления памятью](#Какой-механизм-используется-в-Java-для-управления-памятью)
+ [Опишите процесс работы сборщика мусора](#Опишите-процесс-работы-сборщика-мусора)
+ [Какие алгоритмы сборщика вы знаете](#Какие-алгоритмы-сборщика-вы-знаете)
+ [Чем отличаются сборщики мусора](#Чем-отличаются-сборщики-мусора)
+ [Расскажите про утилиты для анализа памяти](#Расскажите-про-утилиты-для-анализа-памяти)
+ [Что такое ссылки](#Что-такое-ссылки)
+ [Какие типы ссылок вы знаете](#Какие-типы-ссылок-вы-знаете)
+ [Чем они отличаются](#Чем-они-отличаются)
+ [Расскажите про String pool, Int pool](#расскажите-про-string-pool-int-pool)
+ [Расскажите о String.intern](#расскажите-о-stringintern)
+ [Что такое профайлер](#Что-такое-профайлер)
+ [Как использовать VisualVM](#Как-использовать-VisualVM)
+ [Чем отличается sampling от profiling](#Чем-отличается-sampling-от-profiling)
+ [Расскажите о benchmark](#Расскажите-о-benchmark)
+ [Расскажите о методе finalized](#Расскажите-о-методе-finalized)
+ [Расскажите о методе clone](#Расскажите-о-методе-clone)
+ [Утечки памяти](#Утечки_памяти)

## JRE, JVM, JDK 

## **JDK** (Java Development Kit)  

JDK - комплект разработчика приложений на языке Java, включающий в себя **компилятор** (javac), 
**документацию**, **различные утилиты** и исполнительную систему JRE.  
Компилятор — это программа, способная принимать исходные файлы с расширением .java, 
которые являются обычным текстом, и превращать их в исполняемые файлы с расширением .class. (команда javac)
[подробнее](https://topjava.ru/blog/what-is-the-jdk)   

## **JRE** (Java Runtime Environment)    
Это среда выполнения java программ. 
Узнать версию JRE можно с помощью командной строки:  **java -version**. 

JRE - это часть программного обеспечения, предназначенная для запуска другого программного обеспечения. 

JRE сглаживает разнообразие операционных систем, гарантируя,
что программы Java могут работать практически на любой ОС без изменений.
(принцип write once, run anywhere/написано однажды, выполняется где угодно.)
Среда выполнения Java — это уровень программного обеспечения, 
работающий поверх операционной системы и предоставляющий дополнительные службы, специфичные для Java.
Она также обеспечивает дополнительные возможности. Автоматическое управление памятью — одна из самых важных функций JRE,
 гарантирующая что программистам не придется вручную управлять распределением памяти.

JRE — это программа, которая берет ваш Java-код, объединяет его с необходимыми библиотеками и запускает JVM для его выполнения. 
Как среда выполнения для Java, **JRE содержит основные библиотеки классов (io, awt, net итд), загрузчик классов и JVM **
(которая включает Java Interpreter, GC, Threading и т.д.). 
+ Загрузчик классов отвечает за правильную загрузку классов и их связь с основными библиотеками классов Java.
Эта важная часть программного обеспечения загружает **скомпилированный** Java-код в память и соединяет с соответствующими библиотеками.
+ JVM отвечает за обеспечение Java-приложений ресурсами, необходимыми для их запуска и эффективной работы, а также выполняет приложение

Как разработчик вы будете работать с JDK и JVM, потому что эти компоненты вы будете использовать для разработки и запуска ваших Java-программ. 
Как пользователь Java-программ, вы будете использовать JRE, которая позволяет запускать эти программы.

JRE не очень ощутима на стадии разработки, где она просто запускает ваши приложения в операционной системе или IDE. 
JRE играет более заметную роль в devops и системном администрировании, потому что тут она используется для мониторинга и конфигурации.
В основном JRE предоставляет инструменты, которые вы можете использовать для настройки и управления характеристиками Java приложения.
Использование памяти является самым ярким примером.  
[подробнее](https://topjava.ru/blog/what-is-the-jre)  

## **JVM** (Java Virtual Machine)  
JVM — это программное обеспечение, которое выполняет код и предоставляет среду выполнения для этого кода, 
предоставляет и контролирует использование ресурсов Java приложением.  

Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором (javac).
Виртуальные машины Java обычно содержат интерпретатор байт-кода, однако, 
для повышения производительности во многих машинах также применяется JIT-компиляция часто исполняемых фрагментов байт-кода в машинный код.

В 1995 году, JVM представила две революционных концепции: «Написал один раз, запускай везде» и автоматическое управление памятью.
Виртуальная машина означает, что JVM является абстракцией фактической машины. 

Механизм выполнения в JVM
Как только загрузчик классов выполнил свою работу по загрузке классов, JVM начинает выполнять код каждого класса.
Выполнение кода включает управление доступом к системным ресурсам.
Механизм выполнения JVM стоит между работой программы, с ее запросами на файловые, сетевые ресурсы и ресурсы памяти, 
и операционной системой, которая обеспечивает эти ресурсы.

JVM также отвечает за распределение и поддержание ссылочной структуры, которую разработчик принимает, как должное. **Например, 
при использовании ключевого слова new, механизм выполнения JVM осуществляет запрос к операционной системе на выделение памяти.**

Изначально виртуальная машина Java предназначалась только для Java,
но сегодня она может поддерживать разные скриптовые и другие языки программирования, включая Scala, Groovy и Kotlin. 

[к оглавлению](#Garbage-Collection)  

## Расскажите о Stack, Heap, Metaspace  
Разделение хипа, стека и метаспейса являются в значительной степени условными, поскольку они используют виртуальную память, 
также это зависит от конкретной реализации JVM.  
JVM разделяет используемую ею память на две области: куча (heap), в которой хранятся данные приложения, и не-куча (non-heap), 
в которой хранится код программы и другие вспомогательные данные. 
Все три области памяти могут динамически увеличивать размер, за это отвечает JVM по своим алгоритмам.
Многие характеристики памяти определяются реализацией конкретной JVM.  

Metaspace: тут Java хранит малоизменяемою информацию программы, например классы  
Heap space: тут Java хранит изменяемый контент  
Stack space: тут Java хранит выполнение функций и ссылки на переменные

## Стек  
Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
Стек работает по схеме LIFO (последним вошел, первым вышел). 
Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.
Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится доступным для следующего метода. 
 
Основные особенности стека
Помимо того, что мы рассмотрели, существуют и другие особенности стека: 

+ Каждый поток виртуальной машины Java имеет собственный стек виртуальной машины Java, созданный одновременно с потоком.
+ Он заполняется и освобождается автоматически - по мере вызова и завершения новых методов
+ Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
+ Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи
+ Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек
+ Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
+ java -Xss , чтобы установить максимальный размер стека (-Xss to specify the stack size of individual threads in JVM.)\
+ Размер оагрничен ОС
+ Стек имеет статический размер, т.е. не изменяется в процессе работы потока.

Вы можете использовать -Xss для настройки начального размера стека. 
Затем стек динамически растет в соответствии с потребностями программы.

## Куча
Эта область памяти используется для объектов и JRE классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.  

Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
1. Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора.
2. Old (Tenured) Generation — здесь хранятся долгоживущие объекты.
Когда объекты из Young Generation достигают определенного порога «возраста», они перемещаются в Old Generation.  

Основные особенности кучи:
+ Доступ к ней медленнее, чем к стеку, т.к. доступ к этой памяти осуществляется с помощью сложных методов управления памятью, включая Young Generation, Old.
+ Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик мусора
+ Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
+ В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код
+ Стековая память существует лишь какое-то время работы программы (пока работает поток), а память в куче живет с самого начала до конца работы программы.
+ Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче.
+ Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError 
+ нет ограничения ОС, может быть ограничен пользователем или по умолчанию 

| Свойства                    | Стек                    | Куча                         |
| -------------               |:-------------:          | :-----:                       |
| Использование приложением                   | Для каждого потока используется свой стек           | Пространство кучи является общим для всего приложения                       |
| Хранение               | Хранит примитивы и ссылки на объекты                |   Все созданные объекты хранятся в куче                      |
|Порядок                 |Работает по схеме последним вошел, первым вышел (LIFO)|  Доступ к этой памяти осуществляется с помощью сложных методов управления памятью, включая Young Generation, Old и Permanent Generation|
|Существование|Память стека существует пока выполняется текущий метод(поток)|  Пространство кучи существует пока работает приложение|
|Скорость|Обращение к памяти стека происходит значительно быстрее, чем к памяти кучи| Медленнее, чем стек |
|Выделение и освобождение памяти|Эта память автоматически выделяется и освобождается, когда метод вызывается и завершается соответственно| Память в куче выделяется, когда создается новый объект и освобождается сборщиком мусора, когда в приложении не остается ни одной ссылки на его |  

[Стек и куча в Java](https://topjava.ru/blog/stack-and-heap-in-java)

## Metaspace
Metaspace хранит системную информацию. В ней хранятся **загруженные классы приложения и статические переменные**.
Разделение хипа, стека и метаспейса являются в значительной степени условными, поскольку они используют виртуальную память.
Но MetaSpace не используют кучу пространства и не учитывается как часть максимального размера кучи, -Xmx.
(т.е. условно Metaspace отделен от хипа)  

Metaspace хранится в native memory (это память, выделенная jvm под саму jvm, условно она отделена от стека и хипа (как я понимаю)).
Native Memory (собственная память) - это область, которая обычно используется JVM для внутренних операций и для выполнения JNI-кодов.
(JVM использует native memory для оптимизации кода и для загрузки классов и библиотек вместе с промежуточным генерированием кода)
Статические методы, а также статические переменные хранятся в metaspace, 
поскольку они являются частью данных отражения (данные, связанные с классом, а не связанные с экземпляром).
Более того хранит данные о байткоде и JIT информацию. 

По умолчанию, Metaspace увеличивается автоматически. Однако и здесь у нас есть возможность управления памятью.
Metaspace, процесс очистки памяти получил некоторые преимущества. 
Теперь GC автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает максимального значения. 
До Metaspace был PermGen, который был ограничен по размеру. Вместе с этим, уменьшилась вероятность получения ошибки OutOfMemoryError.  
Максимальный размер Metaspace по умолчанию не ограничен ничем кроме предела объёма нативной памяти.  
[Распределение памяти в JVM](https://habr.com/ru/company/otus/blog/445312/)  
[Metaspace](https://topjava.ru/blog/permgen-and-metaspace)
[память](https://habr.com/ru/post/489360/)
  
[к оглавлению](#Garbage-Collection)

## Чем java отличается от с++
C++ поддерживает как процедурное, так и объектно-ориентированное программирование; поэтому он называется гибридным.

+ **Управление памятью**  
В C++ вся память программы управлялась программистом. 
В Java память программ управляется виртуальной машиной Java.
В большинстве случаев делегирование управления памятью высокоточному процессу, такому как JVM, дает лучшую производительность и защищает от ошибок, нежели ручное управление

+ **Многопоточность** 
C++ не имеет встроенной поддержки потоков. Для этих целей используются нестандартизированные библиотеки третьих сторон.

+ **C++ поддерживает множественное наследование**

+ **Независимость от платформы**  
C++ генерирует объектный код; тот же код может не запускаться на разных платформах.
Java, по большей мере, интерпретируется, поэтому не зависит от платформы.  

[к оглавлению](#Garbage-Collection)

## Что такое менеджер памяти
Менеджер памяти — часть компьютерной программы, обрабатывающая запросы на выделение и освобождение оперативной памяти.
В Java - это JVM. 

[к оглавлению](#Garbage-Collection)

## Какой механизм используется в Java для управления памятью
Garbage Collection.  

**Понятие сборщик мусора**  
Garbage Collector висит в отдельном потоке. Если память начинает заканчиваться, происходит вызов GC. (алгоритм обхода графа объектов)  
+ Если на объект нет ссылки из основного потока, метода main, то такой объект считается пригодным для уничтожения.
+ Если объекты имеют циклическую зависимость, такие объекты распознаются и удаляются из памяти.
+ Если есть вложенные объекты, например композиция, то когда затираем родительский объект затираются и внутренние.

- Метод finalize, вызывается из объекта, когда GC хочет очистить память.
- Если по умолчанию для программы выделено 256 мб, а сама она не требует много памяти вызов GC не происходит.
- Если мы присваиваем ссылке null, GC не вызывается, если памяти достаточно.  
System.gc -  метод, который искусственным образом позволяет вызвать GC, он  говорит виртуальной машине, что следовало бы запустить GC,
но этот вызов не гарантирует, что GC будет вызван в этот же момент.
Что делает GC: он пробегает по всем объектам и проверяет, существует ли ссылка на объект в методе main.  

[к оглавлению](#Garbage-Collection)

## Опишите процесс работы сборщика мусора 
Преследуя свои цели, различные сборщики мусора используют разные подходы к организации памяти и ее очистке, 
но их объединяет общая черта — все они опираются на **слабую гипотезу о поколениях**.
Подавляющее большинство объектов создаются на очень короткое время, они становятся ненужными практически сразу после их первого использования.
Это навело разработчиков на мысль, что в первую очередь необходимо очищать память от тех объектов, 
которые были созданы недавно. Именно среди них чаще всего находится бóльшее число тех, кто уже отжил свое,
и именно здесь можно получить максимум эффекта при минимуме трудозатрат.  
Вот тут и возникает идея разделения объектов на младшее поколение (young generation) и старшее поколение (old generation). 
В соответствии с этим разделением и процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только младшее поколение, 
и полную сборку (full GC), которая может затрагивать оба поколения.
Малые сборки выполняются достаточно часто и удаляют основную часть мертвых объектов.  
Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к исчерпанию и малой сборкой уже не обойтись.  
(Вторая — так называемая сильная гипотеза о поколениях говорит о следующем: объекты из старого поколения редко ссылаются на объекты из молодого поколения.)  

При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. 
Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение.
В старшем поколении объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора. 
 
**Критерии оценки сборщиков:**
+ Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются stop-the-world (или STW).
+ Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
+ Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.  

Понятно, что добиться улучшения всех трех параметров одновременно практически невозможно. 
Уменьшение максимального времени задержки приводит к учащению сборки мусора, уменьшая пропускную способность.
Либо приходится использовать более ухищренные алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов.
JVM.  
Кстати, время от момента, когда объект стал нам не нужен, 
до момента его фактического удаления из памяти называется проворством (promptness) и иногда рассматривается как дополнительный фактор оценки эффективности сборщика.  
[подробнее](https://habr.com/ru/post/269621/)  

[к оглавлению](#Garbage-Collection)

## Какие алгоритмы сборщика вы знаете  
Мусор - структура данных (объекты), не достжимая из программного кода.  

Способы определения мертвых объектов:
+ Подсчет ссылок
+ Транзитивное замыкание ссылок (обход графа объектов)
+ Вообще не собирать  

**Подсчет ссылок**  
Имеет серьезный недостаток – с его помощью нельзя собирать кольцевые ссылки.
В принципе, во многих случаях использовать его вполне нормально.  
Подсчёт ссылок также известен как один из алгоритмов сборки мусора,
где **каждый объект содержит счётчик количества ссылок** на него,используемых другими объектами.
Когда этот счётчик уменьшается до нуля, это означает, что объект стал недоступным, и он помещается в список объектов на уничтожение.
Простой подсчёт ссылок требует частых обновлений счётчика. При любом уничтожении или перезаписи ссылки на объект,  
счётчик ссылок этого объекта декрементируется, а когда любая из ссылок на объект создаётся или копируется, счётчик ссылок на объект инкрементируется.  

Плюсы:
+ Просто  
+ Вообще не нужны паузы для сборки мусора  

Минусы:  
+ Не находит циклические ссылки  
+ Дополнительно грузит CPU (процессор)  
Частые обновления, порождаемые подсчётом ссылок, являются источником ухудшения эффективности.  
Это очень большая нагрузка на производительность – каждый раз, когда мы что-то читаем,
записываем ссылку на объект в локальную переменную, нам нужно увеличивать счетчик.  
+ Плохо сочетается с многопоточностью  
Если это происходит в многопоточной среде, у нас возникает жуткий конфликт (англ. contention), связанный со счетчиками ссылок.  
 
**Обход графа объектов (Поиск транзитивного замыкания всех ссылок в графе объектов)**  
Так мы гарантированно находим все досягаемые объекты.
Это довольно трудоемкий процесс: чтобы обойти весь граф, нам надо, по сути, просканировать всю память.  
**Корневой набор ссылок - это статические и локальные переменные(+ не статических полей в классах)**.
(Сборщик мусора начинает поиск живых объектов с области статической памяти,
стека(логично, так как в стеке на данный момент содержится выполняемый код и объекты, 
на которые ссылаются объекты из стека явно нам нужны) и Old Generation(те объекты, которые уже выжили в
результате нескольких сборок мусора, доказав всему миру, что они — не мусор))
Соответственно объекты достижимые из корневых ссылок - живые, недостижимые - мертвые.  
В общем случае, граф объектов не должен меняться по мере обхода. 
Следовательно, приложение должно быть остановлено (=>STW), пока идет сборка мусора.  

Транзитивное замыкание ссылок используется во всех достаточно серьезных виртуальных машинах,
которые не «умирают» после каждого запроса или нескольких запросов.
Чтобы осуществлять транзитивное замыкание, нужно сформировать набор корневых ссылок из статических переменных и локальных переменных.
То есть нам нужно просканировать кадры стека и собрать ссылки оттуда.
Современные Java-машины используют обычный стек. Кадры могут перемежаться нативным кодом.
Некоторые виртуальные машины используют свой стек, но это неважно. Его все равно нужно сканировать.
Затем, начиная с этих корневых ссылок, мы обходим весь граф объектов памяти. 
Те объекты, до которых мы дошли, являются «живыми». Те, до которых мы не дошли,
представляют собой «мусор» - эту память можно использовать повторно.
Есть один неприятный момент: пока мы обходим граф объектов, он не должен меняться.
Если он будет меняться, окажется, что мы не обошли какие-то из достижимых объектов. 
Это одна из основных причин, по которым для «сборки мусора» нужны паузы.  

**Вообще не собирать**  
Когда память закончится, можно «убить» процесс. Звучит страшновато, но на практике этот способ тоже часто оказывается полезным.  

Алгоритмы сборки мусора:  
+  **Mark and Sweep**  
Первая – это обход графа и установка особого флажка на каждом из достижимых объектов.
Второе – сканирование всей памяти и помещение объектов без флажка в список свободного пространства. 
+  **Cборка копированием** (применяется в малых сборках)  
Он позволяет осуществить все вышеперечисленное за один проход. Когда мы находим в графе новый объект, 
достижимый из корней, мы сразу копируем его в другое пространство памяти. 
Соответственно блок памяти этого объекта становится свободным для других данных.  
+ **Mark-Sweep-Compact**
 (применяется в старшем поколении)  
Он выполняет Mark-Sweep, затем, после выполнения действия “sweep” он перемещает объект в памяти,
чтобы выполнить дефрагментацию и обеспечить непрерывность свободного места, которое станет удобно выделять.  

Пример сложности при сборке, когда старый объект ссылается на новый.
Объект старшего поколения ссылается на объект младшего поколения, оба объекта приравниваем к null, 
но чтобы GC понял, что младший объект нужно удалить, нужно провести full GC,
т.к. при проведении minor GC младший объект не будет удален, потому что GC будет считать, что на него еще есть ссылка.
Таким образом, чаще всего для целей малой сборки мусора объект считается мертвым и подлежащим утилизации,
если до него невозможно добраться по ссылкам ни из объектов старшего поколения, ни из так называемых корней (roots),
к каковым относятся ссылки из стеков потоков, статические члены классов и т.п.
  
Выделение объектов в памяти в языке Java – практически бесплатная операция.  
[подробнее](https://floppyy.ru/2017/08/14/gc-java/)
[подробнее](http://profyclub.ru/docs/305) **(хорошая статья!)**
[подробнее](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA)  

 
[к оглавлению](#Garbage-Collection)

## Чем отличаются сборщики мусора
Между сборщиками существуют и заметные различия, проявляющиеся в ответах на следующие вопросы:  
+ Какое количество регионов кучи используется, каково их назначение и размеры? Как эти размеры изменяются динамически?
+ Как устроен перевод объектов из младшего поколения в старшее?
+ Какие из работ по сборке мусора выполняются параллельно с работой основной программы, а какие приводят к ее остановке?
+ Каким образом сборщик мусора автоматически подстраивается под требуемые параметры производительности? Каким из них отдает приоритет?
+ Какие существуют возможности по настройке сборщика?  

Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:
+ **Serial (последовательный)** — вариант для приложений с небольшим объемом данных и не требовательных к задержкам. 
На слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. 
Останавливает приложение и в однмо потоке последовательно выполняет сборку мусора.
+ **Parallel (параллельный)**  — наследует подходы к сборке от последовательного сборщика, но **добавляет многопоточность при переносе объектов в старшее поколение, 
и при уплотнении данных в старшем поколении**, а также **возможности по автоматической подстройке под требуемые параметры производительности**. (работа этого сборщика также полностью останавливает приложение) 
+ **Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. 
Подходит для работы с относительно большими объемами данных в памяти. **Малая и старшая сборки здесь всегда разделены.** Старшая не затрагивает молодое поколение.
Часть старшей сборки производит в конкурентном режиме: пометку выживших объектов и удаление мертвых объектов сборщик CMS выполняет  параллельно с работой основной программы, т.е. конкурирует.
+ **Garbage-First (G1)** — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах 
и оперирующих большими объемами данных.  
G1 измененил подход к организации кучи. Здесь память разбивается на множество регионов одинакового размера. 
Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд
и даже могут менять свою принадлежность к тому или иному поколению.  
Отличие в малых сборках - очистка выполняется **не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени**,
при этом выбирает для очистки те регионы, **в которых скопилось наибольшее количество мусора**.
Отсюда как раз название Garbage First — мусор в первую очередь.  
Смешанные сборки:  
В G1 существует процесс marking cycle, который работает параллельно с основным приложением и составляет список живых объектов.
После окончания цикла пометки G1 переключается на выполнение смешанных сборок. При каждой сборке к набору регионов младшего поколения, 
подлежащих очистке, добавляется некоторое количество регионов старшего поколения. 
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках 
таким образом, чтобы не выходить за требуемое время сборки. Т.е. и малая, и смешанная сборка направлена на непревышение желаемого времени STW.    

## Serial GC (последовательный сборщик)  
Использование Serial GC включается опцией -XX:+UseSerialGC  

**В начале каждой сборки мусора работа основных потоков приложения останавливается и возобновляется только после окончания сборки. (сплошной STW)**
Всю работу по очистке Serial GC выполняет последовательно, в одном потоке.  

**Алгоритм:**  
При использовании данного сборщика куча разбивается на четыре региона, 
три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему.  
Малая сборка:
Когда Eden заполняется, живые объекты переносятся в пустой регион Survivor (Survivor 0).
В след. раз когда Eden заполняется, Eden и Survivor 0 очищаются, живые объекты переносятся в Survivor 1.
Далее когда Eden заполняется, объекты из Eden и Survivor 1 переносятся в Survivor 0.
JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, 
и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение.
Т.е. далее при заполнении Eden, объекты из Eden перейдут в Survivor 1, а выжившие из Survivor 0 уже в Tenured.
Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured.

В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора, работающая с объектами из обоих поколений.

Существуют объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. 
В этом случае они размещаются сразу в Tenured.


Важными факторами в описанных процессах являются абсолютный размер кучи и относительные размеры регионов внутри нее.
По мере заполнения кучи данными JVM может не только проводить чистку памяти, но и запрашивать у ОС выделение дополнительной памяти для расширения регионов.
Причем в случае, если реально используемый объем памяти падает ниже определенного порога, JVM может вернуть часть памяти операционной системе.
Тут также стоит отметить, что по умолчанию младшее поколение занимает одну треть всей кучи, а старшее, соответственно, две трети. 
При этом каждый регион Survivor занимает одну десятую младшего поколения, то есть Eden занимает восемь десятых.

**Достоинства и недостатки:**  
Основное достоинство данного сборщика очевидно — это непритязательность по части ресурсов компьютера. 
Так как всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов (доп. время, которое занимает выполнение самого GC)
и негативных побочных эффектов у него нет.
Главный недостаток тоже понятен — это долгие паузы на сборку мусора при заметных объемах данных. 
Кроме того, все настройки Serial GC крутятся вокруг размеров различных регионов кучи. 
То есть для тонкой настройки требуется самому что-то изучать, настраивать, экспериментировать и прочее.

## Parallel GC  
Многопоточность + подстройка под параметры производительности (максимальное время сборки мусора и пропускной способности).
Во время сборки потоки приложения также полностью останавливаются.  
-XX:+UseParallelGC  
Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, 
то почти наверняка JVM остановит свой выбор на Parallel GC.  
**Основные отличия этого сборщика от последовательного:**сборкой мусора занимаются несколько потоков параллельно, 
данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.
Малая сборка пользуется многопоточностью при переносе объектов в старшее поколение, 
а полная — при уплотнении данных в старшем поколении.

При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden,
Survivor 0, Survivor 1 и Old Gen. 

**Каждый поток сборщика получает свой участок памяти в регионе Old Gen**, так называемый буфер повышения, куда только он может переносить данные,
чтобы не мешать другим потокам. 
Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной **фрагментации памяти.**

Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, 
ориентированные на достижение необходимой вам эффективности сборки мусора. 
Вы можете указать устраивающие вас параметры производительности — максимальное время сборки мусора и/или пропускную способность — 
и сборщик будет изо всех сил стараться не превышать заданные пороги.
При этом Parallel GC оставляет нам возможность самостоятельно корректировать размеры регионов, как и в последовательном сборщике. 
Но не рекомендуется делать и то и другое одновременно, чтобы не дезориентировать алгоритмы автоматической подстройки.  
Как и в случае с последовательным сборщиком, на время операций по очистке памяти все основные потоки приложения останавливаются. 
Разница только в том, что пауза, как правило, короче за счет выполнения части работ в параллельном режиме.

Установка желаемых параметров производительности сборщика выполняется с помощью опций -XX:MaxGCPauseMillis=? и -XX:GCTimeRatio=?.

**Достоинства и недостатки:**
Бесспорным плюсом данного сборщика на фоне Serial GC является возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время cборок. 
При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.
Определенная фрагментация памяти, является минусом, но вряд ли она будет существенной для большинства приложений, 
так как сборщиком используется относительно небольшое количество потоков.

## CMS GC (Concurrent Mark Sweep)  
-XX:+UseConcMarkSweepGC  
Конкурентное выполнение Mark и Sweep.
Вместо полной - старшая сборка, которая трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии. 

Первостепенной задачей CMS GC и G1 GC является минимизация пауз STW. Два этих сборщика объединяют общим названием «mostly concurrent collectors», 
то есть «по большей части конкурентные сборщики». Это связано с тем, что часть своей работы они выполняют параллельно с основными потоками приложения, 
то есть в какие-то моменты конкурируют с ними за ресурсы процессора.  
Mark и Sweep обозначают два шага в процессе сборки мусора в старшем поколении: пометку выживших объектов и удаление мертвых объектов.
Сборщик CMS получил свое название благодаря тому, что **выполняет указанные шаги параллельно с работой основной программы**.

При этом CMS GC использует ту же организацию памяти, как и  Serial/Parallel GC и такие же принципы малой сборки мусора. 
Отличия начинаются только тогда, когда дело доходит до полной сборки. 
В случае CMS ее называют **старшей (major) сборкой, так как она не затрагивает объекты младшего поколения.** 
В результате, малая и старшая сборки здесь всегда разделены. Одним из побочных эффектов такого разделения является то, 
что все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. 
Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Сборщик CMS достаточно интеллектуальный. Например, он старается разносить во времени малые и старшие сборки мусора, 
чтобы они совместно не создавали продолжительных пауз в работе приложения.

Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. 
В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме. Такая ситуация называется сбоем конкурентного режима.

Ситуации STW  
+ Малая сборка мусора. Эта пауза ничем не отличается от аналогичной паузы в Parallel GC. (Конкурентный режим работает только в старшей сборке)
+ Начальная фаза поиска живых объектов при старшей сборке (так называемая initial mark pause). Эта пауза обычно очень короткая.
+ Фаза дополнения набора живых объектов при старшей сборке (известная также как remark pause). Она обычно длиннее начальной фазы поиска.

**Достоинства и недостатки**  
Достоинством данного сборщика по сравнению с рассмотренными ранее Serial / Parallel GC является его ориентированность на минимизацию времени простоя,
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.
Вспомним еще, что данный сборщик не уплотняет объекты в старшем поколении, что приводит к фрагментации Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению (конкретно — старшему поколению) больше памяти, 
чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).
Ну и долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти CMS’у удается их полностью избегать.

## G1 GC (Garbage First)  
-XX:+UseG1GC  
Память разбивается на множество регионов одинакового размера.  
Отличие в малых сборках - **очистка выполняется не на всем поколении**, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. 
При этом он выбирает для очистки те регионы, в которых скопилось больше мусора.=> Garbage First.  
Смешнаая сборка: В G1 существует процесс - цикл пометки (аналогично mark), **который работает параллельно с основным приложением 
и составляет список живых объектов**. После окончания цикла пометки G1 переключается на выполнение смешанных сборок.   

Интересен он прежде всего тем, что не является явным продолжением линейки Serial / Parallel / CMS, 
а использует уже существенно отличающийся подход к задаче очистки памяти.
Он изначально позиционировался как сборщик для приложений с большими кучами (от 4 ГБ и выше), 
для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет уменьшения пропускной способности.

G1 измененил подход к организации кучи. Здесь память разбивается на множество регионов одинакового размера. 
Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. 
Исключение составляют только так называемые громадные (humongous) регионы, которые создаются объединением обычных регионов для размещения очень больших объектов.

Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд 
и даже могут менять свою принадлежность к тому или иному поколению.

**Отличие в малых сборках - очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени.
При этом он выбирает для очистки те регионы, в которых,  скопилось наибольшее количество мусора.
Отсюда как раз название Garbage First — мусор в первую очередь.**

А с полной сборкой (она называется смешанной/mixed) все немного хитроумнее, чем в рассмотренных ранее сборщиках. 
В G1 существует процесс, называемый циклом пометки (marking cycle почти аналогично mark and sweep),
который работает параллельно с основным приложением и составляет список живых объектов. 
После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения,
подлежащих очистке, добавляется некоторое количество регионов старшего поколения. 
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках 
таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

Ситуации STW
+ Процессы переноса объектов между поколениями. Для минимизации таких пауз G1 использует несколько потоков.
+ Короткая фаза начальной пометки корней в рамках цикла пометки.
+ Более длинная пауза в конце фазы remark и в начале фазы cleanup цикла пометки.

**Достоинства и недостатки**   
В целом считается, что **сборщик G1 более аккуратно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени**, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 
При этом он лишен и некоторых других недостатков CMS, например, он **не фрагментирует память**.

Расплатой за достоинства G1 являются ресурсы процессора, которые он использует для выполнения достаточно большой части своей работы параллельно 
с основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности по умолчанию для G1 является 90%. 
Для Parallel GC, например, это значение равно 99%. Это, конечно, не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, 
но данную особенность следует всегда иметь в виду.  

**Вопрос: Расскажите почему именно два региона survival и зачем перекладывать объекты между ними?**  
Ответ:  
Представьте себя на месте сборщика. У вас есть регион памяти, который нужно очистить.
После удаления мусора регион оказывается сильно дефрагментированным и если вы хотите это исправить, 
то у вас есть два варианта: либо уплотнять объекты в рамках этого же региона, либо скопировать их в другой, пока еще пустой регион, 
располагая один-к-одному, а старый регион объявить пустым.     
[краткий конспект по сборщикам](https://ziginsider.github.io/Garbage_Collector_Java/)

[к оглавлению](#Garbage-Collection)  
  
## Утечки памяти и как не допустить их 
Утечка памяти — это ситуация, когда в куче есть объекты, которые больше не используются, но сборщик мусора не может удалить их,
что приводит к нерациональному расходованию памяти.
Утечка является проблемой, так как она блокирует ресурсы памяти, что со временем приводит к ухудшению производительности системы.  

Симптомы утечки памяти:  
+ Серьезное ухудшение производительности, когда оно работает продолжительное время;
+ Возникновение в приложении ошибки java.lang.OutOfMemoryError;
+ Спонтанные и странные сбои в приложении;
+ Иногда в приложении заканчиваются объекты подключения; 
   
**Причины утечек:**
+ **Утечки памяти из-за статических полей** (В Java время жизни статических полей обычно совпадает со временем работы приложения)  
+ **Через незакрытые ресурсы**
+ **Неверные реализации equals() и hashCode() (HashSet и HashMap используют эти методы во многих операциях)** 
+ Внутренние классы, которые ссылаются на внешние классы.  
Каждый нестатический внутренний класс по умолчанию имеет неявную (скрытую) ссылку на класс в котором он находится.
Если мы используем этот объект внутреннего класса в нашем приложении, 
то даже после того, как объект внешнего класса завершает свою работу, он не будет утилизирован сборщиком мусора.  
+ **Через finalize() методы**  
+ **ThreadLocal** — это механизм, который позволяет изолировать состояние (значения переменных) в определенном потоке, что делает его безопасным.
При использовании этой конструкции, каждый поток будет содержать неявную ссылку на его копию переменной ThreadLocal
и будет хранить свою собственную копию, вместо того чтобы совместно использовать ресурс через множество потоков, так долго, сколько поток будет жить.    
  
Использование финализаторов является еще одним потенциальным источником утечек памяти.
Всякий раз, когда в классе переопределяется метод finalize(), объект этого класса не убирается сборщиком мусора немедленно.
Вместо этого он помещается сборщиком в очередь на утилизацию, которая происходит немного позже.      
[подробнее](https://topjava.ru/blog/java-memory-leaks)
  
[к оглавлению](#Garbage-Collection)

## Расскажите про утилиты для анализа памяти
1. JConsole – это встроенный профайлер производительности Java
2. VisualVM - визульаное продолжение JConsole
3. JProfiler - платная утилита

Все утилиты для анализа памяти позволяют мониторить работу JVM, в частности кол-во используемой памяти,
сборки мусора, кол-во созданных объектов, кол-во занятой памяти в поколених,  кол-во загруженных классов, запущенных потоков итд.

[к оглавлению](#Garbage-Collection)

## Что такое ссылки
Ссылки в Java — указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, в которой хранится объект.
Объявленная переменная  хранит не состояние объекта, а ссылку на него, сам же объект хранится в определённой куче. 

Ссылка на объект занимает в стеке память равную машинному слову.
Технически ссылки обычно равны размеру машинного слова, т.е. 32 бит на 32-битной машине и 64 бит на 64-битной машине, 
хотя некоторые 64-разрядные JVM используют специальная магия, чтобы разрешить 32-битные ссылки.

Java передает все по значению: в примитивах - вы получаете копию содержимого, в ссылкамх - копию ссылки.  

[к оглавлению](#Garbage-Collection)

## Какие типы ссылок вы знаете
+ сильные ссылки (Strong reference)
+ мягкие ссылки (SoftReference)
+ слабые ссылки (WeakReference)
+ фантомные ссылки (PhantomReference)  

[к оглавлению](#Garbage-Collection)

## Чем они отличаются  
Наиболее важные методы при работе с этими классами:  
get() — возвращает объект, на который ссылается эта ссылка;
(он объявлен у класса Reference, от которого наследуются SoftReference, WeakReference, PhantomReference)  
clear() — удаляет ссылку на объект.

+ **Сильные ссылки (StrongReference)**  
Это обычные ссылки которые мы всегда используем.
Когда мы объявляем Rectangle rect = new Rectangle(), то объект на который ссылается rect не может быть удален сборщиком мусора из памяти до тех пор,
пока на этот объект есть хотя бы одна сильная ссылка;

++ **Мягкие ссылки (SoftReference)**  
Объявление мягкой ссылки выглядит так: SoftReference<Rectangle> rect = new SoftReference<Rectangle>(new Rectangle());
SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. Потом. Наверно.
**Важно понимать, что метод get() может вернуть null. Это происходит в том случае, когда память вашей программы заполнена и появляется вероятность возникновения OutOfMemoryError, 
тогда сборщик мусора удаляет объекты на которые ссылаются мягкие ссылки. Именно этот вид ссылок удобно использовать для кеширования объектов.**

Главная плюшка SoftReference в том, что JVM сама следит за тем нужно удалять из памяти объект или нет. 
И если осталось мало памяти, то объект будет удален. Это именно то, что нам нужно при кэшировании.
Если говорить про производительность, то стоить отметить что часто, ошибочно, люди используют WeakReference для построения кэша там где стоит использовать SoftReference. 
Это приводит к низкой производительности кэша. На практике weak-ссылки быстро будут удалены из памяти, как только исчезнут strong-ссылки на объект. 
И когда нам реально понадобиться вытянуть объект с кэша, мы увидим что его там уже нет.  
[подробнее](https://habr.com/ru/post/169883/)

++ **Слабые ссылки (WeakReference)**  
WeakReference<Rectangle> rect = new WeakReference<Rectangle>(new Rectangle());
Когда GC определяет, что объект доступен только через weak-ссылки, то этот объект удаляется из памяти, 
т.е. для этого не обязательно условие нехватки памяти.
Выгодно использовать, в случаях, когда при удалении строгой ссылки, объект должен быть тоже удален.

Тут стоить вспомнить про ReferenceQueue и проследить за порядком удаления объекта с памяти. 
Напомню что для WeakReference и SoftReference алгоритм попадания в ReferenceQueue одинаковый. 
Итак, запустился GC и определил что объект доступен только через weak-ссылки. Этот объект был создан так:
StrIngBuilder AAA = new StringBuilder(); ReferenceQueue queue = new ReferenceQueue();
WeakReference weakRef = new WeakReference(AAA, queue);

Сначала GC очистит weak-ссылку, то есть weakRef.get() – будет возвращать null. 
Потом weakRef будет добавлен в queue и соответственно queue.poll() вернет ссылку на weakRef. 
Теперь посмотрим, как это можно использовать.

// какой-то объект  
Student student = new Student();  
// слабая ссылка на него
WeakReference<Student> weakStudent = new WeakReference<Student>(student);  
// теперь объект Student может быть собран сборщиком мусора
student = null;

В качестве примера использования такой структуры данных можно привести следующую ситуацию: 
допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. 
В этом случае добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения - нужную информацию. 
Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. 
Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue
и затем соответствующая запись для этой слабой ссылки будет удалена из WeakHashMap.  Т.е. WeakHashMap удобно использовать,
когда у нас есть некий объект и он связан с большой доп. информацией, и если этот объект нам больше не нужен, мы также очиащаем
эту доп. информацию.  
[Подробнее](https://javadevblog.com/tipy-ssy-lok-v-java-strongreference-weakreference-softreference-i-phantomreference.html)

++ **Фантомные ссылки (PhantomReference)**  
ReferenceQueue<Object> queue = new ReferenceQueue<>();  
PhantomReference<Object> rect = new PhantomReference<Object>(new Object(), queue);  
 
Используется, как замена finalize(). (даже во встроенных библиотеках, где раньше использовался finalize(),
например класс FileInputStream, освобождение сист. ресурсов из под файла)    
В системных классах в качестве более надежной и легковесной замены финализаторам применяется **sun.misc.Cleaner**, 
основанный на PhantomReference. Как только сборщик мусора обнаружит, что объект, на который ссылается Cleaner, 
стал phantom-reachable, будет запущен указанный Runnable, как правило, для освобождения ресурсов.    
Чтобы повесить какое-то действие подчистку объекта, зарегистрировать некий Runnable следующим способом:  
Object ref = new …;    
Cleaner.create(ref, new Runnable() {    
    @Override    
    public void run() {    
    // put your code here    
    }    
});      
[подробнее](https://habr.com/ru/post/132703/)  
[подробнее](http://www.javaspecialist.ru/2012/08/blog-post.html)    

Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. 
Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка
или данная фантомная ссылка не очищена с помощью вызова метода clear().(пока есть ссылка объект не будет удален!)  

**Резюме:**  
Фантомная ссылка попадает в очередь, когда не осталось ни Strong, Weak или Soft ссылок. Далее она попадает в ReferenceQueue после вызова метода finalize().
Метод get() из ссылки всегда возвращает null, чтобы мы не могли получить ссылку на объект и восстановить его. 
Таким образом, когда ссылка появляется в очереди, это значит, что объект наверняка будет удален.  
Также этот тип ссылки используется для очистки ресурсов объекта перед его удалением.

Применение PhantomReference связано с тонкостями метода finalize() и является альтернативой его переопределения.
PhantomReference может использоваться в ситуациях, когда использование finalize() не имеет смысла.
Он является сигналом о том, что объект уже финализирован и сборщик мусора готов вернуть свою память.
PhantomReference - самая слабая ссылка. Одна из тонкостей в том, что объект по фантомной ссылке недоступен сразу, хотя еще не удален из памяти. 

Сборщик удаляет любой объект условно в два прохода:
+ В первый проход он только смотрит на объекты, и, если надо, помечает его как «ненужный, подлежащий удалению». 
Если у этого объекта был переопределен метод finalize(), он вызывается. Или не вызывается — поведение finalize() точно не предугадать.
+ Во второй проход сборщика объект  удаляется, и память освобождается. 
Такое непредсказуемое поведение сборщика мусора создает для нас ряд проблем: Мы не знаем когда именно начнется работа сборщика мусора. 
Мы не знаем будет ли вызван метод finalize(). Плюс ко всему, во время работы finalize() может быть создана strong-ссылка на объект, и тогда он вообще не будет удален.  

Все это подталкивает нас к использованию фантомных ссылок:
Если на объект остались только фантомные ссылки, то у него:
+ вызывается метод finalize() (если он переопределен);
+ **если после работы finalize() ничего не изменилось и объект все еще может быть удален, фантомная ссылка на объект помещается в специальную очередь — ReferenceQueue.**
+ **Самое важное, что нужно понимать при работе с фантомными ссылками, — объект не удаляется из памяти до тех пор, пока его фантомная ссылка находится в этой очереди.
Он будет удален только после того, как у фантомной ссылки будет вызван метод clear().**

[Пример использования:](https://javarush.ru/groups/posts/2291-osobennosti-phantomreference)
Фантомная ссылка позволяет точно узнать, что объект будет удален из памяти. Для этого мы наследуемся от ее класса, 
и добавляем к методу clear выведение информации об успешном удалении ("объект удален").
Далее создаем поток, который постоянно проверяет очередь, и когда в ней появляется фантомная ссылка, мы получаем ее и вызываем метод cleanup(), 
в котором находится метод clear() фантомной ссылки и оповещение об удалении.
Reference ref = null;
//ждем, пока в очереди появятся ссылки
while ((ref = referenceQueue.poll()) == null) {
Далее ((MyPhantomReference) ref).cleanup(); выведет нам - "объект удален".
Теперь мы точно знаем, что объект удален. 
Также таким образом можно освободить ресурсы, связанные с объектом перед его удалением. (например закрыть потоки)

Дополнительно:
Здесь обязательно объявление объекта очереди queue - это представитель класса ReferenceQueue. 
Их функция в том, что когда объект доступный с помощью ссылки удаляется, 
то сам объект ссылки становится доступным в очереди ReferenceQueue. Этот механизм позволяет удалять пустые ссылки.
Слабая ссылка помещается в очередь перед тем, как объект на который она указывает будет финализирован finalize() и удален сборщиком мусора.
Т.е. в методе finalize() удаляемого объекта можно назначить строгую ссылку на удаляемый объект, и таким образом "спасти" его от сборщика мусора.
Но слабая ссылка уже будет в очереди и будет уничтожена.
В свою очередь в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue послетого как выполниться метод finalize().  

Этот ссылочный тип отличается от других типов, поскольку он не предназначен для доступа к объекту. 
Он является сигналом о том, что объект уже финализирован и сборщик мусора готов вернуть свою память.
Для этого сборщик мусора помещает его в специальный ReferenceQueue для последующей обработки. 
Фантомные ссылки — это безопасный способ узнать, что объект будет удален из памяти.
Например, рассмотрим приложение, которое имеет дело с большими изображениями.
Предположим, что мы хотим загрузить изображение в память, когда оно уже находится в памяти, которая готова для сборки мусора. 
В этом случае мы хотим подождать пока сборщик мусора убьет старое изображение и только потом загружать в память новое.
Здесь PhantomReference является гибким и безопасным выбором. Ссылка на старое изображение будет передана в ReferenceQueue после уничтожения старого объекта изображения.
Получив эту ссылку и очистив ее, мы можем загрузить новое изображение в память.  
[к оглавлению](#Garbage-Collection)  

## Размер Java объектов  

**Примитивные типы:**  
Известно, что примитивные типы в Java имеют предопределенный размер, этого требует спецификация для переносимости кода.   
byte: The byte data type is an 8-bit signed two's complement integer.
It has a minimum value of -128 and a maximum value of 127 (inclusive). 
The byte data type can be useful for saving memory in large arrays, where the memory savings actually matters.
They can also be used in place of int where their limits help to clarify your code;
the fact that a variable's range is limited can serve as a form of documentation.  
short: The short data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive).
As with byte, the same guidelines apply: you can use a short to save memory in large arrays,
in situations where the memory savings actually matters.  
int: By default, the int data type is a 32-bit signed two's complement integer,
which has a minimum value of -231 and a maximum value of 231-1.
In Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer,
which has a minimum value of 0 and a maximum value of 232-1. Use the Integer class to use int data type as an unsigned integer.
See the section The Number Classes for more information.
Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers.  
long: The long data type is a 64-bit two's complement integer.
The signed long has a minimum value of -263 and a maximum value of 263-1.
In Java SE 8 and later, you can use the long data type to represent an unsigned 64-bit long,
which has a minimum value of 0 and a maximum value of 264-1. Use this data type when you need a range of values wider than those provided by int.
The Long class also contains methods like compareUnsigned, divideUnsigned etc to support arithmetic operations for unsigned long.    
float: The float data type is a single-precision 32-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion,
but is specified in the Floating-Point Types, Formats,and Values section of the Java Language Specification.
As with the recommendations for byte and short, use a float (instead of double) if you need to save memory in large arrays of floating point numbers.
This data type should never be used for precise values, such as currency. For that, you will need to use the java.math.BigDecimal class instead.
Numbers and Strings covers BigDecimal and other useful classes provided by the Java platform.    
double: The double data type is a double-precision 64-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion,
but is specified in the Floating-Point Types, Formats, and Values section of the Java Language Specification.
For decimal values, this data type is generally the default choice. As mentioned above,
this data type should never be used for precise values, such as currency.    
boolean: The boolean data type has only two possible values: true and false.
Use this data type for simple flags that track true/false conditions.
This data type represents one bit of information, but its "size" isn't something that's precisely defined.  
char: The char data type is a single 16-bit Unicode character.
It has a minimum value of '\u0000' (or 0) and a maximum value of '\uffff' (or 65,535 inclusive).  

**Объекты:**  
А что же говорит спецификация для объектов? Ничего, кроме того, что у каждого объекта есть заголовок.
Иными словами, размеры экземпляров Ваших классов могут отличатся от одной JVM к другой.  
Из чего же состоит объект?  

Прежде чем определять объем потребляемой памяти, следует разобраться, что же JVM хранит для каждого объекта:
+ Заголовок объекта; Каждый экземпляр класса содержит заголовок. Каждый заголовок для большинства JVM(Hotspot, openJVM)
состоит из двух машинных слов. Если речь идет о 32-х разрядной системе, то размер заголовка — 8 байт,
если речь о 64-х разрядной системе, то соответственно — 16 байт.
+ Память для примитивных типов;
+ Память для ссылочных типов;
+ Смещение/выравнивание — по сути, это несколько неиспользуемых байт, что размещаются после данных самого объекта.
Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову,
для ускорения чтения из памяти + уменьшения количества бит для указателя на объект + предположительно для уменьшения фрагментации памяти.
Стоит также отметить, что в java размер любого объекта кратен 8 байтам!  

Integer и String
Давайте попробуем подсчитать сколько же будет занимать объект класса Integer в нашей 32-х разрядной HotSpot JVM.
Для этого нужно будет заглянуть в сам класс, нам интересны все поля, которые не объявлены как static.
(статик поля находятся в metaspace)  
Из таких видим только одно — int value. Теперь исходя из информации выше получаем:  
**Integer**  
Заголовок: 8 байт  
Поле int: 4 байта  
Выравнивание для кратности 8 : 4 байта  
Итого: 16 байт  
**String**  
Итого в конечном итоге простая, казалось бы, строка new String(«a») выливается в:  
Заголовок: 8 байт  
Поля int: 4 байта * 3 == 12 байт  
Ссылочная переменная на объект массива: 4 байта  
Итого: 24 байта  

new char[1]  
Заголовок: 8 байт + 4 байта на длину массива == 12 байт  
Примитивы char: 2 байта * 1 == 2 байта  
Выравнивание для кратности 8 : 2 байта  
Итого: 16 байта  
**Итого, new String("a") == 40 байт**  
[подробнее](https://habr.com/ru/post/134102/)  

[к оглавлению](#Garbage-Collection)  

## Расскажите про String pool, Int pool

## Пул строк  
Пул строк - это набор строк, который хранится в памяти Java heap. 
Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
**Пул строк помогает экономить большой объем памяти**, но с другой стороны создание строки занимает больше времени.
Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, 
если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.
Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки,
а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул,
или получить из пула ссылку на другой объект String с таким же значением.

## Integer пул  
В Java есть пул(pool) целых чисел в промежутке [-128;127]. Т.е. если мы создаем Integer в этом промежутке, то вместо того, 
чтобы каждый раз создавать новый объект, JVM берет их из пула.  

Как работает кеширование при операции autoboxing?
Начиная с Java 1.5, для целочисленных значений в диапазоне от -128 до + 127 объекты-обёртки кешируются внутри для повторного использования.
- верхнюю границу можно изменять при помощи параметра запуска программы
- границы как и многое в джаве, зависят от конкретной реализации JVM  
В классе-обёртке Integer есть внутренний класс IntegerCache. Он объявлен как private static. 
В этом внутреннем классе кешированные объекты находятся в массиве cache[]. 
Кеширование выполняется при первом использовании класса-обёртки. 
После первого использования, вместо создания нового экземпляра (кроме использования конструктора), используются кешированные объекты.

Код метода valueOf() класса Integer выгдядит так: 
 
public static Integer valueOf(int i) {  
if (i >= IntegerCache.low && i <= IntegerCache.high)  
return IntegerCache.cache[i + (-IntegerCache.low)];  
return new Integer(i);  
}  

Кэширование касается не только класса-оболочки Integer. Имеются аналогичные реализации кеширования для других классов-оболочек целочисленных типов:
ByteCache, ShortCache, LongCache, CharacterCache.
Кешированные объекты не используются при создании объекта-обёртки с помощью new().  

Также есть аналогичная схема для Boolean, только в valueof(boolean) возвращаются просто константы.
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false); 

Примеры:
```java
public class Temp {
    public static void main(String []args){
        Integer i1 = 10;
        Integer i2 = 10;
        System.out.println(i1 == i2);
    }
}
```  
напечатает он true.

А вот еще один код:
```java
public class Temp {
    public static void main(String []args){
        Integer i1 = 130;
        Integer i2 = 130;
        System.out.println(i1 == i2);
    }
}
```  
Этот код уже выведет false.  

Устаревшие конструкторы Boolean:
System.out.println(new Boolean(true)); //true
System.out.println(new Boolean("true")); //true
System.out.println(new Boolean("TRUE")); //true
System.out.println(new Boolean(false)); //false
System.out.println(new Boolean("kek")); //false
System.out.println(new Boolean(null)); //false
System.out.println(new Boolean(true) == true); //true!        
[к оглавлению](#Garbage-Collection)

## Расскажите о String.intern  
Когда вызывается метод intern, если пул уже содержит строку, равную этому объекту , определяемому через метод  equals(Object), тогда возвращается строка из пула. 
Иначе, этот объект  добавляется к пулу и возвращается ссылка на этот объект. 
Метод intern() используется для хранения строк в пуле строк. Метод intern можно использовать, 
для добавления строки представленной оператором new("новая строка") или методом, 
тогда эта строка попадет в пул и не будет создан новый объект.  


Конкатенация:  
("ver" == "v" + "er" выдаст тру, конкатенация не появлияет на результат)  
 
Но если используем +=, то:  
a = "Bye";  
a += " bye!";  
b = "Bye bye!";  
compare = (a == b); // This return false  

Этот пример немного отличается от предыдущего, потому что используется оператор +=, который при компиляции в байт-код использует StringBuilder для объединения строк, 
поэтому он создает новый экземпляр объекта StringBuilder, указывая таким образом на другую ссылку.   


Примерный алгоритм пула строк:
+ Создать множество (hash set) строк
+ Проверить, что строка (как последовательность символов), с которой вы имеете дело, уже в множестве
+ Если да, то использовать строку из множества
+ В противном случае, добавить эту строку в множество и затем использовать ее  
[подробнее](https://jsehelper.blogspot.com/2016/01/java-core-3.html)  

[к оглавлению](#Garbage-Collection)

## Что такое профайлер
Это инструмент для мониторинга производительности Java-приложений и отслеживания узких мест в коде Java.
Профайлер позволяет мониторить программу и анализировать процесс ее выполнения. В java  мы можем следить за работой JVM.
Например, мониторить используемую память, сборки мусора, создаваемые объекты и работающие потоки.  

[к оглавлению](#Garbage-Collection)

## Как использовать VisualVM
VisualVM — это встроенный в JDK профайлер.
Необходимо подключиться к интересующуему нас процессу, и можно мониторить его работу.

Профайлеры вносят свои собственные издержки, так что полезно потратить несколько минут на то, чтобы оценить их. 
Простейший способ обнаружить издержки сначала запустить приложение отдельно, а затем под профайлером, и измерить разницу в производительности. 
Сначала можно запустить приложение с параметром -verbose:gc,  чтобы увидеть циклы сбора мусора, а затем  с подключенным к нему профайлером.
С профайлером может появится последовательность циклов GC, которой в первом случае не было. Это издержки производительности профайлера.

Мы можем мониторить память, сборки мусора, работающие потоки, кол-во загруженных классов и создаванных объектов.
Для анализа можно наблюдать графики, следить за количественным представлением или создать дамп кучи для автономного анализа.  

## Чем отличается sampling от profiling
VisualVM’s profiler works by “instrumenting” all of the methods of your code.
This adds extra bytecode to your methods for recording when they’re called, and how long they take to execute each time they are.  
VisualVM’s sampler, however, takes a dump of all of the threads of execution on a fairly regular basis, and uses this to work out how roughly how much CPU time each method spends.

При сэмплинге делается множество дампов для получения данных, при этом часть инф-ии может соотвественно теряться, но мы не меняем байткод.
При профайлинге используются инструментальные агенты - код, который следит за выполнением методов, мы получаем все данные, 
но меняется байткод, что может сломать программу или увеличить время работы. Но такой метод более точный.  
[подробнее](https://coderlessons.com/articles/java/profilirovanie-java-pod-pokrovom)    
[подробнее](https://blog.idrsolutions.com/2014/04/profiling-vs-sampling-java-visualvm/)    

[к оглавлению](#Garbage-Collection)
 
## Расскажите о benchmark
Бенчмарк — тест производительности компьютерной системы.  

Самый простой способ по-настоящему проверить свой код — это Java Microbenchmark Harness (JMH).
Он помогает оценить фактическую производительность, принимая во внимание **прогрев JVM и оптимизацию кода**, которые могут сделать результат неясным.
JMH стал де-факто стандартом для тестов производительности и был включен в JDK 12.

Алгоритм создания простого бенчмарка JMH:

+ Добавляем зависмости:  
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.19</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.19</version>
</dependency>

+ Создаем бенчмарк методы, используя аннотацию @Benchmark:
```java
import org.openjdk.jmh.annotations.Benchmark;

public class BenchmarkDemo {

    @Benchmark
    public void benchmark1() {
    }
    @Benchmark
    public void benchmark2() {
    }
}

// Добавляем гланвый класс, который запускает бенчмарк процесс

public class BenchmarkRunner {
    public static void main(String[] args) throws Exception {
        org.openjdk.jmh.Main.main(args);
    }
}
```
Далее будет проведено опрделенное число итераций прогрева JVM  и итераций измерения для более точного результата.
В итоге мы получим сводную таблицу с результатами показателей производительности.

Result "gc.BenchmarkDemo.benchmark2":  
819726266,834 ±(99.9%) 50134336,159 ops/s [Average]  
(min, avg, max) = (125549633,730, 819726266,834, 1018254832,141), stdev = 212271918,539  
CI (99.9%): [769591930,675, 869860602,993] (assumes normal distribution)
  
  
Benchmark: BenchmarkDemo.benchmark1, BenchmarkDemo.benchmark1  
Mode: thrpt    
Cnt: 200    
Score: 868453297,232 ± 45812959,657,  819726266,834 ± 50134336,159 ops/s  
(ops -operations per second)

JMH supports some possible benchmarks: Throughput, AverageTime, SampleTime, and SingleShotTime. 
Также мы можем изменять настройки бенчмарка:

By using the @Fork annotation, we can set up how the benchmark execution happens: the value parameter controls
how many times the benchmark will be executed, and the warmup parameter controls how many times a benchmark will dry run before results are collected, for example:  
@Benchmark  
@Fork(value = 1, warmups = 2)  
@BenchmarkMode(Mode.Throughput)  
public void init() {  
// Do nothing  
}  
Эта инструкция говорит запустить два прогревочных бенчамарка и отбросить результаты, прежде чем начать реальный бенчмарк.
This instructs JMH to run two warm-up forks and discard results before moving onto real timed benchmarking.
Also, the @Warmup annotation can be used to control the number of warmup iterations. For example, @Warmup(iterations = 5)
tells JMH that five warm-up iterations will suffice, as opposed to the default 20.  
[подробнее](https://www.baeldung.com/java-microbenchmark-harness)
[подробнее](https://yandex.ru/turbo/nuancesprog.ru/s/p/8792/)  

[к оглавлению](#Garbage-Collection)

## Расскажите о методе finalized
@Deprecated(since="9")  
protected void finalize() throws Throwable { }

В классе Object finalize не выполняет никакого действия, но наследник может переопределить его.
Например, finalize для объекта, который представляет Connection может закрыть соединение, до того как объект будет удален, т.е. очистит ресурсы.

Finalize –  определен в классе Object, таким образом, доступен для всех без исключения объектов в Java.
finalize() вызывается в исполняющей среде Java непосредственно перед удалением объекта.
Таким образом, сборщик мусора вызывает его для объектов, на которые больше нет ссылок и которые помечены для сбора мусора.

Предназначен этот метод, чтобы автоматически (наверняка) освободить системные ресурсы, занимаемых объектом, на котором будет данный метод вызван.
(например, когда мы создаем поток для работы с файлом, чтобы освободить потом ресурсы)
Использовался раньше во встроенных библиотеках java, cамому использовать не рекомендуется. 
К примеру, казалось бы в абстрактном классе InputStream можно было сделать finalize(), вызывающий close() для пущего удобства. 
По факту же finalize() определён только в тех дочерних классах, которые работают непосредственно **с системными ресурсами** (например, FileInputStream).
А, скажем, в BufferedInputStream finalize() не нужен, даже если он оборачивает FileInputStream. Здесь избыточная универсальность вредна.  
**Как я понял, в текущее время даже во встроенных (например, FileInputStream) finalize() заменен на использование фантомных ссылок.**    

Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод finalize(). 
Поэтому не стоит полагаться на finalize для чистки данных. Во-первых, нет гарантии, что он будет вызван, т.к. где-то может остаться ссылка на объект. 
Во-вторых, нет гарантии на то, в какое время будет вызван метод. Это связано с тем, что после того, как объект становится доступным для сборки,
если в нем переопределен метод finalize, то он не вызывается сразу, а помещается в очередь, которая обрабатывается специально созданным для этого потоком. 
Когда объекты становятся ненужными, они попадут в очередь на финализацию и определенное время еще будут занимать память, вместо того, чтобы миновать этой очереди и сразу утилизироваться.
Стоит отметить, что в очередь на финализацию попадают только те объекты, в которых переопределен метод finalize.
Есть вероятность, что этот метод не будет вызван совсем.   

Непосредственно вызов finalize() происходит в отдельном потоке «Finalizer», 
который создаётся при запуске виртуальной машины. 
Методы finalize() вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. 
Соответственно, если какой-то finalize() зависнет, он подвесит поток «Finalizer», но не сборщик мусора.
Это в частности означает, что объекты, не имеющие метода finalize(), будут исправно удаляться,
а вот имеющие будут добавляться в очередь, пока не отвиснет поток «Finalizer»,
не завершится приложение или не кончится память. При этом пока у объектов не будет выполнен метод finalize, они не будут очищены.  

Есть один способ быть уверенным, что finalize-методы были запущены для объектов, доступных для сборки:
вызвать System.runFinalization() или Runtime.getRuntime().runFinalization().(одно и то же) 
Выход из метода осуществляется только тогда, когда все доступные методы объектов для финализации будут выполнены - эти методы. ( у меня в примере не сработало)  
Следует ещё сказать о такой штуке, как System.runFinalization(). Этот вызов создаёт второй поток «SecondaryFinalizer»,
который так же вызывает finalize() для объектов из той же очереди. При этом поток, вызвавший System.runFinalization() ждёт,
пока не кончится очередь Finalizer, которая имеется на данный момент. В принципе, он может вас спасти от OutOfMemory, если основной Finalizer завис.  
Вообще явный вызов System.runFinalization() в программе скорее говорит о том, что что-то не так.

finalize() необходим при работе с нативным кодом и освобождения ресурсов там, а исключить вероятность работы Java с С-кодом нельзя.
**И самое главное - начиная с Java 9 этот метод не рекомендуется к использованию.** Но все таки приведем пример его использования.

```java
public class Cup {
    private Spoon spoon;

    public Cup(Spoon spoon) {
        this.spoon = spoon;
    }

    @Override
    protected void finalize()  {
        System.out.println("Чашка исчезает навсегда");
    }

    public static void main(String[] args) {
        Cup cup = new Cup(new Spoon());
        cup = null;
        System.gc();
     }
}
```    
[подробнее](https://habr.com/ru/post/144544/)

[к оглавлению](#Garbage-Collection)

## Расскажите о методе clone  
(Deep clone and shallow clone)  

Бывают случаи, когда надо получить копию объекта, которая НЕ зависит от оригинала. Этот процесс в Java называется клонированием.

Для клонирования объекта в Java можно воспользоваться тремя способами:
+ Переопределение метода clone() и реализация интерфейса Cloneable().
+ Использование конструктора копирования.
+ Использовать для клонирования механизм сериализации.

protected native Object clone() throws CloneNotSupportedException;  
Creates and returns a copy of this object. The precise meaning of "copy" may depend on the class of the object.

- Private — объявляет метод или свойство доступным только в том классе в котором он присутствует. 
То есть в другом классе к private методам и свойствам мы не можем обращаться ни из объектов, ни из дочерних классов.
- Protected — объявляет метод или свойство защищенными. То есть такими, которые не могут быть доступны из объекта, 
реализующего класс(только если объект не создан внутри самого класса), но вполне может быть использовано в дочерних классах.
- Public. Классы и методы, объявленные public, могут быть доступны как внутри самого класса, так и в дочерних классах и в объектах, реализовавших класс.

Основнйо контракт для метода clone():
- x.clone()!=x, will be true.
- x.clone().getClass() == x.getClass(), will be true, but these are not absolute requirements.
While it is typically the case that:
- x.clone().equals(x), will be true, this is not an absolute requirement.

Класс Object определяет метод clone(), который создает копию объекта. 
Если вы хотите, чтобы экземпляр вашего класса можно было клонировать, необходимо переопределить этот метод и реализовать интерфейс Cloneable. 
Интерфейс Clonable - это интерфейс-маркер, он не содержит ни методов, ни переменных. Интерфейсы-маркер просто определяют поведение классов.
*Object.clone() выбрасывает исключение CloneNotSupportedException при попытке клонировать объект не реализующий интерфейс Cloneable.*

Метод clone() в родительском классе Object является protected, поэтому желательно переопределить его как public. 
Реализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование. Рассмотрим пример:

*Shallow clone* (Поверхностное клонирование)
```java
public class Car implements Cloneable {
    private String name;
    private Driver driver;

    public Car(String name, Driver driver) {
        this.name = name;
        this.driver = driver;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Driver getDriver() {
        return driver;
    }
    public void setDriver(Driver driver) {
        this.driver = driver;
    }

    @Override
    public Car clone() throws CloneNotSupportedException {
        return (Car) super.clone();
    }
}

public class Driver implements Cloneable {
    private String name;
    private int age;

    public Driver(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public Driver clone() throws CloneNotSupportedException {
        return (Driver) super.clone();
    }
}

public class CloneCarDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        Car car = new Car("Грузовик", new Driver("Василий", 45));
        Car clonedCar = car.clone();
        System.out.println("Оригинал:\t" + car);
        System.out.println("Клон:   \t" + clonedCar);

        Driver clonedCarDriver = clonedCar.getDriver();
        clonedCarDriver.setName("Вася");

        System.out.println("Оригинал после изменения имени водителя:\t" + car);
        System.out.println("Клон после изменения имени водителя:   \t\t" + clonedCar);
    }
}
```
В этом примере клонируется объект класса Car.
Клонирование выполняется поверхностное - новый объект clonedCar содержит ссылку на тот же объект класса Driver,
что и объект car. Если вас это не устраивает, то необходимо самим написать "глубокое" клонирование - создать новый объект класса Driver.  
  
Перепишем метод clone() класса Car:  
Пример 2. Deep clone (Глубокое клонирование):  

@Override  
public Car clone() throws CloneNotSupportedException {  
Car newCar = (Car) super.clone();  
Driver driver = getDriver().clone();  
newCar.setDriver(driver);  
return newCar;  
}  
**Т.е. в этом случае мы также клонируем целевой объект, затем клонируем у целевого объекта отдельные поля и сетим эти поля в клон объекта.**  

Конструктор копирования  
Еще один вариант клонирования объекта - это конструктор копирования. Создается конструктор, принимающий на вход объект того же класса, который необходимо клонировать:

Пример 3. Конструктор копирования с поверхностным клонированием

```java
public class Car implements Cloneable {
    private String name;
    private Driver driver;

    public Car(String name, Driver driver) {
        this.name = name;
        this.driver = driver;
    }

    /**
     * Конструктор копирования.
     *
     * @param otherCar
     */
    public Car(Car otherCar) {
        this(otherCar.getName(), otherCar.getDriver());
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Driver getDriver() {
        return driver;
    }

    public void setDriver(Driver driver) {
        this.driver = driver;
    }
}
```
Опять же  - пример показывает неглубокое клонирование. Перепишем конструктор для реализации "глубокого" копирования:

Пример 4.  Конструктор копирования с "глубоким" клонированием  
public Car(Car otherCar) throws CloneNotSupportedException {  
  this(otherCar.getName(), otherCar.getDriver().clone());  
}  
[подробнее](https://www.examclouds.com/ru/java/java-core-russian/cloning)  

[к оглавлению](#Garbage-Collection)  

[к оглавлению](#Garbage-Collection)

 


