## Stream  
[источник-хабр](https://habr.com/ru/company/luxoft/blog/270383/) **!!!**   
[источник](https://annimon.com/article/2778)   

+ [Что такое lambda-выражение?](#Что-такое-lambda-выражение)
+ [Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение?](#Как-быть-в-ситуации-если-внутри-lamdba-выражении-операторы-могут-выкинуть-исключение)  
+ [Расскажите о зоне видимости переменных в lamdba - выражениях?](#Расскажите-о-зоне-видимости-переменных-в-lamdba-выражениях)
+ [Лямбда-выражения и захват переменных](#Лямбда-выражения-и-захват-переменных)
+ [Ссылки на методы, конструкторы](#Ссылки-на-методы-конструкторы)
+ [Встроенные функциональные интерфейсы](#Встроенные-функциональные-интерфейсы)
+ [Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#Какие-функциональные-интерфейсы-из-пакета-java-util-function-поддерживают-функции-высшего-порядка)
+ [Что такое Stream API?](#Что-такое-Stream-API)
+ [Способы создания Stream](#Способы-создания-Stream)
+ [Параллельные потоки данных](#Параллельные-потоки-данных)
+ [Расскажите, какой шаблон проектирования используется внутри Stream API?](#Расскажите-какой-шаблон-проектирования-используется-внутри-Stream-API)
+ [Методы](#Методы)
+ [Что делает метод reduce](#Что-делает-метод-reduce)  
+ [Peek](#Peek)  
+ [Что делает метод map](#Что-делает-метод-map)
+ [Что делает метод flatmap](#Что-делает-метод-flatmap)
+ [Что делает метод collect?](#Что-делает-метод-collect)
+ [Что делает метод findFirst?](#Что-делает-метод-findFirst)
+ [Что такое Optional?](#Что-такое-Optional)
+ [Перечислите методы Optional?](#Перечислите-методы-Optional)
+ [Возможно ли прервать выполнение потока по аналогии с break?](#Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
+ [Возможно ли пропустить элемент потока по аналогии с continue?](#Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
+ [В каких случаях можно использовать var?](#В-каких-случаях-можно-использовать-var)

## Что такое lambda-выражение?
```java
public class Lambda {
    public static void main(String[] args) {
        /* создали лямбду: */
        Consumer<String> printer = x -> System.out.println(x); // или ссылку на метод System.out::println
//создали лямбду
        printer.accept("Hello"); // вызвали лямбду через функц.интерфейс, передав в его метод аргумент
    }
}
```
Лямбда - это объект класса, который служит реализацией для функционального интерфейса и содержит реализацию его абстрактного метода.    
Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
Лямбда-выражение можно использовать только в том контексте, в котором определен его целевой тип. (функц. интерфейс)  
К числу контекстов целевого типа относятся инициализация переменных, операторы return и аргументы методов.
  
Зачем используются лямбды: 
+ Для универсальности, например, в методе есть параметр предикат, мы передаем разные условия (лямбды) и получаем разные реализации одного метода.  
+ Можно вместо компоратора передать лямбду и не создавать целый класс. 

```java
interface MyNumber {
double getValue();
}  
MyNumЬer myNum;
myNum = () -> 123.45;
```  
**Когда лямбда-выражение появляется в контексте своего целевого типа, автоматически создается экземпляр класса, 
реализующего функциональный интерфейс, причем лямбда-выражение определяет поведение абстрактного метода, объявляемого
в функциональном интерфейсе.** А когда этот метод вызывается через свой адресат, выполняется лямбда-выражение. 
Таким образом, лямбда-выражение позволяет **преобразовать сегмент кода в объект.** Т.е. позволяет передать метод, как объект. 
Например, мы можем использовать целевой тип как параметр метода, соответственно передавая разные лямбды, мы сможем испольовать разные  
реализации этого целевого типа, не меняя код - отсюда более универсальное использовние кода. 
(например, удобно передавать разные условия и фильтры в форме предиката)  
    
Таким образом, удобно прописывать и использовать конкретные реализации функц. интерфейсов.
   
Блочные лямбды:  
```java
interface NumericFunc{
int func (int n);
}
class BlockLambdaDemo {
public static void main(String args[])
{
//Это блочное лямбда-выражение вычисляет
//факториал целочисленного значения
NumericFunc factorial = (n) -> {
int result = 1;
for(int i= 1; i <= n; i++)
result = result * i;
return result;
};
System.out.println("Фaктopиaл числа 3 равен "
+ factorial.func(3));
System.out.println("Фaктopиaл числа 5 равен"
+ factorial.func(S));
}
}
```  
  
[оглавление](#stream)  

##	Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение?
Если оно генерирует проверяемое исключение, то последнее должно быть совместимо с исключениями,
перечисленными в выражении throws из объявления абстрактного метода в функциональном интерфейсе.  

[оглавление](#stream)  

##	Расскажите о зоне видимости переменных в lamdba - выражениях?
В лямбда выражении можно:
1) получить или установить значение переменной экземпляра 
2) статической переменной
3) вызвать метод из объемлющего его класса.
4) Если в лямбда-выражении используется локальная переменная из объемлющей его области видимости, то возникает особый случай, 
называемый захватом переменной. В этом случае в лямбда-выражении можно использовать только те локальные переменные, 
которые действительно являются конечными. Действительно конечной считается такая переменная, значение которой не изменяется после ее первого присваивания.
Следует, однако, иметь в виду, что локальная переменная из объемлющей области видимости не может быть видоизменена в лямбда-выражении.
 Ведь это нарушило бы ее действительно конечное состояние, а следовательно, привело бы к недопустимому ее захвату.
Пример изменения локальной переменной:
int s = 10;  
Runnable r = () -> { System.out.println(s); };  
s = 20;  
r.run();//Какое значение выведется тут в sysout? 10 или 20?  
Чтобы результат был очевиден, int s = 10; не должен изменяться, и поэтому компилятор сообщит об ошибке изменнения final переменной.    

[оглавление](#stream)  

## Лямбда-выражения и захват переменных  
Переменные, определяемые в объемлющей области действия лямбда-выражения, доступны в этом выражении. Например, 
в лямбда-выражении можно использовать переменную экземпляра или статическую переменную, определяемую в объемлющем
его классе. В лямбда-выражении доступен также по ссылке this (явно или неявно) вызывающий экземпляр объемлющего его класса. 
Таким образом, в лямбда выражении можно получить или установить значение переменной экземпляра или статической переменной 
и вызвать метод из объемлющего его класса.  

Но если в лямбда-выражении используется локальная переменная из объемлющей его области видимости, то возникает особый случай, 
называемый захватом переменной. В этом случае в лямбда-выражении можно использовать только
те локальные переменные, которые действительно являются конечными.  
Действительно конечной считается такая переменная, значение которой не изменяется после ее первого присваивания. 
Такую переменную совсем не обязательно объявлять как final, хотя это и не считается ошибкой. 
Следует, однако, иметь в виду, что локальная переменная из объемлющей области видимости не может быть видоизменена в лямбда-выражении.  

Следует особо подчеркнуть, что в лямбда-выражении можно использовать и видоизменять переменную экземпляра из вызывающего его класса.
  
[оглавление](#stream)  

## Ссылки на методы, конструкторы  
Ссылка на метод  позволяет обращаться к методу, не вызывая его. Она связана с лямбда-выражениями потому, 
что ей также требуется контекст целевого типа, состоящий из совместимого функционального интерфейса. 
Такая ссылка позволяет обращаться к методу, не вызывая его. Т.е. вместо лямбды мы используем ссылку на уже существующий метод.            

Ссылка на метод имеет вид: 
+ имя_класса::имя_статического_метода (если метод статический) 
+ объект_класса::имя_метода (если метод нестатический).  
Следовательно, в выражении МуStringОрs:: strReverse вычисляется ссылка на объект того класса, в котором метод strReverse () 
предоставляет реализацию метода func () из функционального интерфейса StringFunc.
  
## Ссылки на статические методы   
Для создания ссылки на статический метод служит следующая общая форма:
имя_класса: :имя_метода  
  
## Ссылки на методы экземпляра  
**Для передачи ссылки на метод экземпляра для конкретного объекта служит следующая общая форма:  
ссылка_на_объект: :имя_метода**    
```java
interface StringFunc {
String func(String n);
}
class MyStringOps {
String strReverse(String str) {
String result = "";
return result;
}
}

class MethodRefDerno2 {

static String stringOp(StringFunc sf, String s) {
return sf.func(s);
}

public static void main(String args[])
{
String inStr = "Лямбда-выражения повышают "+ "эффективность Java";
String outStr;
//создать объект типа MyStringOps
MyStringOps strOps = new MyStringOps();
outStr = stringOp(strOps::strReverse, inStr);
}
}
```
В теле метода main () создается экземпляр strOps класса MyStringOps. Этот
экземпляр служит для создания ссылки на свой метод strReverse(). В данном примере метод экземпляра strReverse() вызывается для **объекта strOps.**  

Возможны и такие случаи, когда требуется указать метод экземпляра, который будет использоваться вместе с любым объектом данного класса, 
а не только с указанным объектом.   
В подобных случаях можно создать ссылку на метод экземпляра в следующей общей форме:  
+ **имя_класса::имя_метода_экземпляра**  
  
**В этой форме имя класса заменяет имя конкретного объекта, несмотря на то, что в ней указывается метод экземпляра. 
В соответствии с этой формой первый параметр метода из функционального интерфейса совпадает с вызывающим
объектом, а второй параметр - с параметром, указанным в методе экземпляра.** 
Сам же метод-реализация имеет на параметр меньше, т.к. первый параметр - это вызывающий объект. (т.к. это ссылка на метод экземпляра)  
 
```java
interface MyFunc<T> {
    boolean func(T vl, T v2);
}

class HighTemp {
    private int hTemp;

    HighTemp(int ht) {
        hTemp = ht;
    }

    boolean sameTemp(HighTemp ht2) {
        return hTemp == ht2.hTemp;
    }
}

class Demo {
    public static void main(String args[]) {
        MyFunc<HighTemp> myFunc = HighTemp::sameTemp;
        System.out.println(myFunc.func(new HighTemp(1), new HighTemp(2)));
    }
} 
``` 
**Т.е. т.к. мы явно не указали вызывающий объект в ссылке на метод, мы явно указываем его как первый аргумент.**  
Т.е. во втором варианте, конкретный объект мы также указываем, но в вызове абстрактного метода функционального интерефейса, 
а не в ссылке на метод, и благодаря этмоу можем подставлять любой конкретный объект.      

**Ссылки на обобщенные методы** 
```java
MyArrayOps::<Integer> countMatching
``` 
Если передаем ссылку на метод в обобщенный целевой тип, то просто указывааем параметры типа класса перед методом.       

## Ссылки на конструкторы  
Ссылки на конструкторы можно создавать таким же образом, как и ссылки
на методы. Ниже приведена общая форма синтаксиса, которую можно употреблять
для создания ссылок на конструкторы.  
имя_класса:: new  
```java
//Продемонстрировать применение ссылки на конструктор метод, возвращающий ссылку на класс MyClass
interface MyFunc {
MyClass func(int n);
}
class MyClass{
private int val;
// Этот конструктор принимает один аргумент
MyClass(int v) { val = v; }
//А это конструктор по умолчанию
MyClass() { val = О;

int getVal(){ return val; };

class ConstructorRefDemo {
pubic static void main(String args[])
{
//создать ссылку на конструктор класса MyClass.
//Метод func() из интерфейса MyFunc принимает аргумент, поэтому в операции new вызывается 
// параметризованный конструктор класса MyClass, а не к его конструктор по умолчанию
MyFunc myClassCons = MyClass::new;
MyClass mc = myClassCons.func(100);

System.out.println("Знaчeниe val в объекте mc равно "
+ mc.getVal());
}
}
```  
По существу, переменная myClassCons предоставляет еще один способ вызвать конструктор MyClass (int v).  
Количество аргументов определяется по параметрам метода в целевом типе.  
Обычно применяется в статических фабричных методах для создания объектов разных классов.  
Используется в стримах, например, чтобы указать параметр в методе, принимающий конструкторы разных коллекций:  
toMap(Function<? super T, ? extends K> keyMapper,  
                             Function<? super T, ? extends U> valueMapper,  
                             BinaryOperator<U> mergeFunction,  
                             Supplier<M> mapFactory) {  
Supplier<M> mapFactory =  get(); = HashMap::new                               
                                     
## Ссылки на конструктор массива  
стр 486, Шилдт.  
тип[]::new  
```java
interface MyArrayCreator<T>{
Т func(int n);
}

MyArrayCreator<MyClass[]> mcArrayCons = MyClass[]::new;
MyClass[] а = mcArrayCons.func(2);
а[О] = new MyClass(l);
a[l] = new MyClass(2)  
```
Как правило, функциональный интерфейс должен содержать метод, принимающий единственный параметр типа int, 
если он служит для обращения к конструктору массива.  

[оглавление](#stream)

##	Встроенные функциональные интерфейсы
Функциональный интерфейс — это интерфейс, который содержит единственный абстрактный метод. 
Но может включать несколько методов по умолчанию и переопределенных методов класса Object.

Функциональные интерфейсы из пакета java.util.function.    
[источник - метанит](https://metanit.com/java/tutorial/9.3.php) [источник](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)  

Consumer, Runnable, Function<T,R>, Predicate, Supplier, UnaryOperator, BinaryOperator:  
+ Predicate - проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.   
В качестве параметра лямбда-выражение принимает объект типа T     
public interface Predicate<T> {  
    boolean test(T t);  
}  

+ BinaryOperator - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию 
и возвращает ее результат также в виде объекта типа T    
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}

+ UnaryOperator - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T   
public interface UnaryOperator<T> {
    T apply(T t);
}
+ Function<T,R> - представляет функцию перехода от объекта типа T к объекту типа R  
public interface Function<T, R> {
    R apply(T t);
}

+ Consumer - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая  
public interface Consumer<T> {
    void accept(T t);
}
+ Runnable void run()- не принимает агрументы, не возвращает значение.  
https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html  

+ Supplier – не принимает никаких аргументов, но должен возвращать объект типа T   
public interface Supplier<T> {
    T get();
}  

[оглавление](#stream)

##	Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?
Фу́нкция вы́сшего поря́дка — в программировании функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.  
 
В Java метод  может возвращать лямбда-выражение. Т.е. функциональные интерфейсы, в которых определены дефолтные методы, 
принимающие или возвращающие ссылку на функциональный интерфейс. 

Или все, если рассматривать ссылку на интерфейс как параметр для функции.
-Например, Consumer<T>: default Consumer<T> andThen(Consumer<? super T> after)
- Predicate<T>: default Predicate<T> and(Predicate<? super T> other) {
Objects.requireNonNull(other);
return (t) -> test(t) && other.test(t);}  

[оглавление](#stream)

##	Что такое Stream API?  
Stream API -  это новый способ работать со структурами данных в функциональном стиле.  
Stream API – прикладной потоковый интерфейс, API предоставляет средства для обработки данных, главной его особенностью является 
способность выполнять очень сложные операции поиска, фильтрации, преобразования и иного манипулирования данными. 
Поток данных представляет собой последовательность объектов. Поток данных оперирует источником данных,
например массивом или коллекцией. В самом потоке данные не хранятся, а только перемещаются и, возможно, фильтруются, 
сортируются или обрабатываются иным образом в ходе этого процесса. 
Но, как правило, действие самого потока данных не видоизменяет их источник. 
Например, сортировка данных в потоке не изменяет их упорядочение в источнике, а приводит к созданию нового потока данных, 
дающего отсортированный результат.

Stream API – это набор потоковых интерфейсов, входящих в состав пакета java.util.stream. 
В основание их иерархии положен интерфейс BaseStream, где определяются базовые функциональные возможности всех потоков данных.  

В свою очередь, интерфейс BaseStream расширяет интерфейс AutoCloseaЫe, потоком
данных можно управлять в try с ресурсами. Но, как правило, закрывать приходится только те потоки данных, где источники данных требуют
закрытия (например, потоки, которые связаны с файлами). В то же время потоки, источниками данных для которых обычно служат коллекции,
закрывать не нужно.  

BaseStream - базовый интерфейс для потоков, представляющих собой последовательности элементов, поддерживающих 
последовательные и параллельные агрегатные операции:    
```java
public interface BaseStream<T, S extends BaseStream<T, S>>
        extends AutoCloseable {
    /**
     * Returns an iterator for the elements of this stream.
     */
    Iterator<T> iterator();

    Spliterator<T> spliterator();

    /**
     * Returns whether this stream, if a terminal operation were to be executed,
     * would execute in parallel.  
     */
    boolean isParallel();

    /**
     * Returns an equivalent stream that is sequential.  
     */
    S sequential();

    /**
     * Returns an equivalent stream that is parallel.  
     */
    S parallel();

    /**
     * Returns an equivalent stream that is unordered. 
     */
    S unordered();

    @Override
    void close();
}

```
Производными от интерфейса BaseStream являются несколько типов интерфейсов.
Наиболее употребительным из них является интерфейс Stream.  

```java
public interface Stream<T> extends BaseStream<T, Stream<T>> {

    /**
     * Returns a stream consisting of the elements of this stream that match mthe given predicate.
     */
    Stream<T> filter(Predicate<? super T> predicate);

    /**
     * Returns a stream consisting of the results of applying the given function to the elements of this stream
     */
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);

    /**
     * Returns an {@code IntStream} consisting of the results of applying the given function to the elements of this stream.
     */
    IntStream mapToInt(ToIntFunction<? super T> mapper);
// etc
}
```    

Для перебора кроме оперции foreach, можно использовать Iterator и Spliterator, работа с ним осуществляется также как в коллекциях. 
Итератор становится как бы терминальной операцией.    

[оглавление](#stream)  

## Способы создания Stream  

•	Пустой стрим: Stream.empty()  
•   Stream.ofNullable(T) - если передаваемый элемент - null, то возвращает пустой стрим, если нет - то просто стрим. Защищает от NullPointerException.    
Stream.ofNullable(2); Stream.ofNullable(null);  
Просто выведет элементы, но если null, то вместо NullPointerException, мы бы получили Stream.empty().   
•	Стрим из List: list.stream()  
•	Стрим из Map: map.entrySet().stream()  
•	Стрим из массива: Arrays.stream(array)  
•	Стрим из указанных элементов: Stream.of("1", "2", "3")  
•	Стрим из строк из потока BufferReader: bufferreader.lines();  
•	Стрим символов из строки:"твояСтрока".chars() - возвращает IntStream  
•	Стрим значений в диапазоне: IntStream.range(0, 100) – дает поток элекментов от 1 до 100 с шагом в единицу ( 1, 2,3 …99 не включая границу)    
IntStream.rangeClosed(0, 100) – тоже самое, включая правую границу ( 1,2,3 ... 100)  
•	Бесконечных стрим: Stream.iterate(1, n -> n + 1) - начальное значение = 1, функция аккамулятора = n + 1   
  

Получить лист символов из строки:    
List<Character> charList = "твояСтрока".chars().mapToObj(c -> (char) c).collect(Collectors.toList());  

Получить из массива int массив Integer:
Integer[] integerArray = IntStream.of(intArray).boxed().toArray(Integer []::new);  

Получить из массива сhar массив Character:   
char[] array = {'a','c','b'};
Character[] newArray = IntStream.range(0, array.length).mapToObj(i -> array[i]).toArray(Character[]::new);      
  
[оглавление](#stream) 

## Конвейерные или Терминальные операции  
1. Конвейерные — возвращают другой stream, то есть работают как builder.  
2. Терминальные — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.
(после терминального стрим уже нельзя переиспользовать)  

Общее правило: у stream'a может быть сколько угодно вызовов конвейерных вызовов и в конце один терминальный, 
при этом все конвейерные методы выполняются лениво и пока не будет вызван терминальный метод никаких действий на самом деле не происходит,
 так же как создать объект Thread или Runnable, но не вызвать у него start.    
  
Оконечная операция потребляет поток данных и дает конечный результа например обнаруживает минимальное значение 
в потоке данных или выполняет некоторое действие, как это делает метод forEach(). Если поток данных потреблен, 
он не может быть использован повторно.  
А промежуточная операция производит поток данных и служит для создания конвейера для выполнения последовательности
действий.  
Кроме тоrо, промежуточные операции не выполняются немедленно. Напротив, указанное действие происходит в том случае, когда
оконечная операция выполняется в новом потоке данных, созданном промежуточной операцией. Такой механизм называется отложенным поведением,
а промежуточные операции - отложенными. Благодаря отложенному поведению потоковый прикладной интерфейс API действует более эффективно.  

**В самом объекте Stream не сохраняются конкретные элементы, он представляет последовательность инструкций,
которые надо совершить над источником данных.**         

Еще одна особенность потоков данных состоит в том, что одни промежуточные операции выполняются без сохранения состояния (filter),
а другие - с сохранением состояния (sorted). В операции без сохранения состояния каждый элемент обрабатывается независимо
от остальных.  

Для обработки потоков примитивных типов данных в потоковом API определяются следующие специальные интерфейсы:
• DouЬleStream    
• IntStream       
• LongStream    

[оглавление](#stream)  

##  Параллельные потоки данных
+ parallelStream() - получить параллельный стрим  
+ isParallel -	Узнать является ли стрим параллельным
+ parallel -	Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
+ sequential -	Вернуть последовательный стрим, если стрим уже последовательный, то может вернуть самого себя
 
Как только будет получен параллельный поток данных, последующие операции в этом потоке могут выполняться параллельно, 
при условии, что параллелизм поддерживается в исполняющей среде.  
Например, операция сведения, выполняемая методом reduce(), может быть распараллелена, если вызов метода stream() заменить вызовом метода parallelStream (). 
Результат окажется тем же самым, но операция умножения может быть распараллелена в разных потоках исполнения.  
  
Как правило, любая операция в параллельном потоке данных должна выполняться без сохранения состояния, без вмешательства, должна быть ассоциативной. 
Этим гарантируется, что результаты выполнения операций в параллельном потоке данных остаются такими же, как и результаты выполнения аналогичных
операций в последовательном потоке данных.  

Внимание: крайне не рекомендуется использовать параллельные стримы для сколько-нибудь долгих операций (получение данных из базы, сетевых соединений),
так как все параллельные стримы работают c одним пулом fork/join и такие долгие операции могут остановить работу всех параллельных стримов 
в JVM из-за того отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, 
где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты.  

[оглавление](#stream)  

## Расскажите, какой шаблон проектирования используется внутри Stream API?
Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.  
Filter(Predicat <T> PREDIKAT);  
Filter – контекст, фильтрует поток.  
Предикат - обобщенное действие(условие фильтрации)  
Лямбды и ссылки на методы – конкретные реализации условия (предиката)    

[оглавление](#stream)   

##  Методы  
Терминальные методы:  
Операции сведения - это min, max, count, reduce, они сводят стрим к одному объекту - результату.  

+ findFirst - Возвращает первый элемент из стрима (возвращает Optional)  
collection.stream().findFirst().orElse(«1»)  
+ findAny - Возвращает любой элемент из стрима  
collection.stream().findAny().orElse(«1»)  
Получить элемент из Optioanl:
+ get() - возвратит значение элемента, но если оно равно null кинет NoSuchElementException  
+ orElse("0")  
 
+ anyMatch - Возвращает true, если условие выполняется хотя бы для одного элемента  
collection.stream().anyMatch(«a1»::equals)  
+ noneMatch - Возвращает true, если условие не выполняется ни для одного элемента  
+ allMatch - Возвращает true, если условие выполняется для всех элементов

+ forEach - Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
+ forEachOrdered - Применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
  
+ max(Comparator<? super T> comparator)  
collection.stream().max(String::compareTo).get()       
+ count - Возвращает количество элементов в стриме
+ average() - считает среднее для примитивного потока
+ reduce -позволяет выполнять агрегатные функции на всей коллекцией (такие как сумма, нахождение минимального или максимального значение и т.п.),
он возвращает одно значение для стрима, функция получает два аргумента — значение полученное на прошлых шагах и текущее значение.  
Вернуть максимум или -1: collection.stream().reduce(Integer::max).orElse(-1)  
 
Конвейерные методы:  
+ filter - Отфильтровывает записи, возвращает только записи, соответствующие условию  
collection.stream().filter(«a1»::equals).count()
+ distinct - Возвращает стрим без дубликатов (для метода equals)  
collection.stream().distinct().collect(Collectors.toList())  
+ skip - Позволяет пропустить N первых элементов
+ map - Преобразует каждый элемент стрима  
collection.stream().map((s) -> s + "_1").collect(Collectors.toList())

+ peek -  Возвращает тот же стрим, но применяет функцию к каждому элементу стрима. Используется для дебага с System.out.print.   
collection.stream().map(String::toUpperCase).peek((e) -> System.out.print("," + e)).collect(Collectors.toList())  
  
Обе ForEach и Peek по сути делают одно и тоже, меняют свойства объектов в стриме, единственная разница между ними в том,
что ForEach терминальная и она заканчивает работу со стримом, в то время как Peek конвейерная и работа со стримом продолжается.  
**Обе ForEach и Peek - меняют объекты в источнике.**  

+ limit - Позволяет ограничить выборку определенным количеством первых элементов
+  takeWhile(Predicate<? super T> predicate) - берет элементы, пока условие истинно(после перестает брать, даже если условие снова станет истинно)     
+  dropWhile(Predicate<? super T> predicate) - отбрасывает элементы, пока условие истинно, затем возвращает все оставшиеся элементы  

+ sorted - Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator  
collection.stream().sorted((o1, o2) -> -o1.compareTo(o2)).collect(Collectors.toList())  
+ mapToInt, mapToDouble, mapToLong - Аналог map, но возвращает числовой стрим (то есть стрим из числовых примитивов)  
+ boxed() - Преобразует примитивный стрим в объектный.  
Получить массив Double из массива double:
  DoubleStream.of(0.1, Math.PI)
      .boxed()
      .map(Object::getClass)
      .forEach(System.out::println);
  // class java.lang.Double
  // class java.lang.Double  
  
Получить массив Integer из массива int:    
Integer[] integerArray = IntStream.of(intArray).boxed().toArray(Integer[]::new);  
  
+ flatMap, flatMapToInt, flatMapToDouble, flatMapToLong - Похоже на map, но может создавать из одного элемента несколько  
collection.stream().flatMap((p) -> Arrays.asList(p.split(",")).stream()).toArray(String[]::new)  

  
+ Comparator.nullsLast() – размещает null – элементы в конец.  
students.stream().sorted(Comparator.nullsLast((o1, o2) -> o2.getScope() - o1.getScope() ))
.flatMap(Stream::ofNullable).takeWhile(s -> s.getScope() > bound).collect(Collectors.toList());  

+ concat(Stream a, Stream b) - Объединяет два стрима так, что вначале идут элементы стрима A, а по его окончанию последуют элементы стрима B.  
  Stream.concat(Stream.of(1, 2, 3),Stream.of(4, 5, 6)).forEach(System.out::println); // 1, 2, 3, 4, 5, 6  
   
[оглавление](#stream)  

##	Что делает метод reduce?  
Это терминальная операция. В ней можно рассчитать любую функцию над элементами, которая принимает два элемента и возвращает элемент того же типа. 

В методе reduce() понятие сведения обобщается. Вызывая метод reduce(), можно возвратить значение из потока данных по любому 
произвольному критерию. Операция сведения reduce позволяет выполнять агрегатные функции над всей коллекцией 
(такие как сумма, нахождение минимального или максимального значение и т.п.),  он возвращает одно значение для стрима, 
функция получает два аргумента — значение полученное на прошлых шагах и текущий элемент.(вначале первый параметр будет значением идентичности)  
  
+ Optional<T> reduce(BinaryOperator<T> накопитель)
+ Т reduce(T значение_идентичности, BinaryOperator<T> накопитель) - результат возвращается в виде объекта, 
тип которого соответствует типу элемента из потока данных  
+ <U> U reduce(U значение_идентичности, BiFunction<U, ? super Т, U> накопитель, BinaryOperator<U> объединитель)  

Во второй форме параметр значение_идентичности обозначает такое значение, что операция накопления, включающая
значение_идентичности и любой элемент из потока данных, дает в итоге тот же самый элемент без изменения. 
Так, если выполняется операция сложения, то значение идентичности равно нулю, поскольку О + х = х. А если выполняется операция
умножения, то значение идентичности равно 1, поскольку 1 * х = х.   

В обеих формах указанный накопитель обозначает функцию, оперирующую двумя значениями и получающую результат.  
Интерфейсе BinaryOperator определяется следующий абстрактный метод:
Т apply (Т значение1 , U значение2)  

По отношению к методу reduce () параметр значение 1 метода apply () будет
содержать предыдущий результат, тогда как параметр значение 2 - следующий
элемент. При первом вызове данного метода параметр значение 2 будет содержать
значение идентичности или первый элемент в зависимости от применяемого
варианта метода reduce().  

Пример: 
Получить произведение только четных целочисленных значений можно следующим образом:  
int evenProduct = myList.stream() .reduce(l, (а,Ь) -> {  
if(b%2 == 0) return а*Ь; else return а;  
});  

Для применения параллельных потоков данных особенно полезной может оказаться приведенная ниже форма метода reduce().
Эта форма позволяет указать порядок объединения частичных результатов.  
<U> U reduce(U значение_идентичности, BiFunction<U, ? super Т, U> накопитель, BinaryOperator<U> объединитель)  
В данной форме параметр объединитель обозначает функцию, объединяющую два значения, получаемые функцией, определяемой параметром накопитель.
Если обратиться к предыдущему примеру программы, то вычисление произведения элементов из списочного массива myList можно организовать в параллельном
потоке данных следующим образом:    
int parallelProduct = myList.parallelStream().reduce(1, (а,Ь) -> а*Ь, (а,Ь) -> a*b);  
  
Вычисление произведения квадратных корней каждого элемента:      
double productOfSqrRoots = rnyList.parallelStream().reduce(1.0, (а,Ь) -> а* Math.sqrt(Ь), (а,Ь) -> а*Ь);  
Обратите внимание на то, что функция аккумулятора умножает квадратные корни двух элементов, 
тогда как функция объединителя умножает частичные результаты.(промежуточных операций из параллельных выполнений) 
Следовательно, обе функции выполняют разные действия.  
Более того, обе функции должны отличаться, чтобы вычисления выполнялись правильно. Так, если попытаться получить произведение 
квадратных корней элементов списка, используя приведенное ниже выражение, то результат окажется ошибочным.
//Не сработает!
double productOfSqrRoots2 = myList.parallelStrearn().reduce(1.0, (а,Ь) ->а* Math.sqrt(b));
В данной форме метода reduce() функции накопителя и объединителя одинаковы.
И это приводит к ошибке, ведь когда объединяются два частичных результата, перемножаются их квадратные корни, а не сами частичные результаты.  

[оглавление](#stream)  

## Peek  
Используется либо для дебагга, либо чтобы изменить объекты в источнике.    
  
Возвращает тот же стрим, но применяет функцию к каждому элементу стрима. **Оба ForEach(терминальный) и Peek(конвейрный) - меняют объекты в источнике.**    
peek (Consumer action)  
Consumer -  void accept(T t);  

Этот метод часто испольуется  для дебагга, где вы хотите увидеть элементы, когда они проходят мимо определенной точки в конвейре, 
т.е. мы можем вставить его перед любой операцией и вывести элементы через System.out.println, и peek не повлияет на результат. 
(foreach - терминальная и не подходит для этого)

Пример 1:
**Используем для дебагга**  
Stream.of("one", "two", "three", "four")  
     .filter(e -> e.length() > 3)  
     .peek(e -> System.out.println("Filtered value: " + e))  
     .map(String::toUpperCase)  
     .peek(e -> System.out.println("Mapped value: " + e))  
     .collect(Collectors.toList());  
      
Пример 2:  
**Изменяем объекты в источнике**:  
Collection<StringBuilder> list = Arrays.asList(new StringBuilder("a1"), new StringBuilder("a2"), new StringBuilder("a3"));
System.out.println("list = " + list); // напечатает forEachOrdered = [a1, a2, a3]
list.stream().forEachOrdered((p) -> p.append("_new"));
System.out.println("forEachOrdered = " + list); // напечатает forEachOrdered = [a1_new, a2_new, a3_new]

Пример 3:     
Stream.of(0, 3, 0, 0, 5)  
                .peek(x -> System.out.println(x))    
                .forEach(System.out::print);    
//Вывод 0,3,0,0,5   
  
[оглавление](#stream)  

##	Что делает метод map.
Преобразует каждый элемент стрима.  
  
Отображение позволяет задать функцию преобразования одного объекта в другой, то есть получить из элемента одного типа элемент другого типа, 
либо просто преобразовать его определенным образом.(например, получить квадрат каждого элемента)      
Для отображения используется метод map, который имеет следующее определение:  
<R> Stream<R> map(Function<? super T, ? extends R> mapper)    
Function: R apply(T t);  
Передаваемая в метод map функция задает преобразование объектов типа T к типу R. И в результате возвращается новый поток с преобразованными объектами.  

В данном примере исходный поток содержит объекты типа NamePhoneEmail, cостоящие из имен, номеров телефонов и адресов электронной почты. 
На новый поток данных объектов типа NamePhone отображаются только имена и номера телефонов, тогда как адреса электронной почты отбрасываются.  
ArrayList<NamePhoneEmail> myList = new ArrayList<>();  
Stream<NamePhone> nameAndPhone = myList.stream().map((a) -> new NamePhone(a.name, a.phonenum)); (см. src - stream - NamePhoneEmail) 
 
Map, который возвращают поток данных примитивного типа:    
IntStream mapToint(TointFunction<? super Т> функция_ отображения)  
LongStream mapToLong(ToLongFunction<? super Т> функция_ отображения)  
DoubleStream mapToDouЬle(ToDouЬleFunction<? super Т> функция_ отображения)  

Перевод стрима дабл в инт:  
ArrayList<Double> myList = new ArrayList<>();  
IntStream cStrm = myList.stream().mapToint((a) -> (int) Math.ceil(a));  

[оглавление](#stream)  
 
##	Что делает метод flatMap?
**Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько.**  
Например, из коллекции коллекций или массива массивов получить просто коллекцию или массив элементов. 
В качестве аргумента мы обычно передаем лямбду, которая маппит каждый элемент исходного стрима в стрим конечных элементов.      
Это композиция из двух функциональных идиом: map и flatten.  
Данную операцию выполняет метод flatMap:  
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)  
  
Примеры:  
+ If orders is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a
stream containing all the line items in all the orders:
**orders.flatMap(order -> order.getLineItems().stream())...**  
  
+ If path is the path to a file, then the following produces a stream of the words contained in that file:  
**Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);  
Stream<String> words = lines.flatMap(line -> Stream.of(line.split(" ")));**    

Т.е.  например, во втором примере, у нас есть поток из строк, мы хотим получить поток из слов, для этого мы сначала 
маппим каждую строку в массив, затем, в поток слов, далее каждый поток сглаживается и мы получаем общий поток из всех элементов.   

Если бы мы использовали просто map, то он обернул бы поток элементов в еще один поток:  
map(e->e.stream()) = Stream.of(Stream.of(e), Stream.of(e)...),     
мы бы получили стрим стримов, а в flatMap происходит сглаживание и мы получаем один поток из элементов всех потоков.  
  
[оглавление](#stream)

##	Что делает метод collect?  
Метод collect дает возможность преобразовать значение в коллекцию или любой другой тип.  
<R, А> R collect(Collector<? super Т, А, R> функция_накопления)  
 
Мы можем написать свою реализацию функции:  
<R> R collect(
Supplier<R> адресат, 
BiConsumer<R, ? super Т> накопитель, 
BiConsumer <R, R> объединитель)  

Объединитель - функция, которая объединяет два контейнера с частичными результатами. 
Этот метод который нужен для параллельной обработки Collector'a, в данном случае при параллельном стриме коллекция 
может быть разделенной на две части (или больше частей).    
 
LinkedList<NamePhone> npList = nameAndPhone.collect(  
() -> new LinkedList<>(),    
(list, element) -> list.add(element),  
(listA, listB ) -> listA.addAll(listB));    

В классе Collectors определяется ряд статических методов накопления, которымиможно воспользоваться в готовом виде. 
Ниже приведены общие формыдвух употребляемых далее методов toList () и toSet ().  
static <Т> Collector<T, ?, List<T>> toList() : collect(Collectors.toList())    
static <Т> Collector<T, ?, Set<T>> toSet()    

Метод	Описание
1) toList, toCollection, toSet	- представляют стрим в виде списка, коллекции или множества  

2) toConcurrentMap, toMap - позволяют преобразовать стрим в map  
toMap(Function keyMapper, Function valueMapper)  
toMap(Function keyMapper,Function valueMapper, BinaryOperator mergeFunction);  
mergeFunction - функция решения коллизии, если есть значения с одинаковым ключом, например можно объединить все значения в одну строку.  
Map<Integer, String> map4 = Stream.of(50, 55, 69, 20, 19, 52).collect(Collectors.toMap(  
                        i -> i % 5,  
                        i -> String.format("<%d>", i),  
                        (key1, key2) -> String.join(", ", key1, key2)  
                        ));  
toMap(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction, Supplier mapFactory)  
Supplier mapFactory - HashMap::new, указываем конкретный тип мапы, которую хотим создать.                         

3) averagingInt, averagingDouble, averagingLong - возвращают среднее значение
4) summingInt, summingDouble, summingLong	-возвращает сумму
5) summarizingInt, summarizingDouble, summarizingLong	возвращают SummaryStatistics с разными агрегатными значениями
6) partitioningBy -	разделяет коллекцию на две части по соответствию условию и возвращает их как Map<Boolean, List>
, аргументом является функция получения ключа из элемента, которая является предикатом.    
Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate) - возвратит мапу - Map<Boolean, List<T>>>
7) groupingBy разделяет коллекцию на несколько частей и возвращает Map<K, List<T>>, аргументом является функция получения ключа из элемента.    
<T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier)  
В groupingBy есть конструкторы с двумя аргументами. В каждой группе можн оподсчитать любую агрегатную функцию:    
  
**Метод Collectors.counting** применяется в Collectors.groupingBy() для вычисления количества элементов в каждой группе:
Map<String, Long> phonesByCompany = phoneStream.collect(Collectors.groupingBy(Phone::getCompany, Collectors.counting()));  

Метод **Collectors.summing** применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, 
он имеет следующие формы: summingInt(), summingLong(), summingDouble().  
phoneStream.collect(Collectors.groupingBy(Phone::getCompany, Collectors.summingInt(Phone::getPrice)));  

**Методы maxBy и minBy** применяются для подсчета минимального и максимального значения в каждой группе.   
 
**Метод mapping** - Если нужно в листе получить преобразованные объекты или поле объкта вместо объекта, или если хотим получить не лист, а сет итд  
Позволяет дополнительно обработать данные и задать функцию отображения объектов из потока на какой-нибудь другой тип данных.  
Map<String, List<String>> phonesByCompany = phoneStream.collect(
Collectors.groupingBy(Phone::getCompany, Collectors.mapping(Phone::getName, Collectors.toList()))); //см \src\...\stream\DemoStream.java  
 
8) joining - объединить в одну строку. 
9) mapping	дополнительные преобразования значений для сложных Collector'ов  

Cогласно терминологии потокового прикладного интерфейса API метод collect() выполняет операцию, называемую изменяемым
сведением. Дело в том, что в результате сведения получается изменяемый объект хранения, например коллекция.  

+ Collectors.toCollection(Supplier collectionFactory)  
Собирает элементы в заданную коллекцию. Если нужно конкретно указать, какой List, Set или другую коллекцию мы хотим использовать, то этот метод поможет.  
Set<Integer> set = Stream.of(1, 2, 3, 4, 5)  
    .collect(Collectors.toCollection(LinkedHashSet::new));  
      
+ Collectors.joining:       
Объединить все элементы в одну строку через разделитель: и обернуть тегами <b>… </b>	
strings.stream().  
collect(Collectors.joining(": ", "<b> ", " </b>"))  - вначале разделитель, потом префикс и постфикс. <b> a1: b2: c3: a1 </b>  

Примеры:
Arrays.asList(«a1», «b2», «c3», «a1»),
+ Получить сумму нечетных чисел	numbers.stream().collect(Collectors.summingInt(((p) -> p % 2 == 1? p: 0)))
+ Вычесть от каждого элемента 1 и получить среднее: numbers.stream().collect(Collectors.averagingInt((p) -> p — 1))  
+ Разделить числа на четные и нечетные: numbers.stream().collect(Collectors.partitioningBy((p) -> p % 2 == 0))
+ **Преобразовать в map, сгруппировав по первому символу строки: strings.stream().collect(Collectors.groupingBy((p) -> p.substring(0, 1)))  
{a=[a1, a1], b=[b2], c=[c3]}  
Возвращает мапу, в которой ключом является p.substring(0, 1), а значением лист значений с соответствующим ключом, 
т.е. значения у которых ключи совпадают попадают в один лист.**  

+ Преобразовать в map, где первый символ ключ, второй символ значение:  
strings.stream().distinct().collect(Collectors.toMap((p) -> p.substring(0, 1), (p) -> p.substring(1, 2))) {a=1, b=2, c=3}  

 
Collectors.toMap:   
Collector<T, ?, Map<K,U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) -  
стандартная форма, когда задаем только функцию получения ключа и значения из элемента стрима.  

Дополнительные формы:  
+ toMap (Function keyMapper, Function valueMapper, BinaryOperator mergeFunction)  
Аналогичен первой версии метода, только в случае, когда встречается два одинаковых ключа, позволяет объединить значения.  
Map<Integer, String> map4 = Stream.of(50, 55, 69, 20, 19, 52)  
    .collect(Collectors.toMap(  
        i -> i % 5,  
        i -> String.format("<%d>", i),  
        (a, b) -> String.join(", ", a, b)  
    ));  
// {0="<50>, <55>, <20>", 2="<52>", 4="<64>, <19>"}  
В данном случае, для чисел 50, 55 и 20, ключ одинаков и равен 0, поэтому значения накапливаются. Для 64 и 19 аналогично.  

+ toMap(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction, Supplier mapFactory)  
  Всё то же, только позволяет указывать, какой именно класс Map использовать.  
  Map<Integer, String> map5 = Stream.of(50, 55, 69, 20, 19, 52)  
      .collect(Collectors.toMap(  
          i -> i % 5,  
          i -> String.format("<%d>", i),  
          (a, b) -> String.join(", ", a, b),  
          LinkedHashMap::new  
      ));  
  // {0=<50>, <55>, <20>, 4=<69>, <19>, 2=<52>}
    
Пример:  
Объединить все строки коллекции:   
```java
String joinBuilder = strings.stream().collect(
   Collector.of(
                StringBuilder::new, // метод_инициализации_аккумулятора
                (b ,s) -> b.append(s).append(" , "), // метод_обработки_каждого_элемента,
                (b1, b2) -> b1.append(b2).append(" , "), // метод_соединения_двух_аккумуляторов
                StringBuilder::toString // метод_последней_обработки_аккумулятора
        )
);
```   
+ toArray - можно либо вызвать toArray() получить Object[], либо toArray(T[]::new) — получив массив типа T    

[оглавление](#stream)

##	Что делает метод findFirst?
Возвращает Optional, описывающий первый элемент из потока.
Returns an {@link Optional} describing the first element of this stream, or an empty {@code Optional} if the stream is empty. 
If the stream has no encounter order, then any element may be returned.  

[оглавление](#stream)  

##	Что такое Optional?
Optional - это класс оболочка, призванный помочь разработчикам в обработке NullPointerException. Ряд операций сведения в Stream Api, 
такие как min, max, reduce, findFirst, findAny возвращают объект Optional<T>. Этот объект фактически обертывает результат операции. 
Здесь Т обозначает тип сохраняемого значения. Следует иметь в виду, что экземпляр класса Optional может содержать значение типа Т или быть пустым. 
Метод ifPresent() позволяет также устранить некоторую избыточность кода, следующего вида:  
```java
person.ifPresent(System.out::println);  
     if(person != null) {  
    	System.out.println(person);  
     }  
Person personNew = person.orElse(new Person());
Person personNew = person != null ? person : new Person();
```
  
[оглавление](#stream) 

##  Перечислите методы Optional?  
public static <T> Optional<T> ofNullable(T value) {
    return value == null ? (Optional<T>) EMPTY
                         : new Optional<>(value);
}  
Returns an Optional describing the given value, if non-null, otherwise returns an empty Optional.


If a value is present, performs the given action with the value, otherwise does nothing.
public void ifPresent(Consumer<? super T> action) {
    if (value != null) {
        action.accept(value);
    }
}

If a value is present, returns the value, otherwise returns the result produced by the supplying function.
public T orElseGet(Supplier<? extends T> supplier) {
    return value != null ? value : supplier.get();
}

If a value is present, returns the value, otherwise throws NoSuchElementException.
public T orElseThrow();  

 
[оглавление](#stream)

##	Возможно ли прервать выполнение потока по аналогии с break?
В Java 9 можно использовать java takeWhile.  Этот метод позволяет получать поток данных до тех пор, пока он проходит фильтр. (возможно еще limit, похоже по смыслу)
Пример:
List.of(2, 4, 3, 4).stream()
        .takeWhile(v -> v % 2 == 0)
        .map(v -> String.format(" %s", v))
        .forEach(System.out::print);

Вывод: Когда поток обрабатывает 3 фильтр не проходит и потом завершается.  

[оглавление](#stream)

##	Возможно ли пропустить элемент потока по аналогии с continue?
Вместо этого можно использовать filter или return.

    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");

        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.

            System.out.println(str); // a c
        });
    }  
     
[оглавление](#stream)    
    
##  В каких случаях можно использовать var?	
Для чего используется ключевое слово var?  
Начиная с версии JDK 10, появилась возможность автоматически выводить тип локальной переменной из типа ее инициализатора, а не указывать его явно. 
Для поддержки этой новой возможности в язык Java был внедрен контекстно-зависимый идентификатор под именем зарезервированного типа данных var.

В каких случаях можно использовать var?    
+ var - может использоваться только в сочетании с данными. Т.е. нельзя, например, присвоить var - метод, возвращающий результат. 
+ Нельзя использовать var в полях.
+ В качестве инициализатора переменной нельзя употреблять пустое значение null. 
+ В качестве инициализатора переменных выводимого типа нельзя употреблять лямбда-выражения и ссылки на методы. 
+ Выведение типов локальных переменных нельзя применять при объявлении типа исключения, перехватываемого оператором catch.  
[подробнее](https://urvanov.ru/2015/09/16/lombok-val-%D0%B1%D0%B5%D1%81%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5-final-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5/)  

[оглавление](#stream)

/*Следует, однако, иметь в виду, что операция накопления (нампример в reduce и  collect) должна удовлетворять трем ограничениям. Она должна быть:
• без сохранения состояния;
• без вмешательства;
• ассоциативная.
Как пояснялось ранее, операция без сохранения состояния означает, что она опирается на сведения о состоянии. Следовательно, каждый элемент из потока данных обрабатывается отдельно. Операция без вмешательства означает, что источник данных не видоизменяется самой операцией. И наконец, операция должна быть ассоциативной. В данном случае понятие ассоциативная операция употребляется в его обычном для арифметики значении. Это означает, что если ассоциативный оператор применяется в последовательности операций, то не имеет никакого значения, какая именно пара операндов обрабатывается первой. Например, вычисление следующего выражения:
(10 * 2) * 7
дает такой же результат, как и вычисление приведенного ниже выражения.
10 * (2 * 7)*/