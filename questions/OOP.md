## Методы по умолчанию в иинтерфейсах  
Методы по умолчанию кладут конец классическому паттерну предоставления интерфейса и абстрактного класса,
который реализует все или почти все из его методов. Теперь вы можете просто реализовать методы в интерфейсе.  
Что произойдет, если точно такой же метод определен как метод по умолчанию в одном интерфейсе, 
а затем снова в качестве метода суперкласса или другого интерфейса?   
Языки типа Скала и C++ имеют сложные правила разрешения таких неоднозначностей. К счастью, правила в Java гораздо проще. Вот они:  

1.	Родительские классы выиграют. Если суперкласс предоставляет конкретный метод, методы по умолчанию с тем же именем и типами параметров просто игнорируются.  
2.	Интерфейсы сталкиваются. Если супер интерфейс предоставляет метод по умолчанию, а другой интерфейс поставляет метод 
с тем же именем и типами параметров (по умолчанию или нет), то вы должны разрешить конфликт путем переопределения этого метода.  
(если хотя бы у одного общего метода есть реализация по умолчанию, то также используем это правило, 
если у обоих методов нет реализации, мы делаем реализацию в классе и она будет реализацией обоих методов.)  

Давайте посмотрим на второе правило. Рассмотрим еще один интерфейс с методом getFirstName:  
```java
interface Naming {
default String getFirstName() { 
return getClass().getName() + "_" + hashCode();}
}
interface Person {
 String getFirstName(){
return "";
}
}

//Что произойдет, если вы создадите класс, реализующий оба? 

class Student implements Person, Naming {
//    ...
}
```  

Класс наследует две противоречивые версии метода getFirstName, предоставляемые интерфейсами Person и Naming.
Вместо выбора того или другого метода, компилятор Java сообщает об ошибке и оставляет программисту разрешение неоднозначности.
Просто предоставьте метод getFirstName в классе Student. В этом методе вы можете выбрать один из двух конфликтующих методов, как показано ниже:  

class Student implements Person, Naming {  
    public String getFirstName() { return Person.super.getFirstName(); }}      
super в этом случае, подразумевает вызов дефолтного метода, а не метода из суперкласса.  
(Person.super.getFirstName() - вызов дефолтного метода getFirstName() из интерфейса Person)  

При этом для выбранного метода останется его реализация, а второй метод по умолчанию будет переопределен в классе реализацией выбранного.  

Теперь предположим, что Naming интерфейс не содержит реализацию по умолчанию для getFirstName:  
```java
interface Naming { 
    String getFirstName();
}

```  
Может ли класс Student унаследовать метод по умолчанию из интерфейса Person? Это могло бы быть разумным, 
но проектировщики Java приняли решение в пользу единообразия. Это не имеет значения, как два интерфейсы конфликтуют. 
Если хотя бы один интерфейс обеспечивает реализацию, компилятор сообщает об ошибке, и программист должен устранить неоднозначность.    

Если ни один интерфейс не обеспечивает реализацию по умолчанию для общего метода, 
то мы находимся в пре-Java 8 ситуации и нет никакого конфликта. Класс просто реализует метод.
В этом случае у нас будет одна реализация для обоих интерфейсов, т.е:    

```java
public interface A {
    void getWord();
}

public interface B {
  void getWord();
}

public class DefaultMethod implements A, B {
    @Override
    public void getWord() {
        System.out.println("A");
    }

    public static void main(String[] args) {
        A a = new DefaultMethod();
        a.getWord();
        B b = new DefaultMethod();
        b.getWord();
    }
}

/* Вывод:
A
A */
```  

Мы только что обсудили конфликты имен между двумя интерфейсами. Теперь рассмотрим класс, расширяющий суперкласс и реализующий интерфейс, 
наследуя тот же метод от обоих. Например, предположим, что Person является классом и Student определяется как:

class Student extends Person implements Naming { ... }  
 

В этом случае только метод суперкласса имеет значение, и любой метод по умолчанию из интерфейса просто игнорируется. 
В нашем примере Student наследует метод getFirstName от Person, и нет никакой разницы, обеспечивает ли интерфейс Naming 
реализацию по умолчанию для getFirstName или нет. Это правило «класс побеждает» в действии. 
Правило «класс побеждает» обеспечивает совместимость с Java 7. Если вы добавляете методы по умолчанию к интерфейсу, 
это не имеет никакого влияния на код, который работал до того, как появились методы по умолчанию.  
 
**Но имейте в виду: вы не имеете права создавать метод по умолчанию, который переопределяет один из методов класса Object. 
Например, вы не можете определить метод по умолчанию для toString или equals, хотя это могло бы быть удобным для таких интерфейсов, как List. 
Как следствие правила о победе классов, такой метод никогда не может выиграть у Object.toString или Object.equals.**  

## Статические методы в интерфейсах  
[подробнее](https://javadevblog.com/interfejsy-v-java-8-staticheskie-metody-metody-po-umolchaniyu-funktsional-ny-e-interfejsy.html)  

Статические методы похожи на методы по умолчанию, за исключением того, что мы не можем переопределить их в классах, реализующих интерфейс. 
Этот функционал помогает нам избежать нежелательных результатов, которые могут появиться в дочерних классах.  
Статические методы видны только для методов интерфейса.  

Коротко о главном. Статические методы в интерфейсах  
+ Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации.
+ Статические методы в интерфейсе хороши для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.
+ Статические методы в интерфейсе помогают обеспечивать безопасность, не позволяя классам, которые реализуют интерфейс, переопределить их.
+ Мы не можем определить статические методы для методов класса Object, потому что получим ошибку компиляции: 
«This static method cannot hide the instance method from Object«. Это потому, что в Java так делать нельзя . 
То есть Object является базовым классом для всех классов и мы не можем использовать статический метод и еще такой метод с одинаковой сигнатурой.  
+ Мы можем использовать статические методы интерфейса, чтобы не создавать вспомогательные классы, 
то есть переместить все статические методы в соответствующий интерфейс. Такой метод легко использовать и быстро находить.      

