
## Двоичный код  
[подробнее](https://www.chaynikam.info/dvoichnoe-kodirovanie.html#text)  

Как осуществляется кодирование различных типов данных, рассмотрим немного ниже. Сначала давайте разберемся,   
из каких же символов формируется двоичный код внутри компьютера и как он там хранится.  

С технической стороны компьютерный двоичный код реализуется наличием или отсутствием определенных свойств (импульсов) 
у мельчайших запоминающих элементов. Эти импульсы могут быть:  

• фотооптическимиБинарная дорожка CD  
Так, поверхность любого оптического диска (CD, DVD или BluRay) состоит из спирали, которую формируют мелкие отрезки.
Каждый из них может быть либо темного, либо светлого цвета. Диск быстро вращается в дисководе. 
На его спиральной дорожке фокусируется лазер, отражение которого попадает на фотоэлемент. 
Темные участки спирали поглощают свет и не передают его на фотоэлемент, светлые – наоборот, отражая свет, передают импульс фотоэлементу. 
В результате фотоэлемент получает информацию, зашифрованную в дорожке диска в виде темных и светлых точек.  

• магнитными  
Например, внутри жесткого диска находится быстро вращающаяся пластина. Вся ее поверхность тоже представляет собой спираль, 
состоящую из последовательности миллионов мелких участков. Каждый из них является элементом, который может принимать одно из двух состояний: 
"намагниченное", "ненамагниченное". Эти элементы и формируют двоичный код, в котором кодируется какая-то информация. 
Считывание состояния элементов осуществляется специальной головкой, которая быстро движется по поверхности пластины;  

• электрическими
Например, оперативная память компьютера является микросхемой, состоящей из миллионов маленьких ячеек, 
созданных из микроскопических транзисторов и конденсаторов. Каждая такая ячейка может либо содержать электрический заряд, либо нет. 
Комбинации заряженных и разряженных ячеек оперативной памяти и формируют в ней двоичный код.  
В аналогичной форме информация хранится и во всех других запоминающих микросхемах (флешки, SSD-носители и др.).  

Процессор компьютера обрабатывает двоичный код тоже в виде электрических импульсов.  

Иногда можно встретить ошибочное мнение, что бинарный код внутри компьютера записан в виде обычных нулей и единиц. 
Это следствие непонимания технической стороны вопроса. Привычных для нас нулей и единиц в компьютере нет. 
"Символами" компьютерного двоичного кода является наличие или отсутствие у мельчайшего запоминающего элемента определенного свойства (см. выше).
Чтобы было нагляднее, в учебных материалах отсутствие у элемента такого свойства лишь условно обозначают нулем, а его наличие – единицей. 
Но с таким же успехом их можно бы было обозначать точкой и тире или крестиком и ноликом.   

## О сети  
[подробнее](https://javarush.ru/groups/posts/2514-vvedenie-v-enterprise-razrabotku)  
Когда мы переходим, скажем, в интернет-магазин, мы указываем его адрес нахождения и порт. При первом посещении создается сессия, 
в которую магазин может записывать информацию. Например, о товарах, которые мы оставили в корзине. 
Если мы закроем вкладку с интернет-магазином, а потом опять зайдем в него, наши товары останутся в корзине,
потому что они сохранены в сессии. Ну и, естественно, всю информацию, которую мы получаем от магазина, 
мы получаем по протоколу HTTP/HTTPS, а наш браузер умеет его обрабатывать.  

## Протоколы HTTP  
[подробнее](https://www.youtube.com/watch?v=C_QZtajkDf0&t=196s&ab_channel=letsCode)  
[подробнее](https://ru.wikipedia.org/wiki/HTTP)  

HTTP и HTTPS - протоколы передачи данных по сети на прикладном уровне модели OSI.  
**Протокол передачи данных - общепринятое соглашение, благодаря которому разработчики разных сервисов 
отправляют информацию в едином виде.**  

Например, используя Google Chrome, ты можешь получить информацию и с Facebook, и с Twitter, 
потому что разработчики передают ее с помощью стандартного протокола HTTP, а твой браузер умеет его обрабатывать.  

HTTP протокол – это соглашение о формате текстовых файлов, которые ходят между сервером и клиентом. Изначально передавались 
гипертекстовые файлы HTML, сейчас любые произвольные данные.  
(заголовки, статусы запроса, методы get, post, put итд прописаны внутри этого файла)   

Content-type передается, чтобы сервер сразу знал, какой формат придет и использовал подходящий парсер.
Если мы хотим отправить звуки или картинки, то они просто отправляются в двоичном виде, а в Content-type указывается их тип (image/jpeg).  

Методы:  
OPTIONS  
Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. 
В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов.
Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы «OPTIONS * HTTP/1.1  

GET  
Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. 
В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:  
GET /path/resource?param1=value1&param2=value2 HTTP/1.1  

Пример:  
```java
class HttpGet {
  public static void main(String args[]) throws Exception { 
    int c; 
 
    // Create a socket connected to httpbin.org, port 80.
    Socket s = new Socket("httpbin.org", 80);
 
    // Obtain input and output streams. 
    InputStream in = s.getInputStream(); //поток ввода
    OutputStream out = s.getOutputStream(); //поток вывода
 
    // Construct a request string. 
    String str = "GET / HTTP/1.1\n" +
            "Host: httpbin.org\n\n"; // 2 перевода строки, значит, что запрос окончен! и сервер может отвечать
    // Convert to bytes. 
    byte buf[] = str.getBytes(); 
 
    // Send request. 
    out.write(buf); 
 
    // Read and display response. 
    while ((c = in.read()) != -1) { 
      System.out.print((char) c); 
    } 
    s.close(); 
  } 
}
```  
Подключаемся к серверу, отправаляем get - запрос, получаем ответ. (чтобы посмотреть ответ запустить src\main\java\io\Http.java  

Post-запрос:  
Post /post HTTP/1.1  //второй post - это просто такой юрл
Host: httpbin.org  
Connection: close  
Content-type: application/json  
Content-lenght: 14

{"text":true} //13 символов + перевод строки = 14         

Если мы указали Content-lenght, то сервер после двух переводов строки ожидает указанное кол-во символов, а потом начианет отвечать  

## Response Status Codes  
С телом сообщения и заголовками все ясно, а о кодах статусов стоит сказать пару слов. Response Status Codes всегда трехзначные, 
и первая цифра кода указывает категорию ответа:  
1xx — информационный. Запрос получен, сервер готов к продолжению;  
2xx — успешный. Запрос получен, понятен и обработан;  
3xx — перенаправление. Следующие действия нужно выполнить для обработки запроса;  
4xx — ошибка клиента. Запрос содержит ошибки или не отвечает протоколу;  
5xx — ошибка сервера. Сервер не смог обработать запрос, хотя был составлен верно;  
Вторая и третья цифры в коде детализируют ответ.   

Например:  
200 OK — реквест получен и успешно обработан;  
201 Created — реквест получен и успешно обработан, в результате чего создан новый ресурс или его экземпляр;  
301 Moved Permanently — запрашиваемый ресурс был перемещен навсегда, и последующие запросы к нему должны происходить по новому адресу;  
307 Temporary Redirect — ресурс перемещен временно. Пока к нему можно обращаться, используя автоматическую переадресацию;  
403 Forbidden — запрос понятен, но нужна авторизация;  
404 Not Found — сервер не нашел ресурс по этому адресу;  
501 Not Implemented — сервер не поддерживает функциональность для ответа на этот запрос;  
505 HTTP Version Not Supported — сервер не поддерживает указанную версию HTTP-протокола.  
Вдобавок к статус-коду ответа также отправляется описание статуса, благодаря которому интуитивно понятно, что значит конкретный статус.  

## HTTPS  
https://yandex.ru/blog/company/77455  
Защиту данных в HTTPS обеспечивает криптографический протокол SSL/TLS, который шифрует передаваемую информацию. 
По сути этот протокол является обёрткой для HTTP. Он обеспечивает шифрование данных и делает их недоступными для просмотра посторонними. 
Протокол SSL/TLS хорош тем, что позволяет двум незнакомым между собой участникам сети установить защищённое соединение через незащищённый канал.  

Как работает безопасное соединение
Представьте, что вы хотите передать какую-то вещь другому человеку. Вы кладёте её в ящик и отправляете по почте. 
А чтобы курьер — или кто угодно другой — не украл её, вы запираете ящик на замок.
Курьер доставляет ящик, но ваш адресат не может его открыть — у него нет ключа. Тогда он вешает на ящик свой замок и отправляет обратно вам. 
Вы получаете ящик под двумя замками, снимаете свой — теперь это безопасно — и отправляете снова. 
Адресат получает, наконец, ящик, на котором висит только его замок, открывает его и достаёт то, что вы ему послали.  

В ящике вы послали ему ключ от шифра, и теперь он известен вам обоим. Теперь вы можете открыто обмениваться зашифрованными сообщениями, 
не опасаясь, что их кто-то перехватит — всё равно их невозможно понять без ключа.  

На похожем принципе основана работа протокола SSL/TLS. При установке безопасного соединения по HTTPS ваш компьютер и сервер сначала выбирают общий секретный ключ, 
а затем обмениваются информацией, шифруя её с помощью этого ключа. Общий секретный ключ генерируется заново для каждого сеанса связи.
Его нельзя перехватить и практически невозможно подобрать — обычно это число длиной более 100 знаков. 
Этот одноразовый секретный ключ и используется для шифрования всего общения браузера и сервера.  

##  Прокси-сервер
[подробнее](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80)  
Прокси-сервер (от англ. proxy — представитель, уполномоченный; часто просто прокси, сервер-посредник) — промежуточный сервер (комплекс программ) в компьютерных сетях, 
выполняющий роль посредника между пользователем и целевым сервером (при этом о посредничестве могут как знать, так и не знать обе стороны), 
позволяющий клиентам как выполнять косвенные запросы (принимая и передавая их через прокси-сервер) к другим сетевым службам, так и получать ответы. 
Сначала клиент подключается к прокси-серверу и запрашивает какой-либо ресурс (например e-mail), расположенный на другом сервере. 
Затем прокси-сервер либо подключается к указанному серверу и получает ресурс у него, либо возвращает ресурс из собственного кэша (в случаях, если прокси имеет свой кэш). 
В некоторых случаях запрос клиента или ответ сервера может быть изменён прокси-сервером в определённых целях. 
Прокси-сервер позволяет защищать компьютер клиента от некоторых сетевых атак и помогает сохранять анонимность клиента, 
но также может использоваться мошенниками для скрытия адреса сайта, уличённого в мошенничестве, изменения содержимого целевого сайта (подмена), 
а также перехвата запросов самого пользователя.  

## Rest vs Soap  

1.  У Rest запросы атомарные, в то время как Soap хранит исчерпывающую информацию о запросах и требует сохранения длительной сессии 
между клиентом и сервером.  
2. В  Rest сервер - stateless, т.е. не хранит состояние, инф-ию о клиенте. Сервер не должен знать о клиенте, все состояние 
должно храниться на клиенте.   
3. Вся информация, необходимая серверу, должна приходить вместе с запросом.  
4. Клиент может кешировать ответы с сервера, чтоыб не запрашивать их несколько раз. 
5. Клиент знает об интерфейсе сервера, но не знает о его реализациях.    
  

Методы используемые в запросах:  
+ Post - обычно используется дял доабвления информации, но может также использовать для получения данных, когда нужн опередать много аргументов.  
+ Put - обновляет уже существующие данные
+ Patch -  обновляет уже существующие данные, но при этом идентификатор объекта меняется.  

## Dto  
Мы отдельно создавали DTO - data transfer objects, чтобы отдавать на фронт только необходимые поля, а не все поля сгенерированного pojo.  
```java
@Data
@JsonIgnoreProperties(ignoreUnknown = true) //игнорирование лишних полей, приходящих с фронта
public abstract class RoomDto implements Serializable {
    private Integer idd;
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm")
    private LocalDateTime createDate;
}
```

@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm")  
private LocalDateTime createDate;  - Получаем на рфонте целое число, преобразуем к нужнмоу формату  

## Мапперы  
ModelMapper:  
```xml
<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>2.3.8</version>
</dependency>
``` 

В спринге есть ModelMapper, который можно использоватьследующим образом:  
ModelMapper mapper = new ModelMapper();  
mapper.map(object, Result.class);  
Значения будут мапится по одинаковым названиям. Плюс маппер маппит вложенные структуры.  

## Reflection  
http://java-online.ru/java-reflection.xhtml    


  
