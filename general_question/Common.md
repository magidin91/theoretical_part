## Common questions  

+ [Как работает статическая типизация в Java](#Как-работает-статическая-типизация-в-Java)
+ [Потоки, создающиеся при старте программы по умолчанию](#Потоки-создающиеся-при-старте-программы-по-умолчанию)

## Как работает статическая типизация в Java  

+ Статическая типизация — проверка безопасности типов программы на этапе компиляции
 (путем анализа исходного кода программы).
+ Динамическая типизация — проверка безопасности типов программы во время ее выполнения.  

Java использует статическую проверку типов, то есть анализ программы во время ее компиляции.
Основная идея выбора такого подхода проверки типов состоит в том, чтобы проверять типы только 1 раз при компиляции,
тем самым повышая скорость выполнения программы. Также это позволяет обнаруживать возможные ошибки.  
Статическая типизация в Java  

Давайте рассмотрим простой пример статической типизации в Java. Есть два класса: Alpha и Beta с методами, которые что-то делают:

```java
class Alfa {
	Alfa getThis() {
		return this;
	}
 
	public void doAlfa() {
		System.out.println("что-то делаем в Alfa");
	}
}
 
class Beta extends Alfa {
	public void doBeta() {
		System.out.println("что-то делаем в Beta");
	}
}

class Omega extends Alfa{
	public void doOmega() {
		System.out.println("что-то делаем с Omega");
	}
}
```
Примеры:  
+ new Beta().getThis()? - работает, т.к. B - наследник А (кастинг вверх) 
+ new Beta().getThis().doBeta(); - ошибка компиляции  
Проблема заключается в том, что ее исходный тип Аlfa и компилятор не знает реальный тип во время компиляции, 
поэтому он видит объект типа Аlfa. Исходя из этого нам не доступен метод doBeta().
+ ((Beta) new Beta().getThis()).doBeta(); - обошли проблему с помощью приведения типов к Beta:
+ ((Omega) new Beta().getThis()).doOmega(); - ройдет статическую компиляцию, т.к. альфа можно привести к омега, но упадет во время выполнения    
Так написать можно и это даже пройдет статическую проверку типов (по той же причине, что и с new Beta().getThis().doBeta();), 
однако во время выполнения будет брошено исключение «java.lang.ClassCastException:
Beta cannot be cast to Omega«, так как Beta не может быть приведена к Omega.  

[подробнее](https://javadevblog.com/kak-rabotaet-staticheskaya-tipizatsiya-v-java.html)  

[к оглавлению](#Common-questions)  

## Потоки, создающиеся при старте программы по умолчанию  
Список всех потоков можн ополучить в дебаггере или любом профайлере типа jСonsole    
+ main  
"Основной" поток - это поток, созданный для запуска вашего main метода.
+ Attach Listener  
"Слушатель присоединения" создается JVM для приема соединений с агентом отладки JVM.
+ Common Cleaner  
Поток "Common Cleaner" относится к механизму Cleaner, который является лучшим способом для удаления объектов при удалении объектов.
(связанс фантомными ссылками)  
Можно добавить действие (по очистке ресурсов объекта) перед удалением.
+ Finalizer  
Поток "Finalizer" запускает методы finalize для недоступных объектов, поставленных в очередь потоком GC.
+ Reference Handler  
Поток "Reference Handler" выполняет обработку объектов Reference поставленных в очередь GC. 
+ Signal Dispatcher  
Поток "Диспетчер сигналов" обрабатывает собственные сигналы (например, SIGINT, SIGHUP и т.д.).
По-видимому, они должны обрабатываться выделенным (собственным) потоком из-за того, как работают связанные системные вызовы.  

В JVM также есть один или несколько собственных потоков GC, но, очевидно, они не отображаются в списке. 
Я предполагаю, что это потому, что у них нет соответствующего объекта Thread. (Они... особенные!)