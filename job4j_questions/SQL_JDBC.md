## SQL, Jdbc  

прочитать этот туториал при возможности - [sql-туториал](http://www.sql-tutorial.ru/ru/content.html)         

**SQL:**  
+ [Общее](#Общее)
+ [CREATE](#CREATE) 
+ [INSERT](#INSERT) 
+ [SELECT](#SELECT) 
+ [Alter](#Alter)
+ [UPDATE/DELETE ](#UPDATE-DELETE )
+ [Команды PostgreSQL](#Команды-PostgreSQL)
+ [Ограничения столбцов и таблиц](#Ограничения-столбцов-и-таблиц)
+ [Что такое первичный ключ?](#Что-такое-первичный-ключ)
+ [Что такое внешний ключ?](#Что-такое-внешний-ключ)
+ [Что такое нормализация БД?](#Что-такое-нормализация-БД)
+ [Что такое денормализация БД?](#Что-такое-денормализация-БД)
+ [Что такое кластерный и некластерный индекс?](#Что-такое-кластерный-и-некластерный-индекс) 
+ [Что такое SQL курсор?](#Что-такое-SQL-курсор)  
+ [Опишите шаги по созданию и использованию курсора?](#Опишите-шаги-по-созданию-и-использованию-курсора) 
+ [Что такое подзапрос (sub-query)?](#Что-такое-подзапрос)
+ [Какие типы соединений (join) таблиц существуют? В чем их разница?](#Какие-типы-соединений-(join)-таблиц-существуют-В-чем-их-разница)
+ [Что такое group by](#Что-такое-group-by)
+ [Что такое HAVING? Разница с Where?](#Что-такое-HAVING-Разница-с-Where)  
+ [Составные типы данных](#Составные-типы-данных)
+ [Множества: Union, EXCEPT, INTERSECT](#Множества-Union-EXCEPT-INTERSECT)
+ [Что такое транзакция?](#Что-такое-транзакция)
+ [Требования ACID к СУБД](#Требования-ACID-к-СУБД)   
+ [Что такое хранимые процедуры?](#Что-такое-хранимые-процедуры)
+ [Что такое триггер? (Какие типы триггеров вы знаете?)](#Что-такое-триггер-Какие-типы-триггеров-вы-знаете))  
+ [Что такое view](#Что-такое-view)
+ [Для чего используется конструкция try-with-resources](#Для-чего-используется-конструкция-try-with-resources)
+ [Дополнительно](#Дополнительно)  

**JDBC:** 
+ [Опишите процесс создания запроса через JDBC](#Опишите-процесс-создания-запроса-через-JDBC)  
 + [ANSI SQL](#ANSI-SQL)
 + [Основные элементы баз данных – таблицы, процедуры, функции, констрейнты и т.д..](#Основные-элементы-баз-данных-–-таблицы-процедуры-функции-констрейнты-и-тд)
 + [Как вы понимаете null в базах данных?](#Как-вы-понимаете-null-в-базах-данных)
 + [Агрегатные функции, как они работают с null. Не забудьте о group by и having](#Агрегатные-функции-как-они-работают-с-null-Не-забудьте-о-group-by-и-having)
 + [Каким образом лучше добавлять большое количество записей в таблицу?](#Каким-образом-лучше-добавлять-большое-количество-записей-в-таблицу)
 + [Что такое первая нормальная форма и процесс нормализации? Какие бывают нормальные формы?](#Что-такое-первая-нормальная-форма-и-процесс-нормализации-Какие-бывают-нормальные-формы)
 + [В чем смысл индекса СУБД, как они устроены, как хранятся? Как бы вы реализовали тот же функционал?](#В-чем-смысл-индекса-СУБД-как-они-устроены-как-хранятся-Как-бы-вы-реализовали-тот-же-функционал)
 + [Что такое JDBC API и когда его используют?](#Что-такое-JDBC-API-и-когда-его-используют)
 + [Что такое JDBC Driver и какие различные типы драйверов JDBC вы знаете?](#Что-такое-JDBC-Driver-и-какие-различные-типы-драйверов-JDBC-вы-знаете)
 + [Как JDBC API помогает достичь слабой связи между Java программой и JDBC Drivers API?](#Как-JDBC-API-помогает-достичь-слабой-связи-между-Java-программой-и-JDBC-Drivers-API)
 + [Что такое JDBC Connection? Покажите шаги для подключения программы к базе данных.](#Что-такое-JDBC-Connection-Покажите-шаги-для-подключения-программы-к-базе-данных)
 + [Как используется JDBC DriverManager class?](#Как-используется-JDBC-DriverManager-class)
 + [Как получить информацию о сервере базы данных из java программы?](#Как-получить-информацию-о-сервере-базы-данных-из-java-программы)
 + [Что такое JDBC Statement?](#Что-такое-JDBC-Statement)
 + [Какие различия между execute, executeQuery, executeUpdate?](#Какие-различия-между-execute-executeQuery-executeUpdate)
 + [Что такое JDBC PreparedStatement?](#Что-такое-JDBC-PreparedStatement)
 + [Как установить NULL значения в JDBC PreparedStatement?](#Как-установить-NULL-значения-в-JDBC-PreparedStatement)
 + [Как используется метод getGeneratedKeys в Statement?](#Как-используется-метод-getGeneratedKeys-в-Statement)
 + [Какие преимущества в использовании PreparedStatement над Statement?](#Какие-преимущества-в-использовании-PreparedStatement-над-Statement)
 + [Какие есть ограничения PreparedStatement и как их преодолеть?](#Какие-есть-ограничения-PreparedStatement-и-как-их-преодолеть)
 + [Что такое JDBC ResultSet?](#Что-такое-JDBC-ResultSet)
 + [Какие существуют различные типы JDBC ResultSet?](#Какие-существуют-различные-типы-JDBC-ResultSet)
 + [Как используются методы setFetchSize и SetMaxRows в Statement?](#Как-используются-методы-setFetchSize-и-SetMaxRows-в-Statement)
 + [Как вызвать Stored Procedures используя JDBC API?](#Как-вызвать-Stored-Procedures-используя-JDBC-API)
 + [Что такое JDBC Batch Processing и каковы его преимущества?](#Что-такое-JDBC-Batch-Processing-и-каковы-его-преимущества)
 + [Что такое JDBC Transaction Management и зачем он нужен?](#Что-такое-JDBC-Transaction-Management-и-зачем-он-нужен)
 + [Как откатить JDBC транзакцию?](#Как-откатить-JDBC-транзакцию)
 + [Что такое JDBC Savepoint и как он используется?](#Что-такое-JDBC-Savepoint-и-как-он-используется)
 + [Расскажите о JDBC DataSource. Какие преимущества он дает?](#Расскажите-о-JDBC-DataSource-Какие-преимущества-он-дает)
 + [Расскажите про Apache DBCP API.](#Расскажите-про-Apache-DBCP-API)
 + [Какие вы знаете уровни изоляции соединений в JDBC?](#Какие-вы-знаете-уровни-изоляции-соединений-в-JDBC)
 + [Что вы знаете о JDBC RowSet? Какие существуют различные типы RowSet?](#33-Что-вы-знаете-о-JDBC-RowSet-Какие-существуют-различные-типы-RowSet)
 + [В чем разница между ResultSet и RowSet?](#В-чем-разница-между-ResultSet-и-RowSet)
 + [Приведите пример наиболее распространенных исключений в JDBC.](#Приведите-пример-наиболее-распространенных-исключений-в-JDBC)
 + [Расскажите о типах данных CLOB и BLOB в JDBC.](#Расскажите-о-типах-данных-CLOB-и-BLOB-в-JDBC)
 + [Что вы знаете о «грязном чтении» dirty read в JDBC? Какой уровень изоляции предотвращает этот тип чтения?](#Что-вы-знаете-о-«грязном-чтении»-dirty-read-в-JDBC-Какой-уровень-изоляции-предотвращает-этот-тип-чтения)
 + [Какие есть две фазы commit?](#Какие-есть-две-фазы-commit)
 + [Приведите пример различных типов блокировки в JDBC.](#Приведите-пример-различных-типов-блокировки-в-JDBC)
 + [Как вы понимаете DDL и DML выражения?](#Как-вы-понимаете-DDL-и-DML-выражения)
 + [Какая разница между java.util.Date и java.sql.Date?](#Какая-разница-между-javautilDate-и-javasqlDate)
 + [Как вставить изображение или необработанные данные в базу данных?](#Как-вставить-изображение-или-необработанные-данные-в-базу-данных)
 + [Что вы можете рассказать о фантомном чтении? Какой уровень изоляции его предотвращает?](#Что-вы-можете-рассказать-о-фантомном-чтении-Какой-уровень-изоляции-его-предотвращает)
 + [Что такое SQL Warning? Как возвратить SQL предупреждения в JDBC программе?](#Что-такое-SQL-Warning-Как-возвратить-SQL-предупреждения-в-JDBC-программе)
 + [Как запустить Oracle Stored Procedure с объектами базы данных INOUT?](#Как-запустить-Oracle-Stored-Procedure-с-объектами-базы-данных-INOUT)
 + [Приведите пример возникновения java.sql.SQLException: No suitable driver found.](#Приведите-пример-возникновения-javasqlSQLException:-No-suitable-driver-found)
 + [Best Practices в JDBC.](#Best-Practices-в-JDBC)  
 
## SQL

## Общее:  
Реляционные базы хранят данные в таблицах, в которых строки соответствуют записям, а колонки полям.  
  
**Типы данных:**   
+ dec - хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков в дробной части.
То же самое, что и numeric. Данный тип может принимать два параметра precision и scale: numeric(precision, scale).
Параметр precision указывает на максимальное количество цифр, которые может хранить число.
Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой.   
Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.    
+ real: хранит числа с плавающей точкой из диапазона от 1E-37 до 1E+37. Занимает 4 байта. Имеет псевдоним float4.  
+ double precision: хранит числа с плавающей точкой из диапазона от 1E-307 до 1E+308. Занимает 8 байт. Имеет псевдоним float8.  
+ Тип boolean может хранить одно из двух значений: true или false.      

[к оглавлению](#SQL-Jdbc)       

## CREATE     
Создание таблицы с Внешним ключом:  
**CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER, Quantity INTEGER, FOREIGN KEY (CustomerId) REFERENCES Customers (Id));**     
или  
**CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER REFERENCES Customers (Id), Quantity INTEGER);**
 
Создать таблицу на основании указанных столбцов другой таблицы:  
create table people_new as Select name, age, passport from people; (Не только создает структуру, но и копирует данные)  

Значение по умолчанию в столбце таблицы:        
**CREATE TABLE shop_goods (id serial primary key, cost DEC(3,2) NOT NULL DEFAULT 1.00);** 
cost - Этот столбец ВСЕГДА должен содержать значение. Для этого мы не только объявляем его с ключевыми словами NOT NULL, но и присваиваем значение по умолчанию 1.00     

[к оглавлению](#SQL-Jdbc)    

## INSERT  
**INSERT into students values (1, 'Ivan', '2009-06-04'), (2, 'Petr', '2009-06-04');**  
  
+ Можно указать конкретные столбцы:    
**INSERT into students (name, birth_date) values ('Ivan', '2009-06-04'), ('Petr', '2009-06-04');**
  
+ INSERT с SELECT    
INSERT INTO profession (profession)  SELECT  profession  FROM  my_contacts;  
Т.е. мы вставляем записи из столбца profession таблицы my_contacts в столбец profession таблицы profession.  
    
+ ON CONFLICT DO NOTHING    
Если, например, поле name задано Unique, то при обычной вставке дублирующего значения, произойдет ошибка.
Чтобы этого избежать можно использовать условие ON CONFLICT DO NOTHING/UPDATE. В этом случае вставка не произойдет, 
но и не будет выдано никакое сообщение об ошибке.    
Конструкция DO UPDATE SET обновляет поля, которые в ней указаны.      
**INSERT INTO account (id, name, surname, address) VALUES (1, 'Петя', 'Петров', 'Москва, Кремль') 
ON CONFLICT (id) DO UPDATE SET name='Петя', surname='Петров';**  

При вставке можно посмотреть значения тех столбцов, которые мы не указываем при вставке, например первичного ключа. 
insert into students (name, birth_date) values ('Ivan', '2009-06-04') RETURNING id;   
[подробнее](https://habr.com/ru/post/264281/)  

[к оглавлению](#SQL-Jdbc)    
  
##  SELECT    
##  Where (AND, OR, <>,<=, IS NULL, LIKE+ % и _ , BETWEEN, IN, NOT IN)      
Для фильтрации данных применяется оператор WHERE, после которого указывается условие, на основании которого производится фильтрация.     
  
**AND, OR, NOT**    
**SELECT * FROM Products WHERE Manufacturer = 'Samsung' AND Price > 50000;**      
**NOT** - выберем все товары, у которых производитель не Samsung:      
**SELECT * FROM Products WHERE NOT Manufacturer = 'Samsung';**    
Но в большинстве случаев можно обойтись без оператора NOT. Предыдущий пример мы можем переписать:    
**SELECT * FROM Products WHERE Manufacturer <> 'Samsung'**  
Также в одной команде SELECT можно использовать сразу несколько операторов:
SELECT * FROM Products WHERE Manufacturer = 'Samsung' OR Price > 30000 AND ProductCount > 2;  
Так как **оператор AND имеет более высокий приоритет**, то сначала будет выполняться 
подвыражение Price > 30000 AND ProductCount > 2, и только потом оператор OR. (То есть здесь выбираются товары, 
которыех на складе больше 2 и у которых одновременно цена больше 30000, либо те товары, производителем которых является Samsung)    
С помощью скобок мы также можем переопределить порядок операций:  
**SELECT * FROM Products WHERE (Manufacturer = 'Samsung' OR Price > 30000) AND ProductCount > 2;**    

**IS NULL**        
Если необходимо получить строки, у которых поле ProductCount не равно NULL, то можно использовать оператор NOT:  
SELECT * FROM Products WHERE ProductCount IS NOT NULL;  
[подробнее](https://metanit.com/sql/postgresql/3.3.php)  

**Операторы сравнения при поиске текстовых данных:** 
**LIKE**       
Ключевое слово LIKE, в сочетании со специальными символами ищет часть текстовой строки и возвращает совпадения.  
**SELECT * FROM my_contacts Where location LIKE '%CA’;**    
**Знак %** говорит, что мы ищем все значения локэйшен, которые заканчиваются на СА. Знак % — обозначает любое количество произвольных символов.
Также можно использовать %часть слова%, если ищем часть в середине слова.    
**Знак подчеркивания (_)** — представляет ровно один произвольный символ.  
**SELECT first_name FROM my_contacts Where first_name LIKE '_им';**  
Запрос возвращает имена, которые со стоят из одной буквы + ≪иМ≫: KиM,  ТиМ и т.д.     

**Проверка вхождения значений в диапазон**      
Обычный вариант:    
**SELECT drink_name FROM drink_info WHERE calories>= 30  AND calories<= 60;**    
**BETWEEN**  
Конструкция BETWEEN эквивалентна использованию операторов <= и >=, но не < и >.  
**SELECT drink_name FROM drink_info WHERE calories BETWEEN 30 AND 60;** - [30, 60]    
**SELECT drink_name FROM drink_info WHERE drink_name BETWEEN 'Д ' AND 'O';**    
Запрос возвращает названия всех напитков, начинающихся с Д, заканчивающихс О и всех букв между ними.  

**IN (совпадает со значением из набора)**     
После IN следует набор значений в круглых скобках.     
**SELECT date_name FROM black_book WHERE rating IN ('оригинально', 'потрясающе', 'неплохо');**  
NOT IN (не входит в набор значений)    
**SELECT date_name FROM black_book WHERE rating NOT IN ('оридтинально', 'потрясающе', ’неплохо’);**   

**Другие применения NOT**    
Ключевое слово NOT может использоваться не только с IN, но и с BETWEEN и LIKE. Однако необходимо помнить, что NOT следует сразу же после WHERE.    
SELECT drink_name FROM drink_info WHERE NOT carbs BETWEEN 3 AND 5;  
Если ключевое слово Not используется с And или Or, оно записывается после And или Or.  
SELECT date_name FROM black_book WHERE date_name LIKE 'A%' and NOT date name LIKE 'E%';  

**Получение части строки:**      
**Right, Left**    
Для выделения заданного количества символов в столбце используются функции RIGHT() и LEFT();    
**SELECT RIGHT (location , 2) FROM my_contacts;**    
Функция выделяет два последних символа из столбца location;   
**SUBSTRING**  
Функция SUBSTRING(выражение, начальная позиция, длина) позволяет извлечь из выражения его часть заданной длины, 
начиная от заданной начальной позиции. Выражение может быть символьной или бинарной строкой, а также иметь тип text или image.  
Например, если нам потребуется получить три символа в названии корабля, начиная со второго символа:
**SELECT name, SUBSTRING(name, 2, 3) FROM Ships;** (выведет столбец SUBSTRING)  
**SUBSTR**    
Команда SUBSTR (interests , LENGTH (interest1) +2) возвращает часть строки interest1, отрезав от нее левую часть указанной длины.
**UPDATE my_contacts SET interests = SUBSTR (interest, LENGTH (interest1)+2);**    

**AS**    
С помощью оператора AS можно изменить название выходного столбца или определить его псевдоним:  
SELECT ProductCount AS Title, Manufacturer, Price * ProductCount  AS TotalSum FROM Products;  

**Limit и offset**    
Выбрать **limit** записей, начиная с **(offset+1)**-ой:  
**SELECT* FROM students LIMIT 10 OFFSET 14;** (получим 10 записей, начиная с 15-ой)  
offset - это смещение, т.е. чтобы получить вторую запись, а не первую  offset = 1  

**Distinct, Count:**
**DICTINCT**  
Оператор DISTINCT позволяет выбрать уникальные данные по определенному столбцу.  
SELECT DISTINCT Manufacturer FROM Products;  
  
**Агрегатные функции**  
Агрегатные функции вычисляют одно значение над некоторым набором строк. Агрегатные функции: AVG, COUNT(*), SUM, MIN, MAX.  
+ COUNT(expression): находит количество строк в запросе, для которых expression не содержит значение NULL.  
Вторая форма функции COUNT(*) возвращает количество строк, при этом строки со значениями NULL игнорируются.
+ STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку.  
  
Если в наборе нет строк, то все агрегатные функции за исключением COUNT(*) возвращают значение NULL.    
SELECT COUNT(DISTINCT Company) FROM Products; [подробнее](https://metanit.com/sql/postgresql/4.1.php)         

[к оглавлению](#SQL-Jdbc)  

## Alter
**Добавление нового столбца**  
ALTER TABLE Customers ADD Phone CHARACTER VARYING(20);  
**Удаление столбца**    
ALTER TABLE Customers DROP COLUMN Address;    
**Изменение типа столбца** 
Для изменения типа применяется ключевое слово TYPE.  
ALTER TABLE Customers ALTER COLUMN FirstName TYPE VARCHAR(50);  
**Изменение ограничений столбца**  
Для добавления ограничения применяется оператор SET, после которого указывается ограничение. 
Например, установим для столбца FirstName ограничение NOT NULL:  
ALTER TABLE Customers ALTER COLUMN FirstName SET NOT NULL;  
**Для удаления ограничения применяется оператор DROP**, после которого указывается ограничение. 
Например, удалим выше установленное ограничение:  
ALTER TABLE Customers ALTER COLUMN FirstName DROP NOT NULL;  
**Изменение ограничений таблицы**    
Добавление первичного ключа PRIMARY KEY:  
ALTER TABLE Customers ADD PRIMARY KEY (cust_id);  
Добавление ограничение UNIQUE - определим для столбца Email уникальные значения:  
ALTER TABLE Customers ADD UNIQUE (Email);  
Мы можем явным образом назначить ограничению при добавлении имени с помощью оператора CONSTRAINT.  
ALTER TABLE Customers ADD CONSTRAINT phone_unique UNIQUE (Phone);  
**Удалить ограничение**  
Чтобы удалить ограничение, надо знать его имя:  
ALTER TABLE Customers DROP CONSTRAINT phone_unique;  
**Переименование столбца и таблицы**  
Переименуем столбец Address в City:  
ALTER TABLE Customers RENAME COLUMN Address TO City;  
Переименуем таблицу Customers в Users:  
ALTER TABLE Customers RENAME TO Users;  
[подробнее](https://metanit.com/sql/postgresql/2.6.php)    
  
[к оглавлению](#SQL-Jdbc)  

## UPDATE/DELETE  
**UPDATE**  
Например, увеличим у всех товаров цену на 3000:    
UPDATE Products SET Price = Price + 3000;    
В данном случае обновление касается всех строк.
С помощью выражения WHERE можно с помощью условию конкретизировать обновляемые строки:   
UPDATE Products SET Manufacturer = 'Samsung Inc.' WHERE Manufacturer = 'Samsung';    
Также можно обновлять сразу несколько столбцов:    
UPDATE Products SET Manufacturer = 'Samsung', ProductCount = ProductCount + 3 WHERE Manufacturer = 'Samsung Inc.';

**DELETE**     
Например, удалим строки, у которых производитель - Apple:  
DELETE FROM Products WHERE Manufacturer='Apple';    
Если необходимо вовсе удалить все строки вне зависимости от условия, то условие можно не указывать:    
DELETE FROM Products;    

[к оглавлению](#SQL-Jdbc)  

## Ограничения столбцов и таблиц 
## **UNIQUE**    
Если мы хотим, чтобы столбец имел только уникальные значения, то для него нужно определить атрибут UNIQUE  
CREATE TABLE Customers (Id SERIAL, FirstName varchar(30) UNIQUE );  
В данном случае FirstName будет иметь уникальное значение. И мы не сможем добавить в таблицу две строки,
у которых значения для этих столбцов будет совпадать.    
Также мы можем определить этот атрибут на уровне таблицы:  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY, Email varchar(30), Phone varchar(30), Age INTEGER, UNIQUE(Email, Phone));  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY, Email varchar(30), Phone varchar(30), Age INTEGER,  UNIQUE(Email), UNIQUE(Phone));  
## **CHECK**     
Ключевое слово CHECK задает ограничение для диапазона значений, которые могут храниться в столбце.
Для этого после слова CHECK указывается в скобках условие, которому должен соответствовать столбец.  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY,
Age INT CHECK(Age >0 AND Age < 100),  
Email VARCHAR(30) CHECK(Email !=''),   
Phone VARCHAR(20) UNIQUE CHECK(Phone !=''));  
## **CONSTRAINT**    
С помощью ключевого слова CONSTRAINT можно задать имя для ограничений. В качестве ограничений могут использоваться **PRIMARY KEY, UNIQUE, CHECK**.
Необязательно задавать имена ограничений, но, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.    
CREATE TABLE Customers (     
Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,  
Email VARCHAR(30) CONSTRAINT customers_email_key UNIQUE,  
Phone VARCHAR(20) CONSTRAINT customers_phone_key UNIQUE);   
Мы задали названия: customer_Id, customers_email_key, customers_phone_key.      
И также можно задать все имена ограничений через атрибуты таблицы:  
CREATE TABLE Customers ( Id SERIAL, Age INTEGER, Email VARCHAR(30), Phone VARCHAR(20),    
CONSTRAINT customer_Id PRIMARY KEY(Id),    
CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),    
CONSTRAINT customers_email_key UNIQUE(Email),    
CONSTRAINT customers_phone_key UNIQUE(Phone));    

[к оглавлению](#SQL-Jdbc) 

## Что такое первичный ключ?  
**Первичный ключ - ункиальный идентификатор строки в таблице.**  
В качестве первичного ключа необязательно должны выступать столбцы с типом SERIAL, они могут представлять любой другой тип.    
CREATE TABLE Customers (Id SERIAL PRIMARY KEY);  
CREATE TABLE Customers (Id SERIAL, FirstName varchar(30), **PRIMARY KEY(Id)**);  
**Первичный ключ может быть составным** (compound key)  
Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать строку в таблице:  
CREATE TABLE OrderLines (OrderId INTEGER, ProductId INTEGER, Quantity INTEGER, PRIMARY KEY (OrderId, ProductId));  

[к оглавлению](#SQL-Jdbc)  

## Что такое внешний ключ?  
**Внешний ключ SQL — это ключ, используемый для объединения данных двух таблиц.**  
Часто информация об объекте распределена по нескольким таблицам, внешний ключ обеспечивает возможность получить полную информацию об объекте.   
Внешний ключ устанавливается для столбца из зависимой, 
подчиненной таблицы, и указывает на один из столбцов главной таблицы (обычно на первичный ключ). 
Т.е. внешний ключ - это поле значение, которого равно конкретному значению первичного ключа другой таблицы, 
тем самым мы можем понять, какая запись главной таблицы соответствует полю внешнего ключа.      
Внешний ключ поддерживает согласованное состояние данных между двумя таблицами, 
обеспечивая ссылочную целостность. **Этот тип целостности означает,
что всегда есть возможность получить полную информацию об объекте, распределенную по нескольким таблицам.**  
Т.е. таким образом мы можем разделить информацию об объекте на неск. таблиц, например,
из таблицы с заказами вынести поля покупателя и заказанного продукта в отдельные таблицы.    
Определение внешнего ключа на уровне таблицы выглядело бы следующим образом:    
CREATE TABLE Customers ( Id SERIAL PRIMARY KEY, Age INTEGER,  FirstName VARCHAR(20) NOT NULL);  
CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER, Quantity INTEGER, FOREIGN KEY (CustomerId) REFERENCES Customers (Id));  
 
**ON DELETE и ON UPDATE**  
ALTER TABLE inventory ADD CONSTRAINT fk_inv_product_id FOREIGN KEY (product_id) REFERENCES products (product_id) ON DELETE CASCADE;         
С помощью выражений ON DELETE и ON UPDATE можно установить действия, 
которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы:  
+ CASCADE: автоматически удаляет/изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.
+ RESTRICT: предотвращает какие-либо действия в зависимой таблице при удалении/изменении связанных строк в главной таблице.
То есть фактически какие-либо действия отсутствуют.
NO ACTION: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице 
**и генерирует ошибку.**  
+ SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.
+ SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. 
Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL.  
[подробнее](https://metanit.com/sql/postgresql/2.5.php)
[подробнее](http://www.sql-tutorial.ru/ru/book_foreign_key.html)  

[к оглавлению](#SQL-Jdbc)  

## Что такое нормализация БД?  
Нормализация - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам. 
Нормальные формы - это линейная последовательность правил, применяемых к БД, причем чем выше номер нормальной формы,
тем совершеннее структура БД.  
Нормализация - это  процесс, при котором таблицы БД организуются, разъединяются и данные приводятся в порядок.  
**Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, 
возникающих при добавлении, редактировании и удалении строк таблицы.**   
Аномалии изменения данных - это сложности при операциях вставки, изменения и удаления данных, возникающие из-за структуры БД. 
Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, 
и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. 
**Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.**  
Хотя существует много уровней, обычно достаточно выполнить нормализацию до Третьей нормальной формы (3НФ).  

В ненормализованной форме таблица может хранить информацию о двух и более сущностях. 
Также она может содержать повторяющиеся столбцы. Также столбцы могут хранить повторяющиеся значения.
В нормализованной же форме каждая таблица хранит информацию только об одной сущности. 
**Функциональная зависимость** описывает связь между атрибутами отношения,
если атрибут В функционально зависит от атрибута А (А → В), то каждое значение атрибута А связано только с одним значением атрибута В.   
Атрибут Teacher функционально зависит от атрибута Course (Course → Teacher), если
зная название курса, мы можем определить его преподавателя. 
И в этом случае можно говорить, что между атрибутами Course и Teacher есть связь 1:1,
а между Teacher и Course связь 1:N, так как есть несколько курсов, которые может вести один преподаватель.
При этом атрибут Course функционально не зависит от атрибута Teacher.  
 
В таблице в нормализованной базе данных единственным детерминантом должен быть атрибут, 
который является первичным ключом. А все остальные атрибуты должны функционально зависеть от первичного ключа. 
 
+ **Первая нормальная форм**а предполагает, что таблица не должна содержать повторяющихся столбцов или таких столбцов, которые содержат наборы значений **(атомарность данных)**.
+ **Вторая нормальная форма** применяется к тем таблицам, которые имеют составной первичный ключ,
то есть где первичный ключ состоит из нескольких атрибутов.  
**Во второй нормальной форме каждый столбец в таблице, который не является ключом, должен полностью функционально зависеть от ключа.**
**(По первчиному ключу можно определить любой стоблец - они полностью функционально зависят от него, но они все еще могут зависеть друг от друга)**  
Если в таблице несоставной первичный ключ, то в этом случае считается, 
что все остальные атрибуты автоматически находятся в полной функциональной зависимости от первичного ключа.  
То есть, если атрибут А составляют несколько значений, скажем, А1 и А2, то атрибут В полностью функционально зависит от А, если он зависит и от А1 и от А2 (А1, А2 → В).
**Если атрибут В зависит только от какого-либо подмножества из атрибута А, например, только от А1, то имеет место частичная функциональная зависимость. 
(чтобы этого избежать обычно таблица разъединяется)**    
+ **Третья нормальная форма**: каждый столбец, не являющийся ключом, должен зависеть только от столбца, 
который является ключом, то есть должна отсутствовать транзитивная функциональная зависимость. **(исключается зависимость столбцов друг от друга)**   
Транзитивная функциональная зависимость выражается следующим образом: А → В и В → С. 
То есть атрибут С транзитивно зависит от атрибута А, если атрибут С зависит от атрибута В,
а атрибут В зависит от атрибута А (при условии, что атрибут А функционально не зависит ни от атрибута В, ни от атрибута С).
Если столбец зависит не только от первичного ключа, то данный столбец находится не в той таблице,
в которой он должен находиться, либо же является производным от других столбцов.  
Для нормализации из исходной таблицы те атрибуты, которые находятся в транзитивной зависимости от ключа, 
выносятся в отдельную таблицу с копией того атрибута, от которого они непосредственно зависят. 
[подробнее](https://metanit.com/sql/tutorial/2.1.php)  

[к оглавлению](#SQL-Jdbc)   

## Что такое денормализация БД? 
Это намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации,
обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.

Добавление "избыточных" данных делается с целью:  
+ Для сохранения истории.  
+ Повышение производительности запросов за счет экономии на объединениях.  
+ Предварительные вычисления часто запрашиваемых значений.  
    
[к оглавлению](#SQL-Jdbc)  

## Что такое кластерный и некластерный индекс?  
**Индекс – это средство, обеспечивающее быстрый доступ к **строкам** таблицы на основе значений одного или нескольких столбцов.  
Индекс — это и есть отсортированный набор значений.**  
В самом простом случае, индекс необходимо создавать для тех колонок, которые присутствуют в условии WHERE, ORDER BY.  
Рассмотрим запрос из примера:  
SELECT * FROM users WHERE age = 29  
Нам необходимо создать индекс на колонку age:  
**CREATE INDEX age ON users(age);**  

id | name   | age  
1  | Den    | 29  
2  | Alyona | 15  
3  | Putin  | 89  
4  | Petro  | 12    
После создания индекса на колонку age, MySQL сохранит все ее значения в отсортированном виде.
Кроме этого, будет сохранена связь между значением в индексе и записью, которой соответствует это значение. 
Обычно для этого используется первичный ключ.  
  
age index    
12: 4    
15: 2    
29: 1    
89: 3  

Кла́стер (англ. cluster — скопление, кисть, рой) — объединение нескольких однородных элементов, которое может рассматриваться как самостоятельная единица, 
обладающая определёнными свойствами.    

**Кластерные индексы**  
Обычные индексы являются некластерными. Это означает, что сам индекс хранит только ссылки на записи таблицы.
Когда происходит работа с индексом, определяется только список записей (точнее список их первичных ключей),
подходящих под запрос. После этого происходит еще один запрос — для получения данных каждой записи из таблицы по индексу.  

Кластерный индекс (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде, а данные всей строки.
При работе с таким индексом не требуется дополнительной операции чтения данных.  
При использовании кластерного индекса строки таблицы сортируются по столбцу, к которому применяется кластерный индекс.
Поэтому в таблице может быть только один кластерный индекс, потому что вы не можете упорядочить таблицу двумя разными столбцами.  
(индекс хранится вместе с таблицей)    
CREATE CLUSTERED INDEX ix_employees_name ON Employees(Employee_Surname);  
[подробнее](https://riptutorial.com/ru/sql/example/13009/%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81) [подробнее](https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql)  

[к оглавлению](#SQL-Jdbc)   

## Что такое SQL курсор?  
**Курсор – временный набор строк, которые можно перебирать последовательно, с первой до последней, получается на основе какого-то Select** 
(похож на итератор или коллекцию, из которой можно получить отдельную строку)
SQL управляет контекстной областью с помощью курсора. 
Курсор содержит строки (одну или несколько), возвращаемые оператором SQL. Набор строк, которые содержит курсор, называется активным набором.
Вы можете назвать курсор так, чтобы на него можно было ссылаться в программе для выборки и обработки строк, возвращаемых оператором SQL, по одной за раз.   
[подробнее](https://coderlessons.com/tutorials/bazy-dannykh/izuchite-pl-sql/pl-sql-kursory)  
  
[к оглавлению](#SQL-Jdbc)  

## Опишите шаги по созданию и использованию курсора?  
При работе с курсорами используются следующие команды.
+ **Объявление курсора**: 
DECLARE имя_курсора CURSOR **FOR SELECT текст_запроса**  
**Любой курсор создается на основе некоторого оператора SELECT.**
+ **Открытие курсора**:
OPEN имя_курсора  
Для того чтобы с помощью курсора можно было читать строки, его надо обязательно открыть.
+ **Чтение следующей строки из курсора**:
FETCH имя_курсора INTO список_переменных  
Выборка курсора вовлекает доступ к одной строке за один раз.
Переменные в списке должны быть в том же количестве и того же типа, что и столбцы курсора. 
Глобальная переменная @@FETCH_STATUS принимает ненулевое значение, если строк в курсоре больше нет. Если же набор строк еще не исчерпан, 
то @@FETCH_STATUS равна нулю, и оператор FETCH перепишет значения полей из текущей строки в переменные. 
+ **Закрытие курсора**:
CLOSE имя_курсора
+ Для **удаления курсора из памяти** используется команда 
DEALLOCATE имя_курсора

**Для иллюстрации использования курсора создадим процедуру, которая будет выбирать данные из одной таблицы, 
перебирать их в курсоре анализируя, есть ли такие данные во второй таблице и вставлять в третью таблицу, 
если данные записи удовлетворяют определённым критериям.**
```sql
CREATE PROCEDURE [dbo].[MyProcedure] AS

DECLARE @ID INT // объявление переменной
DECLARE @QUA INT
DECLARE @VAL VARCHAR (500)
DECLARE @NAM VARCHAR (500)
/*Объявляем курсор*/
DECLARE @CURSOR CURSOR
/*Заполняем курсор*/
SET @CURSOR  = CURSOR SCROLL
FOR
SELECT  INDEX, QUANTITY, VALUE,  NAME  
  FROM  My_First_Table WHERE  QUANTITY > 1
/*Открываем курсор*/
OPEN @CURSOR
/*Выбираем первую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
/*Выполняем в цикле перебор строк*/
WHILE @@FETCH_STATUS = 0
BEGIN

        IF NOT EXISTS(SELECT VAL FROM My_Second_Table WHERE ID=@ID)
        BEGIN
/*Вставляем параметры в третью таблицу если условие соблюдается*/
        INSERT INTO My_Third_Table (VALUE, NAME) VALUE(@VAL, @NAM)
        END
/*Выбираем следующую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
END
CLOSE @CURSOR
```  

[к оглавлению](#SQL-Jdbc) 
      
## Что-такое-подзапрос?  
Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы.  
Это запрос, который выполнится перед основным и результаты которого будут данными,
из которых будет производиться дальнейшая обработка основным запросом.  
Подзапросы могут также выполняться и к той же таблице, к которой вызывается основной запрос:  
Например, найдем товары, которые имеют минимальную цену:    
SELECT * FROM Products WHERE Price = (SELECT MIN(Price) FROM Products);  
**Коррелирующие подзапросы**  
Коррелирующие подзапросы - запросы, результаты которых зависят от строк, которые извлекаются в основном запросе.  
Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре:  
SELECT  CreatedAt, Price, (SELECT ProductName FROM Products WHERE Products.Id = Orders.ProductId) AS Product FROM Orders;    
Здесь для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId.
И каждый подзапрос может возвращать различные данные.  
Часто можно заменить на join. 
[подробнее](https://metanit.com/sql/postgresql/4.7.php)  

[к оглавлению](#SQL-Jdbc)  
## Какие типы соединений (join) таблиц существуют? В чем их разница?  
![alt text](https://github.com/magidin91/theoretical_part/blob/sql_jdbc/src/main/resources/JOIN.jpg)  

Нередко возникает ситуация, когда нам надо получить данные из нескольких таблиц, для этого можно применять JOIN-ы.    
+ **INNER JOIN (пересечение)**     
SELECT столбцы FROM таблица1 [INNER] JOIN таблица2 ON условие1 [[INNER] JOIN таблица3 ON условие2];  
Как правило, для соединения применяется первичный ключ главной таблицы и внешний ключ зависимой таблицы.  
Выбираются только совпадающие данные из объединяемых таблиц.   
**SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName FROM Orders  
JOIN Products ON Products.Id = Orders.ProductId  
JOIN Customers ON Customers.Id=Orders.CustomerId;**  
Получим заказ с информацией о покупателе из таблицы Customers и о продукте из таблицы Products.  
Условия после ключевого слова ON могут быть более сложными по составу.
Например, выбирем все заказы на товары, производителем которых является Apple:  
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName FROM Orders  
JOIN Products **ON Products.Id = Orders.ProductId AND Products.Company='Apple'**  
JOIN Customers ON Customers.Id=Orders.CustomerId ORDER BY Customers.FirstName;    
+ **Cross Join (перекрестное соединение)**    
Перекрестное соединение создает набор строк, где каждая строка из одной таблицы соединяется с каждой строкой из второй таблицы. 
Например, соединим таблицу заказов Orders и таблицу покупателей Customers:  
SELECT * FROM Orders CROSS JOIN Customers;  
Если в таблице Orders 3 строки, а в таблице Customers то же три строки,
то в результате перекрестного соединения создается 3 * 3 = 9 строк вне зависимости, связаны ли данные строки или нет.  
Также можно опустить оператор CROSS JOIN: SELECT * FROM Orders, Customers;  
+ **OUTER JOIN**  
SELECT столбцы FROM таблица1 {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1 [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]  
Такое объединение вернет данные из обеих таблиц (совпадающие по условию объединения)
ПЛЮС дополнит выборку оставшимися данными из внешней таблицы, которые по условию не подходят, заполнив недостающие данные значением NULL.     
Left Join выбирает все строки первой таблицы и затем присоединяет к ним строки правой таблицы:  
**SELECT FirstName, CreatedAt, ProductCount, Price FROM Customers LEFT JOIN Orders ON Orders.CustomerId = Customers.Id;**  
Этот запрос выбирает все строки из таблицы Customers, затем дополняет их строками из таблицы Orders по условию ON Orders.CustomerId = Customers.Id,
если же для строки Customers не найдено соответствие по условию, эти поля будут заполнены NULL.  
Удобно использовать, если нужно посмотреть **обязательно все* объекты таблицы, плюс дополнительную информацию из связанных таблиц.  
**SELECT Customers.FirstName, Orders.CreatedAt,  Products.ProductName, Products.Company FROM Orders   
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id  
LEFT JOIN Products ON Orders.ProductId = Products.Id;**  
  
И также можно применять более комплексные условия с фильтрацией и сортировкой. 
Например, выберем все заказы с информацией о клиентах и товарах по тем товарам, у которых цена больше 55000, и отсортируем по дате заказа:  
SELECT Customers.FirstName, Orders.CreatedAt, Products.ProductName, Products.Company FROM Orders   
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id  
LEFT JOIN Products ON Orders.ProductId = Products.Id  
WHERE Products.Price > 55000 ORDER BY Orders.CreatedAt;  
**Или выберем только тех пользователей из Customers, у которых нет заказов в таблице Orders: (т.е. тех, для которых нет совпадения)**:  
**SELECT FirstName FROM Customers LEFT JOIN Orders ON Customers.Id = Orders.CustomerId WHERE Orders.CustomerId IS NULL;**  
  
Также можно комбинировать Inner Join и Outer Join:  
SELECT Customers.FirstName, Orders.CreatedAt, Products.ProductName, Products.Company FROM Orders   
JOIN Products ON Orders.ProductId = Products.Id AND Products.Price > 45000  
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id ORDER BY Orders.CreatedAt;  
Вначале по условию к таблице Orders через Inner Join присоединяется связанная информация из Products, 
затем  к этим записям через Outer Join добавляется информация из таблицы Customers.  
+ **FULL JOIN**  
Возвращает объединение объединений LEFT и RIGHT таблиц, комбинируя результат двух запросов.  
Чтобы получить обе таблицы, но без совпадающего множества:    
**SELECT FirstName, CreatedAt, ProductCount, Price FROM Customers FULL OUTER JOIN Orders
ON Orders.CustomerId = Customers.Id where Orders.CustomerId is Null or Customers.Id is Null;**    
+  **SELF JOIN** (селф иннер джоин)    
Таблица может быть соединена сама с собой, с разными строками, соответствующими друг другу.  
В  примере для каждого сотрудника в таблице базы данных  возвращается запись, содержащая имя сотрудника вместе с соответствующим именем менеджера сотрудника.
Поскольку менеджеры также являются сотрудниками, таблица объединяется с собой.  
SELECT  e.FName AS "Employee", m.FName AS "Manager" FROM Employees e  
JOIN Employees m ON e.ManagerId = m.Id    
[подробнее](https://riptutorial.com/ru/sql/example/940/self-join)   
    
[подробнее](http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html)
[подробнее](https://metanit.com/sql/postgresql/6.3.php)  

[к оглавлению](#SQL-Jdbc)  

## Что такое group by  
**GROUP BY используется для определения групп выходных строк.** К ним могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM).   
Все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть указаны в предложении GROUP BY.
В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах. 
После чего к каждой группе будут применены агрегатные функции. Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные,
то есть при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.  
Например, сгруппируем товары по производителю:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products GROUP BY Company;  
Т.е. для повторяющихся компаний мы сформируем группы и посчитаем число вхождений.  
Оператор GROUP BY может выполнять группировку по множеству столбцов.  
SELECT Company, ProductCount, COUNT(*) AS ModelsCount FROM Products GROUP BY Company, ProductCount;  
В данном случае группировка происходит по совпадению **одновременно двух столбцов** у строки (как бы по составному столбцу)  
[подробнее](https://metanit.com/sql/postgresql/4.6.php)
[подробнее](https://sql-academy.org/ru/guide/groupping-aggregate-functions )  

[к оглавлению](#SQL-Jdbc)  

## Что такое HAVING? Разница с Where?  
Оператор HAVING указывает, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп. 
Его использование аналогично применению оператора WHERE.  
Например, сгруппируем по производителям и найдем все группы, для которых определено более 1 модели:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products GROUP BY Company HAVING COUNT(*) > 1;  
При этом в одной команде мы можем использовать выражения WHERE и HAVING:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products WHERE Price * ProductCount > 80000 GROUP BY Company HAVING COUNT(*) > 1;  
Т.е. в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000.
Затем выбранные товары группируются по производителям. И далее фильтруются сами группы - выбираются те группы,
которые содержат больше 1 модели.  
Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING:  
SELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units FROM Products WHERE Price * ProductCount > 80000  
GROUP BY Company  
HAVING SUM(ProductCount) > 2  
ORDER BY Units DESC;  
В дополнение к оператору GROUP BY PostgreSQL поддерживает еще три специальных расширения для группировки данных: GROUPING SETS, ROLLUP и CUBE.  
Оператор ROLLUP добавляет суммирующую строку в результирующий набор.  
[подробнее](https://metanit.com/sql/postgresql/4.6.php)  
  
[к оглавлению](#SQL-Jdbc)  
  
##  Составные типы данных  
**Массивы**  
Столбцы в таблице в PostgreSQL могут представлять массивы, например,
массивы чисел INTEGER или массивы строк VARCHAR или массивы других типов данных.  
create table posts (id serial primary key, title varchar(30), body text, tags varchar(10)[]);  
Добавим в эту таблицу одну статью с набором тегов:  
insert into posts(title, body, tags) values('Post Title', 'Post Text', '{"sql", "postgres", "database", "plsql"}');  
Как и данные любого другого столбца, мы можем извлечь данные массива:  
select tags from posts;  
Однако с помощью индексов мы также можем конкретизировать, какие именно элементы массива мы хотим получить:  
select tags[1:3] from posts;  
Вначале идет индекс начала диапазона, а затем индекс конца диапазона. То есть в данном случае извлекаем три тега с первого по третий.  
При обновлении строки мы можем изменять как в целом все теги, так и какие-то конкретные теги:  
Переустановим массив:  
update posts set tags='{"sql", "postgres", "database"}' where id=1;  
Переустановим конкретный элемент, например, второй:  
update posts set tags[2]='system' where id=1;  
**Перечисления ENUM**  
PostgreSQL имеет специальный тип данных, который называется enum и который представляет набор констант. 
И столбец подобного типа может в качестве значения принимать одну из этих констант.  
Для создания перечисления используется команда CREATE TYPE. Например, создадим простейшее перечисление:  
create type request_state as enum ('created', 'approved', 'finshed');  
Данное перечисление называется "request_state".
После слова enum в скобках указывается через запятую список констант, которые составляют данное перечисление. 
То есть в данном случае перечисление request_status может принимать три значения: 'created', 'approved', 'finshed'.  
После создания перечисления мы можем использовать его в качестве типа столбца.  
create table requests (id serial primary key, title varchar(30), status request_state);  
Здесь третий столбец - status представляет перечисление request_state и может принимать одно из трех выше указанных значений.  
insert into requests(title, status) values ('Request 1', 'created');  
Кроме того, большую роль играет регистр символов, например, "created" не эквивалентно "Created".  
[подробнее](https://metanit.com/sql/postgresql/5.1.php)   
[подробнее](https://metanit.com/sql/postgresql/5.2.php)  

[к оглавлению](#SQL-Jdbc)      
  
## Множества: Union, EXCEPT, INTERSECT    
**Union (объединение множеств)**    
Оператор UNION позволяет объединить два множества (условно две таблицы). 
(т.е. если у нас есть две таблицы "сотрудники" и "клиенты" с полями имени и фамилии, их можно объединить в одно множество)
Но в отличие от inner/outer join объединения соединяют не столбцы разных таблиц, а два однотипных набора в один.  
Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами: 
именем (FirstName) и фамилией (LastName).   
Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц:    
SELECT FirstName, LastName FROM Customers UNION SELECT FirstName, LastName FROM Employees;  
В данном случае из первой таблицы выбираются два значения - имя и фамилия клиента. 
Из второй таблицы Employees также выбираются два значения - имя и фамилия сотрудников. 
То есть при объединении количество выбираемых столбцов и их тип совпадают для обеих выборок.  
**Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются.**
В случае с таблицами Customers и Employees сотрудники банка могут быть одновременно его клиентами и содержаться в обеих таблицах. 
Если же необходимо при объединении сохранить все, в том числе повторяющиеся строки, то для этого необходимо использовать оператор ALL  
SELECT FirstName, LastName FROM Customers UNION ALL SELECT FirstName, LastName  FROM Employees;  
При этом названия столбцов объединенной выборки будут совпадать с названия столбцов первой выборки. 
И если мы захотим при этом еще произвести сортировку, 
то в выражениях ORDER BY необходимо ориентироваться именно на названия столбцов первой выборки.  
Для объединения строк применяется оператор ||. (т.е. имя и фамилию можно объединить в один столбец)  
SELECT FirstName || ' ' || LastName AS FullName FROM Customers
UNION SELECT FirstName || ' ' || LastName AS EmployeeName  FROM Employees;    
[подробнее](https://metanit.com/sql/postgresql/6.5.php)  

**EXCEPT (разность множеств)**  
Оператор EXCEPT в PostgreSQL позволяет найти разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй.  
И допустим, нам надо найти всех клиентов банка, которые не являются его сотрудниками:  
SELECT FirstName, LastName FROM Customers EXCEPT SELECT FirstName, LastName FROM Employees;  

**INTERSECT (пересечение множеств)**   
Оператор INTERSECT позволяет найти общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения множеств.  
Найдем всех сотрудников банка, которые одновременно являются его клиентами:  
SELECT FirstName, LastName FROM Employees INTERSECT SELECT FirstName, LastName FROM Customers;

[к оглавлению](#SQL-Jdbc)   

## Что такое транзакция?  
Транзакции позволяют выполнять ряд операций в виде одного целостного пакета. 
И если хотя бы одна из этих операций завершится неудачно, то произойдет откат выполнения остальных операций.  
Транзакция Transaction включает одно или несколько изменений в базе данных, 
которые после выполнения либо все фиксируются (commit), либо все откатываются назад (rollback).  
```java
Connection connection = ...;
// Сброс автофиксации
connection.setAutoCommit(false);
// Первая транзакция
PreparedStatement updateSales = connection.prepareStatement(
         "UPDATE COFFEES SET SALES = ? WHERE COF_NAME LIKE ?");
updateSales.setInt(1, 50);
updateSales.setString(2, "Colombian");
updateSales.executeUpdate();

// Вторая транзакция
PreparedStatement updateTotal = connection.prepareStatement(
        "UPDATE COFFEES SET TOTAL = TOTAL + ? WHERE COF_NAME LIKE ?");
updateTotal.setInt(1, 50);
updateTotal.setString(2, "Colombian");
updateTotal.executeUpdate();
// Завершение транзакции
connection.commit();
// Восстановление по умолчанию
connection.setAutoCommit(true);  
```  
[подробнее](http://java-online.ru/jdbc-transaction.xhtml)    

[к оглавлению](#SQL-Jdbc)  

## Требования ACID к СУБД  
В информатике акроним ACID описывает требования к транзакциям (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.    
**Atomicity — Атомарность**  
Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
Будут либо выполнены все её подоперации, либо не выполнено ни одной.  
**Consistency — Согласованность**  
После завершения операции в БД останутся только согласованные (с точки зрения бизнес логики) данные.
Например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять,
не выйдет ли в результате отрицательных значений.  
**Isolation — Изолированность**  
**Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.**
**Другие клиенты (потоки, операции) не видят промежуточных несогласованных данных во время выполнения операции.**  
Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности).  
**Долговечность (durability)**
Изменения, получившиеся в результате транзакции, должны оставаться сохраненными вне зависимости от каких-либо сбоев.
Иначе говоря, если пользователь получил сигнал о завершении транзакции, он может быть уверен, что данные сохранены.  
(Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения,
сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.)    

[к оглавлению](#SQL-Jdbc)    
   
## Что такое хранимые процедуры?  
Нередко операция с данными представляет набор инструкций, которые необходимо выполнить в определенной последовательности. 
Например, при добавлении покупке товара необходимо внести данные в таблицу заказов. Однако перед этим надо проверить,
а есть ли покупаемый товар в наличии. Возможно, при этом понадобится проверить еще ряд дополнительных условий.
То есть фактически процесс покупки товара охватывает несколько действий, которые должны выполняться в определенной последовательности. 
И в этом случае более оптимально будет инкапсулировать все эти действия в один объект - хранимую процедуру (stored procedure).
**То есть по сути хранимые процедуры представляет набор инструкций, которые выполняются как единое целое.**
Тем самым хранимые процедуры позволяют упростить комплексные операции и вынести их в единый объект. 
Изменится процесс покупки товара, соответственно достаточно будет изменить код процедуры. То есть процедура также упрощает управление кодом.
Также хранимые процедуры позволяют ограничить доступ к данным в таблицах
и тем самым уменьшить вероятность преднамеренных или неосознанных нежелательных действий в отношении этих данных.
И еще один важный аспект - производительность. Хранимые процедуры обычно выполняются быстрее,
чем обычные SQL-инструкции. Все потому что код процедур компилируется один раз при первом ее запуске, а затем сохраняется в скомпилированной форме.
Для создания хранимой процедуры применяется команда CREATE PROCEDURE или CREATE PROC.  
CREATE PROCEDURE ProductSummary AS SELECT ProductName AS Product, Manufacturer, Price FROM Products  
**Таким образом, хранимая процедура имеет три ключевых особенности: упрощение кода, безопасность и производительность.**  
Для выполнения хранимой процедуры вызывается команда EXEC или EXECUTE.  
[подробнее](https://metanit.com/sql/sqlserver/11.1.php)
[к оглавлению](#SQL-Jdbc)  

## Что такое триггер? (Какие типы триггеров вы знаете?)  
Триггеры представляют специальный тип хранимой процедуры,
которая вызывается автоматически при выполнении определенного действия над таблицей или представлением,
в частности, при добавлении, изменении или удалении данных, то есть при выполнении команд INSERT, UPDATE, DELETE. (немного напоминают аспекты)  
CREATE TRIGGER имя_триггера ON {имя_таблицы | имя_представления} {AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE] AS выражения_sql;  
Мы можем использовать один из двух типов:  
AFTER: выполняется после выполнения действия. Определяется только для таблиц.  
INSTEAD OF: выполняется вместо действия (то есть по сути действие - добавление, изменение или удаление - вообще не выполняется).
Определяется для таблиц и представлений.  
CREATE TRIGGER Products_INSERT_UPDATE  
ON Products  
AFTER INSERT, UPDATE  
AS  
UPDATE Products  
SET Price = Price + Price * 0.38  
WHERE Id = (SELECT Id FROM inserted)    
  
[подробнее](https://metanit.com/sql/sqlserver/12.1.php)
[к оглавлению](#SQL-Jdbc)    

## Что такое view  
Представления или Views представляют виртуальные таблицы - т.е. представляют таблицы, но сами данные хранятся в других таблицах, а 
они извлекают эти данные в момент обращения к ним. 
Представления дают нам ряд преимуществ. Они упрощают комплексные SQL-операции.
Они защищают данные, так как представления могут дать доступ к части таблицы, а не ко всей таблице.
Представления также позволяют возвращать отформатированные значения из таблиц в нужной и удобной форме.  
CREATE VIEW OrdersProductsCustomers AS SELECT Orders.CreatedAt AS OrderDate, Customers.FirstName AS Customer,
Products.ProductName As Product FROM Orders     
INNER JOIN Products ON Orders.ProductId = Products.Id  
INNER JOIN Customers ON Orders.CustomerId = Customers.Id  
То есть данное представление фактически будет возвращать сводные данные из трех таблиц.
И после его создания мы сможем его увидеть в узле Views у выбранной базы данных в SQL.  
[подробнее](https://metanit.com/sql/sqlserver/10.1.php)  

[к оглавлению](#SQL-Jdbc) 

## Для чего используется конструкция try-with-resources  
Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally в которой
и происходит закрытие без участия разработчика. Конструкция является так называемым «синтаксическим сахаром»
и создана для облегчения жизни программиста. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.  

[к оглавлению](#SQL-Jdbc)    

## Дополнительно:  
**Команды PostgreSQL:**  
+ create database test; 
+ use test;  
или \c test; для postgresql  
Приказать СУБД использовать созданную базу данных
+ drop table students; 
 
**Команды SQL:**  
+ DESC students;  
Посмотреть описание созданной таблицы.
+ SHOW CREATE TABLE users;  
В MySql возвращает команду CREATE TABLE, которая была использована для создания таблицы.  
+ insert into students values ('', 'Petr', '2000-06-02');  
Два апострофа означают,что значение первичного ключа должно генерироваться автоматически.
  
**Получение части строки:**  
SUBSTRING_INDEX ()    
Функция SUBSTRING_INDEX () находит все символы текстового значения, предшествующие заданному символу или подстроке.
Запятая заключается в апострофы, а функция SUBSTRING INDEX () возвращает все символы, стоящие перед запятой:  
SELECT SUBSTRING_INDEX (location, ’,’ , 1 ) FROM my__contacts; (1 – значит, что ищется первая запятая)  
[подробнее](http://old.code.mu/sql/substring_index.html)  

[к оглавлению](#SQL-Jdbc)  

## JDBC  

## Опишите процесс создания запроса через JDBC  
+ Загрузка драйвера базы данных. Для загрузки/использования нашего драйвера можно пойти двумя путями. 
Первый – это вписать имя драйвера в код программы. В этом случае мы не сможем изменить СУБД без перекомпиляции. 
Второй – это подключать драйвер из командной строки Java (JVM). 
Следующей строчкой мы загружаем драйвер, и он автоматически зарегистрируется себя для использования вместе с JDBC.
```java
Class.forName(“postgresql.Driver”);
```
Во втором же случае мы используем ключ –D для подключения драйвера.
```java
java –Djdbc.drivers=postgresql.Driver myClass
```
+ Для соединения с базой данных используют класс Connection:
```java
Connection dbh = DriverManager.getConnection(url, user, passwd);
```
+ Установив соединение, мы можем выполнять sql-запросы к нашей базе данных. 
Для примера, рассмотрим небольшой кусок кода на Java:
```java
Statement st = dbh.createStatement();

ResultSet rs = st.executeQuery(
"select * from flowers_tbl where (flowers_id in (1,2,3,4,5,6,7,8,9))"
);

while (rs.next())
{
  System.out.println(rs.getString(1));
}
rs.close();
st.close();
```

Для того, чтобы посылать запросы к базе данных, необходимо создать экземпляр класса Statement st. 
Метод executeQuery этого класса отправляет переданный ему запрос к базе данных и в качестве ответа возвращает результат 
в виде класса ResultSet.

В конце надо закрыть все ресурсы.  

[к оглавлению](#SQL-Jdbc)  

## ANSI SQL

SQL (structured query language — «язык структурированных запросов») — формальный непроцедурный язык программирования, 
применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой 
соответствующей системой управления базами данных (СУБД). SQL основывается на исчислении кортежей. Стандарт SQL 
определяется с помощью кода ANSI.

[к оглавлению](#SQL)

## Основные элементы баз данных – таблицы процедуры функции констрейнты и тд

**Поле** — это минимальный элемент базы данных, содержащий один неделимый квант информации. 
Каждое поле характеризуется именем и типом хранящихся в нем данных.

**Запись** — это совокупность нескольких разнородных полей, описывающая некоторую сущность предметной области.

**Таблица базы данных** — это набор однородных записей.

**Хранимая процедура** — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз
 и хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, 
 у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления 
 и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. 
 В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). 
 Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции 
 управления процессом исполнения.
```sql
CREATE [OR REPLACE] PROCEDURE имя_процедуры
[ (параметр [, параметр, …]) ] IS
            [локальные объявления]
        BEGIN
            исполняемые предложения
        [EXCEPTION
            обработчики исключений]
        END [имя_процедуры];
```
**Функция** – это подпрограмма, которая вычисляет значение. 
Существует большое количество встроенных функций (могут разниться для разных БД).
```sql
CREATE [OR REPLACE] FUNCTION имя_функции
[ (параметр [, параметр, …]) ]
RETURN тип_данных IS | AS
            [локальные объявления]
        BEGIN
            исполняемые предложения
        [EXCEPTION
            обработчики исключений]
        END [имя_функции];
```

**Констрейнты (constraints)** — объявление правил (ограничения), которым должны соответствовать данные в таблице.
```sql
CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
Например для задания первичного ключа, можно использовать такую запись:
CONSTRAINT <имя ограничения> PRIMARY KEY (<список столбцов, являющихся первичным ключом>)
```

Типы констрейнтов:

+ NOT NULL -колонка не может содержать NULL значений.
+ UNIQUE — каждая строка в колонке должна иметь уникальное значение.
+ PRIMARY KEY — комбинация NOT NULL и UNIQUE.
+ FOREIGN KEY — обеспечивает ссылочную целостность. Означает что ссылающиеся данные имеют соответствие в другой таблице.
+ CHECK — проверка на определенное выполнение правил.
+ DEFAULT — задает значение по умолчанию для колонки

[к оглавлению](#SQL)

## Как вы понимаете null в базах данных

Смысл NULL-значения — это отсутствие информации или неприменимость данного атрибута в данном кортеже.
NULL-значение может означать неприменимость значения к этому столбцу (например в колонке «скорость полета» для таблицы животные и записи «Слон»)
NULL-значение так же может означать отсутствие информации. Заменять отсутствующие значения, например на -1, ‘ ‘ или что-то такое, не корректно.

[к оглавлению](#SQL)

## Агрегатные функции как они работают с null Не забудьте о group by и having

Стандартом предусмотрены следующие агрегатные функции:

+ COUNT(*)	Возвращает количество строк источника записей
+ COUNT	Возвращает количество значений в указанном столбце
+ SUM	Возвращает сумму значений в указанном столбце
+ AVG	Возвращает среднее значение в указанном столбце
+ MIN	Возвращает минимальное значение в указанном столбце
+ MAX	Возвращает максимальное значение в указанном столбце

Все эти функции возвращают единственное значение. При этом функции COUNT, MIN и MAX применимы к данным любого типа, 
в то время как SUM и AVG используются только для данных числового типа. Разница между функцией COUNT(*) 
и COUNT(имя столбца | выражение) состоит в том, что вторая (как и остальные агрегатные функции) при подсчете 
не учитывает NULL-значения.

Предложение GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные 
функции (COUNT, MIN, MAX, AVG и SUM).

Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING применяется после группировки для
определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций. 
Это предложение необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк 
источника записей, определенного в предложении FROM, а из групп таких строк. Поэтому такая проверка не может содержаться 
в предложении WHERE.

[к оглавлению](#SQL)

## Каким образом лучше добавлять большое количество записей в таблицу

+ Отключить автокоммит.
+ Выполнить insert.
+ Закоммитить вручную.
+ Включить автокоммит.

[к оглавлению](#SQL)

## Что такое первая нормальная форма и процесс нормализации Какие бывают нормальные формы

Первая нормальная форма (1NF) — базовая нормальная форма отношения в реляционной модели данных.

Нормальная форма — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, 
потенциально приводящей к логически ошибочным результатам выборки или изменения данных. 
Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение. 
Нормальные формы: первая нормальная форма, вторая нормальная форма, третья нормальная форма, 
нормальная форма Бойса — Кодда, четвёртая нормальная форма, пятая нормальная форма.



[к оглавлению](#SQL)

## В чем смысл индекса СУБД как они устроены как хранятся Как бы вы реализовали тот же функционал

Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. 
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, 
и их поиск по заданному критерию путем последовательного просмотра таблицы строка за строкой может занимать много времени. 
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, 
таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов 
достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, 
сбалансированного дерева.

Обзор типов индексов Oracle, MySQL, PostgreSQL, MS SQL: http://habrahabr.ru/post/102785/

[к оглавлению](#SQL)

## Что такое JDBC API и когда его используют

JDBC – это стандарт взаимодействия приложения с различными СУБД. JDBC основан на концепции драйверов, 
позволяющей получать соединение с БД по специальному url. JDBC API находятся в пакетах java.sql и javax.sql. 
С помощью JDBC API можно создавать соединения с БД, выполнять SQL запросы, хранимые процедуры и обрабатывать результаты. 
JDBC API упрощает работу с базами данных из Java программ.

[к оглавлению](#SQL)

## Что такое JDBC Driver и какие различные типы драйверов JDBC вы знаете

JDBC основан на концепции так называемых драйверов, позволяющих получать соединение с базой данных по специально 
описанному URL. Драйверы могут загружаться динамически (во время работы программы). Загрузившись, 
драйвер сам регистрирует себя и вызывается автоматически, когда программа требует URL, содержащий протокол, 
за который драйвер отвечает.

[к оглавлению](#SQL)

## Как JDBC API помогает достичь слабой связи между Java программой и JDBC Drivers API

JDBC API используют рефлексию в java для достижения слабой связи между джава программой и JDBC драйверами. 
Драйвер фактически загружается один раз с помощью Class.forName(), а дальше используются возможности JDBC API в Java. 
Таким образом мы пишем код не особо задумываясь с какой базой данных мы будем работать. 
При необходимости достаточно указать другой драйвер и не переписывать большое количество кода.

[к оглавлению](#SQL)

## Что такое JDBC Connection Покажите шаги для подключения программы к базе данных

JDBC Connection — соединение, установленное с сервером базы данных. 
Это своего рода сессия или Socket Connection. Для создания JDBC connection требуется всего два шага:
1) Зарегистрировать и загрузить драйвер с помощью Class.forName(). Класс драйвера будет зарегистрирован для DriverManager 
и загружен в память.
2) Используя DriverManager.getConnection() получить объект Connection. 
В метод необходимо передать URL базы данных, имя и пароль.
```sql
Connection con = null;
try{
    // load the Driver Class
    Class.forName("com.mysql.jdbc.Driver");
 
    // create the connection now
    con = DriverManager.getConnection("jdbc:mysql://localhost:3306/UserDB",
                    "pankaj",
                    "pankaj123");
    }catch (SQLException e) {
            System.out.println("Check database is UP and configs are correct");
            e.printStackTrace();
    }catch (ClassNotFoundException e) {
            System.out.println("Please include JDBC MySQL jar in classpath");
            e.printStackTrace();
    }
```
[к оглавлению](#SQL)

## Как используется JDBC DriverManager class

JDBC DriverManager — фабрика, через которую можно получить объект Database Connection. 
После загрузки JDBC драйвера в память, он регистрирует себя в DriverManager (что можно проверить посмотрев в исходники 
JDBC Driver class). DriverManager используется для получения подключения с помощью зарегистрированных драйверов 
(метод getConnection()).

[к оглавлению](#SQL)

## Как получить информацию о сервере базы данных из java программы

С помощью объекта интерфейса DatabaseMetaData можно получить детальную информацию о сервере. 
После подключения к БД мы можем вызывать метод getMetaData() и получить объект DatabaseMetaData. 
Существует множество методов для получения различной информации, например о версии БД, конфигурации и т.п.
```sql
DatabaseMetaData metaData = con.getMetaData();
String dbProduct = metaData.getDatabaseProductName();
```
[к оглавлению](#SQL)

## Что такое JDBC Statement

JDBC API Statement используется для выполнения SQL запросов к базе данных. 
Объект Statement можно получить с помощью метода Connection.getStatement(). 
Вызывая методы execute(), executeQuery(), executeUpdate() и др., можно выполнять различные статичные SQL запросы.

В случае динамически созданных SQL запросов внутри java программы, когда введенные пользователем данные могут быть 
не проверенными, можно использовать SQL injection.

По умолчанию только один объект ResultSet для каждого Statement может быть открыт в одно и то же время. 
Таким образом, если необходимо работать с несколькими объектами ResultSet одновременно, мы должны использовать различные 
объекты Statement. Все execute() методы в интерфейсе Statement закроют текущий открытый объект ResultSet при выполнении.

[к оглавлению](#SQL)

## Какие различия между execute executeQuery executeUpdate

Существует несколько способов выполнять SQL-запросы в зависимости от типа этого запроса. 
Для этого у интерфейса Statement существует три различных метода: executeQuery(), executeUpdate(), а так же execute(). 
Рассмотрим их отдельно.

Самый базовый метод executeQuery() необходим для запросов, результатом которых является один единственный набор значений, 
таких как у запросов SELECT. Возвращает ResultSet, который не может быть null даже если у результата запроса 
не было найдено значений.

Метод execute() используется, когда операторы SQL возвращают более одного набора данных, более одного счетчика обновлений 
или и то, и другое. Метод возвращает true, если результатом является ResultSet, как у запроса SELECT. Вернет false, 
если ResultSet отсутствует, например при запросах вида Insert, Update. С помощью методов getResultSet() мы можем получить 
ResultSet, а getUpdateCount() — количество обновленных записей.

Метод executeUpdate() используется для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов 
DDL (Data Definition Language — язык определения данных), например, CREATE TABLE и DROP TABLE. 
Результатом оператора INSERT, UPDATE, или DELETE является модификация одной или более колонок в нуле или более строках таблицы. 
Метод executeUpdate() возвращает целое число, показывающее, сколько строк было модифицировано. 
Для выражений типа CREATE TABLE и DROP TABLE, которые не оперируют над строками, возвращаемое методом executeUpdate() 
значение всегда равно нулю.

Все методы выполнения SQL-запросов закрывают предыдущий набор результатов (result set) у данного объекта Statement. 
Это означает, что перед тем как выполнять следующий запрос над тем же объектом Statement, 
надо завершить обработку результатов предыдущего (ResultSet).

[к оглавлению](#SQL)

## Что такое JDBC PreparedStatement

Объект PreparedStatement используется для выполнения прекомпилированных SQL-запросов с или без входных (IN) параметров. 
Мы можем использовать сеттеры для установки значений в запрос. Т.к. PreparedStatement является предкомпилированным, 
то он может быть эффективно использован множество раз. PreparedStatement считается лучшим выбором нежели Statement, т.к. 
он автоматически обрабатывает специальные символы, а так же предотвращает, так называемые, SQL injection attack 
(когда в запрос можно подставить свой код).

[к оглавлению](#SQL)

## Как установить NULL значения в JDBC PreparedStatement

Используя метод setNull() для установки null переменной в качестве параметра. 
Этот метод принимает индекс и SQL тип в качестве аргументов: s.setNull(10, java.sql.Types.INTEGER);

[к оглавлению](#SQL)

## Как используется метод getGeneratedKeys в Statement

Если в таблице используется автоматическая генерация ключей, то для их получения используется метод Statement getGeneratedKeys(), 
который вернет сгенерированный ключ.

[к оглавлению](#SQL)

## Какие преимущества в использовании PreparedStatement над Statement

+ PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы.
+ PreparedStatement позволяет использовать динамические запросы с внедрением параметров.
+ PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement 
или при использовании для вызова группы запросов.
+ PreparedStatement позволяет писать объектно ориентированный код с использованием сеттеров\геттеров. 
В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. 
Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.

[к оглавлению](#SQL)

## Какие есть ограничения PreparedStatement и как их преодолеть

В PreparedStatement нельзя использовать напрямую запросы с IN (входными) параметрами. Есть некоторые обходные пути:

+ Выполнить Single Queries – низкая производительность и вообще не рекомендуется так делать.
+ Использовать Stored Procedure (хранимые процедуры) – являются специфичными для конкретной базы данных и следовательно 
плохи для приложений с возможностью подключения к различным БД.
+ Создание PreparedStatement Query динамически – это хорошее решение, но с потерей кэширования PreparedStatement.
+ Использование NULL в PreparedStatement Query – хорошее решение, если вы знаете максимальное число переменных IN. 
Можно расширить до использования неограниченного кол-во параметров с помощью разбиения на части.

[к оглавлению](#SQL)

## Что такое JDBC ResultSet

JDBC ResultSet — интерфейс, объект которого создается в результате запроса к базе данных. 
Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.
Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. 
При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). 
При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице 
полученных результатов.

По умолчанию объект ResultSet не модифицируемый и поддерживает курсор, который способен только к движение вперед. 
Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного 
движения по таблице, а так же возможности обновления:
```sql
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                   ResultSet.CONCUR_UPDATABLE);
```

Объект ResultSet автоматически закрывается при закрытии объекта, который его сгенерировал. 
Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.

Для использования геттера ResultSet можно использовать имя колонки или индекс, который начинается с 1.

[к оглавлению](#SQL)

## Какие существуют различные типы JDBC ResultSet

При создании Statement можно задать различные типы получаемого ResultSet.

Три типа объектов ResultSet:

+ **ResultSet.TYPE_FORWARD_ONLY:** тип по умолчанию. Поддерживает движение курсора только в прямом направлении.
+ **ResultSet.TYPE_SCROLL_INSENSITIVE:** Двунаправленный курсор. Объект не чувствителен к изменениям, которые произошли с таблицей после получения результата.
+ **ResultSet.TYPE_SCROLL_SENSITIVE:** Двунаправленный курсор. Объект чувствителен к изменениям, которые произошли с базой данных после создания объекта ResultSet.

Два типа потокобезопасных объектов ResultSet:

+ **ResultSet.CONCUR_READ_ONLY:** Поддерживает только чтение (read only). Применяется по умолчанию.
+ **ResultSet.CONCUR_UPDATABLE:** Поддерживает метод ResultSet update для обновления строк в таблице данных.

[к оглавлению](#SQL)

## Как используются методы setFetchSize и SetMaxRows в Statement

Для ограничения количества строк, которые может вернуть запрос, применяется метод setMaxRows(int i). 
Конечно, этот результат можно получить используя SQL запрос (например для MySQL существует команда LIMIT).

Для понимания метода setFetchSize() необходимо разобраться с работой Statement и ResultSet. 
Когда выполняется запрос к базе данных, результат обрабатывается и сохраняется в кэше базы данных и возвращается в виде ResultSet. 
ResultSet является курсором, которые ссылается на результат в базе данных. Теперь допустим мы имеем запрос, 
который возвращает 100 строк и мы установили setFetchSize(10). Теперь для каждого обращения к базе данных выделено только 10 строк 
и понадобится 10 запросов, чтобы получить все данные. Выбор оптимального количества fetchSize() может улучшить производительность 
выполнения большого кол-ва обращений к каждой строке и в случае большого количества строк в выходном результате.

Значение fetchSize можно указать внутри объекта Statement, но оно может быть переопределено в объекте ResultSet с помощью setFetchSize().

[к оглавлению](#SQL)

## Как вызвать Stored Procedures используя JDBC API

Хранимые процедуры — это группы SQL запросов, которые компилируются в базе данных и могут быть вызваны с помощью JDBC API. 
Для вызова хранимых процедур используется объект CallableStatement. Нам необходимо задать параметры выхода OUT до выполнения CallableStatement.
```sql
CallableStatement stmt = con.prepareCall("{call insertEmployee(?,?,?,?,?,?)}");
stmt.setInt(1, id);
stmt.setString(2, name);
stmt.setString(3, role);
stmt.setString(4, city);
stmt.setString(5, country);
 
//register the OUT parameter before calling the stored procedure
stmt.registerOutParameter(6, java.sql.Types.VARCHAR);
              
stmt.executeUpdate();
```
[к оглавлению](#SQL)

## Что такое JDBC Batch Processing и каковы его преимущества

Бывает необходимо выполнить сразу группу похожих запросов, например при загрузке данных из CSV файлов реляционной базы данных. 
Это можно сделать просто используя Statement или PreparedStatement для пошагового выполнения этих запросов. 
В JDBC API существует другая возможность, которая предоставляет возможность выполнить группу запросов за один раз. 
Выполнение такого рода задачи происходит с помощью JDBC API Batch Processing.

JDBC API поддерживает пакетную обработку с помощью методов addBatch() и executeBatch() у Statement и PreparedStatement. 
К преимуществам такого подхода относится более быстрая работа, т.к. вызовов к базе данных может быть существенно меньше.

[к оглавлению](#SQL)

## Что такое JDBC Transaction Management и зачем он нужен

По умолчанию, при создании подключения к базе данных будет выбран auto-commit mode. 
Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению. 
Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения будут 
приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения какого-либо 
запроса (или групп запросов) в случае, если что-то пошло не так, то мы можем воспользоваться поддержкой транзакций в JDBC API.

С помощью метода setAutoCommit(boolean flag) можно отключить авто коммит в конкретном соединении. 
Следует отметить, что при отключении auto-commit не одно изменение не будет сохранено в базе данных до вызова 
метода commit() и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных 
до подтверждения транзакции, а так как это ресурсоёмкая задача, то подтверждать транзакцию необходимо сразу после выполнения задачи.

[к оглавлению](#SQL)

## Как откатить JDBC транзакцию

Для этого предусмотрен метод объекта Connection rollback(), который откатывает транзакцию. 
Будут отменены все изменения в транзакции и отменен lock базы данных от этого объекта Connection.

[к оглавлению](#SQL)

## Что такое JDBC Savepoint и как он используется

JDBC Savepoint позволяет создавать «чекпоинты» в транзакции с помощью которых мы можем откатить не всю транзакцию целиком, 
а только часть до точки сохранения. Любая точка сохранения автоматически освобождается и становится недоступной после 
подтверждения транзакции или её роллбека. Откат к точке сохранения делает все последующие сейвы недоступными и к ним уже 
нельзя будет вернуться.

[к оглавлению](#SQL)

## Расскажите о JDBC DataSource Какие преимущества он дает

JDBC DataSource является интерфейсом пакета javax.sql и является более продвинутым в сравнении с DriverManager 
для подключения к базе данных. Мы можем использовать DataSource для создания подключения к базе данных и реализацию 
класса драйвера, которая будет выполнять всю работу по поддержанию соединения. 
В дополнение к соединению через Database, DataSource предоставляет следующие дополнительные возможности:

+ Кэширование PreparedStatement для ускорения обработки запросов
+ Настройки Connection timeout
+ Возможности логирования
+ Порог максимального размера ResultSet
+ Поддержка Connection Pooling в контейнере сервлетов, использующий поддержку JNDI.

[к оглавлению](#SQL)

## Расскажите про Apache DBCP API

При использование DataSource для получения соединения с базой данных возникает проблема тесной связи кода с драйвером реализации 
DataSource. Кроме того, большинство из кода является шаблонно повторяющимся (т.н. boilerplate code), 
за исключением выбора класса реализации источника данных.

Apache DBCP API помогает нам избавиться от этих проблем, предоставляя реализацию DataSource, который работает 
в качестве уровня абстракции между нашей программой и различными драйверами JDBC. Библиотека Apache DBCP API основана 
на библиотеке Commons Pool library, поэтому необходимо удостовериться, что все необходимые зависимости правильно подключены к проекту.

[к оглавлению](#SQL)

## Какие вы знаете уровни изоляции соединений в JDBC

Уровень изолированности транзакций — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, 
то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, 
но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности 
позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Когда мы используем транзакции в JDBC для обеспечения целостности данных, СУБД использует блокировки, 
чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. 
Такие блокировки необходимы, чтобы предотвратить грязное чтение (Dirty Read), неповторяющиеся чтение (Non-Repeatable Read) 
и фантомное чтение (Phantom-Read).
Уровень изоляции транзакции JDBC используемый СУБД для механизма блокировки можно задать с помощью метода setTransactionIsolation(). 
Получить информацию о применяемом уровне изоляции поможет метод Connection getTransactionIsolation().

| Isolation Level| Transaction| Dirty Read| Non-Repeatable Read| Phantom Read |
| ---| ---| ---| ---| --- |
| TRANSACTION_NONE| Not Supported| Not Applicable| Not Applicable| Not Applicable |
| TRANSACTION_READ_COMMITTED| Supported| Prevented| Allowed| Allowed |
| TRANSACTION_READ_UNCOMMITTED| Supported| Allowed| Allowed| Allowed |
| TRANSACTION_REPEATABLE_READ| Supported| Prevented| Prevented| Allowed |
| TRANSACTION_SERIALIZABLE| Supported| Prevented| Prevented| Prevented |

[к оглавлению](#SQL)

## Что вы знаете о JDBC RowSet Какие существуют различные типы RowSet

JDBC RowSet содержит табличные данные в более гибком формате по сравнению с ResultSet. 
Все объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet 
с некоторыми дополнительными функциями. RowSet интерфейс определяется в javax.sql пакета. 
Можно выделить следующие дополнительные функции, предоставляемые RowSet:

Функции похожие на Java Beans со свойствами и get\set методами для работы с ними. RowSet использует модель событий JavaBeans. 
В результате можно посылать уведомления любого зарегистрированного компонента для таких событий, например, движение курсора, 
обновления / вставка / удаление из строки и изменять содержимое RowSet.
Объекты RowSet поддерживают скроллинг по данным (scrollable), а так же являются обновляемыми по умолчанию. 
Так что если СУБД не поддерживает скроллинг или обновляемый ResultSet, мы можем использовать RowSet, чтобы получить эти функции.

RowSet можно разделить на два типа:

+ Connected RowSet Objects – эти объекты подключаются к БД и очень похожи на объекты ResultSet. 
JDBC API предоставляет только одно подключение объекта RowSet — javax.sql.rowset.JdbcRowSet 
и это является стандартной реализации класса com.sun.rowset.JdbcRowSetImpl.
+ Disconnected RowSet Objects – эти объекты RowSet не требуют подключения к базе данных. 
Они более легковесные и могут быть сериализованы. Такие объекты хорошо подходят для передачи данных по сети. 
Существуют четыре реализации такого типа объектов (disconnected RowSet objects).

Кратко рассмотрим четыре реализации Disconnected RowSet Objects:

+ CachedRowSet — объекты могут получить соединение и выполнить запрос, считать данные ResultSet для заполнения данных RowSet. 
Мы можем управлять и обновлять данные на время отключения от БД и записать измененные данные при очередном подключении.
+ WebRowSet получены из CachedRowSet — такие объекты могут читать и записывать XML документы.
+ JoinRowSet получены из WebRowSet — могут образовывать SQL JOIN без подключения к источнику данных.
+ FilteredRowSet получены из WebRowSet — поддержка применения критериев фильтрации, поэтому видны только выбранные (полученные) данные.

[к оглавлению](#SQL)

## В чем разница между ResultSet и RowSet

Объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet с некоторыми дополнительными функциями. 
Одним из существенных преимуществ является возможность работы с данными без соединения с базой, а так же их легковесность 
и возможности пересылки данных объектов по сети.

Следует ли использовать ResultSet или RowSet зависит от ваших требований. ResultSet, возможно, подойдет к длительным подключениям, 
в то время как RowSet будет лучшим выбором для подключений к базам данных с возможностью дисконекта и обработки полученных данных.

[к оглавлению](#SQL)

## Приведите пример наиболее распространенных исключений в JDBC

Некоторые из наиболее распространенных исключений JDBC:

+ java.sql.SQLException — это базовый класс для исключений JDBC.
+ java.sql.BatchUpdateException — возникает при исключительных ситуациях пакетной обработки запросов. Может зависеть от типа драйвера JDBC, который может выбросить взамен базовый SQLException.
+ java.sql.SQLWarning — для предупреждающих сообщений различных SQL операций.
+ java.sql.DataTruncation — когда значения данных неожиданно усекаются по причинам, не зависящим от превышения MaxFieldSize.

[к оглавлению](#SQL)

## Расскажите о типах данных CLOB и BLOB в JDBC

Character Large OBjects (CLOBs) — тип данных (внутренний символьный объект), используемый для хранения больших объектов. 
При выборе значения любого LOB-типа посредством оператора SELECT возвращается указатель, а не само значение; 
кроме того, типы LOB могут быть и внешними. Этот тип данных является подходящим для хранения текстовой информации, 
которая может выходить за пределы обычного типа данных VARCHAR (верхний предел 32 Кбайт).
Внутренний большой двоичный объект (BLOB) — двоичный объект большого размера, который может содержать переменное количество данных. 
Этот тип данных может хранить данные объемом более VARBINARY (32K предел). Тип данных, предназначенный, в первую очередь, 
для хранения изображений, аудио и видео, а также компилированного программного кода.

[к оглавлению](#SQL)

## Что вы знаете о «грязном чтении» dirty read в JDBC Какой уровень изоляции предотвращает этот тип чтения

«Грязное» чтение (англ. dirty read) — чтение данных, добавленных или изменённых транзакцией, 
которая впоследствии не подтвердится (откатится). Получение недействительного в последствии значения (после отката транзакции) 
может приводить к непредвиденным результатам.

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| UPDATE tbl1 SET f2=f2+1 WHERE f1=1; | |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| ROLLBACK WORK; | |

Dirty Read можно предотвратить, используя следующие уровни изоляции: 
TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ и TRANSACTION_SERIALIZABLE.

[к оглавлению](#SQL)

## Какие есть две фазы commit

Когда мы работаем в распределенных системах, где участвуют несколько баз данных, мы должны использовать протокол с 2 фазами фиксации. 
2 фазовый протокол фиксации является атомарным протоколом для распределенных систем. 
На первом этапе, менеджер транзакций передает commit-request всем ресурсам транзакции. 
Если все ресурсы транзакции ответили ОК, то менеджер транзакций фиксирует изменения транзакций для всех ресурсов. 
Если какой-либо из ресурсов транзакций уведомляет об отмене, то менеджер транзакций может откатить все изменения транзакций.

[к оглавлению](#SQL)

## Приведите пример различных типов блокировки в JDBC

На более широком уровне есть два типа механизма блокировки для предотвращения повреждения данных из-за одновременной 
работы с данными несколькими пользователями. По логике реализации различают два вида блокировок.

**Оптимистическая блокировка** — не ограничивает модификацию обрабатываемых данных сторонними сессиями, 
однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк 
данных (обычно используется наименование VERSION и целочисленный тип с инициальным значением 0). 
Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, 
то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута 
не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута 
(например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.

**Пессимистическая блокировка** — накладывается перед предполагаемой модификацией данных на все строки, 
которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных 
из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. 
По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.

[к оглавлению](#SQL)

## Как вы понимаете DDL и DML выражения

**Data Definition Language (DDL) (язык описания данных)** — это семейство компьютерных языков, используемых в компьютерных 
программах для описания структуры баз данных. Функции языков DDL определяются первым словом в предложении (часто называемом запросом), 
которое почти всегда является глаголом. В случае с SQL это глаголы — «create» («создать»), «alter» («изменить»), «drop» («удалить»).

**Data Manipulation Language (DML) (язык управления (манипулирования) данными)** — это семейство компьютерных языков, 
используемых в компьютерных программах или пользователями баз данных для получения, вставки, удаления или изменения данных 
в базах данных. Функции языков DML определяются первым словом в предложении (часто называемом запросом), 
которое почти всегда является глаголом. В случае с SQL эти глаголы — «select» («выбрать»), «insert» («вставить»), 
«update» («обновить»), и «delete» («удалить»). Это превращает природу языка в ряд обязательных утверждений (команд) к базе данных.

[к оглавлению](#SQL)

## Какая разница между javautilDate и javasqlDate

java.util.Date содержит информацию о дате и времени, тогда как java.sql.Date содержит информацию только о дате, 
но не имеет информации о времени. Если необходимо сохранить информацию о времени в базе данных, 
то желательно использовать поля Timestamp или DateTime.

Java.util.Date — основной универсальный объект. В нем просто сохраняется дата (как long).

java.sql.Date расширяет java.util.Date и добавляет следующую функциональность:

1) toString выводит дату в качестве «yyyy-mm-dd», а не как у конкретного языкового стандарта строки (локали).

2) Добавлен метод valueOf для чтения строк формата «yyyy-mm-dd» и дальнейшего разбора ее в объект sql.Date.

[к оглавлению](#SQL)

## Как вставить изображение или необработанные данные в базу данных

Для этого можно использовать тип данных BLOB, чтобы вставить картинку или двоичные данные в базу данных.

[к оглавлению](#SQL)

## Что вы можете рассказать о фантомном чтении Какой уровень изоляции его предотвращает

Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк. 
Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20); | |
|  COMMIT; | |
| | SELECT SUM(f2) FROM tbl1; |

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка 
новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. 
Такая ситуация называется фантомным чтением. От неповторяющегося чтения оно отличается тем, что результат повторного 
обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.
Phantom read можно предотвратить только на уровне изоляции — TRANSACTION_SERIALIZABLE.

[к оглавлению](#SQL)

## Что такое SQL Warning Как возвратить SQL предупреждения в JDBC программе

SQLWarning это подкласс SQLException, который мы можем получить вызвав метод getWarnings() у объектов Connection, 
Statement, ResultSet. SQL Предупреждения не останавливает выполнение запроса, но показывает предупреждающие сообщения 
для пользователя.

[к оглавлению](#SQL)

## Как запустить Oracle Stored Procedure с объектами базы данных INOUT

Если хранимая процедура Oracle содержит IN / OUT параметры как DB объекты, то мы должны создать массив объектов такого 
же размера в программе, а затем использовать его для создания Oracle STRUCT объекта. Тогда мы можем установить этот 
STRUCT объект в объект базы данных, вызвав метод setSTRUCT().

[к оглавлению](#SQL)

## Приведите пример возникновения javasqlSQLException: No suitable driver found

Исключение java.sql.SQLException: No suitable driver found может быть вызвано, например, неправильно отформатированной 
строкой SQL-адреса. Вы можете получить это исключение в простом Java приложении как через DriverManager, 
так и используя JNDI DataSource. Трассировка стека исключений приведена ниже:
```java
org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot create JDBC driver of class 'com.mysql.jdbc.Driver' for connect URL ''jdbc:mysql://localhost:3306/UserDB'
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1452)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)
 
 
java.sql.SQLException: No suitable driver found for 'jdbc:mysql://localhost:3306/UserDB
    at java.sql.DriverManager.getConnection(DriverManager.java:604)
    at java.sql.DriverManager.getConnection(DriverManager.java:221)
    at com.journaldev.jdbc.DBConnection.getConnection(DBConnection.java:24)
    at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:15)
Exception in thread "main" java.lang.NullPointerException
```
[к оглавлению](#SQL)

## Best Practices в JDBC

Некоторые Best Practices в JDBC:

+ Всегда закрывайте ресурсы базы данных сразу после работы с ними. Connection, Statement, ResultSet и другие JDBC объекты имеют метод close(), который позволяет закрыть их.
+ Всегда явно закрывайте результирующий набор ResultSet, Statement и Connection в коде, потому что если вы используете пул соединений, то соединение может быть возвращено в пул, оставляя открытые result sets и statement objects и будет происходить утечка.
+ Закрывайте ресурсы в конце finally блока, чтобы убедиться, что они закрыты даже в случае возникновения исключения.
+ Используйте пакетную обработку (batch processing) для повторяющихся запросов.
+ Всегда используйте PreparedStatement вместо Statement, чтобы избежать SQL Injection и получить преимущества заранее прекомпилированного и кэшированного запроса PreparedStatement.
+ Если вы извлекаете большие массивы данных в result set, то заранее установите оптимальное значение fetchSize, что поможет получить лучшую производительность.
+ Сервер базы данных может не поддерживать все уровни изоляции, так что проверьте их заранее.
+ Более строгие уровни изоляции могут привести к снижению производительности, поэтому убедитесь, что вы используете оптимальный набор уровней изоляции для ваших соединений с базой данных.
+ Если вы создаете подключения к базе данных из веб-приложения, попробуйте использовать ресурсы JDBC DataSource с помощью применения контекста JNDI для возможности повторного использования соединений.
+ Попробуйте использовать отключенный (disconnected) RowSet, когда вам нужно работать с ResultSet в течение длительного времени.

[к оглавлению](#SQL)  
 
  

   





 
 
  
  



