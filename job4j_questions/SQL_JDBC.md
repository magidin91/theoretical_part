## SQL, Jdbc  

+ прочитать этот туториал при возможности - [sql-туториал](http://www.sql-tutorial.ru/ru/content.html)       
acid 
**SQL:**
+ [Общее](#Общее)
+ [CREATE](#CREATE) 
+ [INSERT](#INSERT) 
+ [SELECT](#SELECT) 
+ [Alter](#Alter) 
+ [Команды PostgreSQL](#Команды-PostgreSQL)
+ [Ограничения столбцов и таблиц](#КОграничения-столбцов-и-таблиц)
+ [Что такое первичный ключ?](#Что-такое-первичный-ключ)
+ [Что такое внешний ключ?](#Что-такое-внешний-ключ)
+ [Что такое нормализация БД?](#Что-такое-нормализация-БД)
+ [Что такое денормализация БД?](#Что-такое-денормализация-БД)
+ [Что такое кластерный и некластерный индекс?](#Что-такое-кластерный-и-некластерный-индекс) 
+ [Что такое SQL курсор?](#Что-такое-SQL-курсор)  
+ [Опишите шаги по созданию и использованию курсора?](#Опишите-шаги-по-созданию-и-использованию-курсора) 
+ [Что такое подзапрос (sub-query)?](#Что-такое-подзапрос)
+ [Какие типы соединений (join) таблиц существуют? В чем их разница?](#Какие-типы-соединений-(join)-таблиц-существуют-В-чем-их-разница)
+ [Что такое group by](#Что-такое-group-by)
+ [Что такое HAVING? Разница с Where?](#Что-такое-HAVING-Разница-с-Where)  
+ [Другие запросы: Distinct, Count](#Другие-запросы-Distinct-Count)
+ [Составные типы данных](#Составные-типы-данных)
+ [Множества: Union, EXCEPT, INTERSECT](#Множества-Union-EXCEPT-INTERSECT)
+ [Что такое транзакция?](#Что-такое-транзакция)
+ [Требования ACID к СУБД](#Требования-ACID-к-СУБД)   
+ [Что такое хранимые процедуры?](#Что-такое-хранимые-процедуры)
+ [Что такое триггер? (Какие типы триггеров вы знаете?)](#Что-такое-триггер-Какие-типы-триггеров-вы-знаете))  
+ [Что такое view](#Что-такое-view)
+ [Для чего используется конструкция try-with-resources](КДля-чего-используется-конструкция-try-with-resources)
+ [Опишите процесс создания запроса через JDBC](#Опишите-процесс-создания-запроса-через-JDBC)
+ [Дполнительно](#Дополнительно)


## Общее:  
Реляционные базы хранят данные в таблицах, в которых строки соответствуют записям, а колонки полям.  
  
**Типы данных:**   
+ dec - хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков в дробной части.
То же самое, что и numeric. Данный тип может принимать два параметра precision и scale: numeric(precision, scale).
Параметр precision указывает на максимальное количество цифр, которые может хранить число.
Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой.   
Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.    
+ real: хранит числа с плавающей точкой из диапазона от 1E-37 до 1E+37. Занимает 4 байта. Имеет псевдоним float4.  
+ double precision: хранит числа с плавающей точкой из диапазона от 1E-307 до 1E+308. Занимает 8 байт. Имеет псевдоним float8.  
+ Тип boolean может хранить одно из двух значений: true или false.      

[к оглавлению](#SQL-Jdbc)       

## CREATE  
Создать таблицу:    
create table students (id serial primary key, name varchar(20), birth_date timestamp);  
**Создание таблицу с Внешним ключом**  
CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER, Quantity INTEGER, FOREIGN KEY (CustomerId) REFERENCES Customers (Id));  
или CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER REFERENCES Customers (Id), Quantity INTEGER); 
+ **Создать таблицу на основании указанных столбцов другой таблицы**
create table people_new as Select name, age, passport from people;  
Не только создает структуру, но и копирует данные.  

[к оглавлению](#SQL-Jdbc)    

## INSERT  
insert into students values (1, 'Ivan', '2009-06-04'), (2, 'Petr', '2009-06-04');  
Можно указать конкретные столбцы:  
insert into students (name, birth_date) values ('Ivan', '2009-06-04'), ('Petr', '2009-06-04');  
При вставке можно посмотреть значения тех столбцов, которые мы не указываем при вставке, например первичного ключа. 
insert into students (name, birth_date) values ('Ivan', '2009-06-04') RETURNING id; 
+ **INSERT с SELECT**  (вставить)  
INSERT INTO profession (profession)  SELECT  profession  FROM  my_contacts;  
Т.е. мы вставляем записи из столбца profession таблицы my_contacts в столбец profession таблицы profession.    
+ **ON CONFLICT DO NOTHING**  
Если, например, поле name задано Unique, то при обычной вставке дублирующего значения, произойдет ошибка.
Чтобы этого избежать можно использовать условие ON CONFLICT DO NOTHING/UPDATE. В этом случае вставка не произойдет, 
но и не будет выдано никакое сообщение об ошибке.    
Конструкция DO UPDATE SET обновляет поля, которые в ней указаны.    
INSERT INTO account (id, name, surname, address) VALUES (1, 'Петя', 'Петров', 'Москва, Кремль') 
ON CONFLICT (id) DO UPDATE SET name='Петя', surname='Петров';  
[подробнее](https://habr.com/ru/post/264281/)  

[к оглавлению](#SQL-Jdbc)    
  
##  SELECT  
Where (AND, OR, <>,<=, IS NULL, LIKE+ % и _ , BETWEEN, IN, NOT IN)    
Для фильтрации данных применяется оператор WHERE, после которого указывается условие, на основании которого производится фильтрация.
Если условие истинно, то строка попадает в результирующую выборку.  
<>: сравнение на неравенство - не равно  
В качестве условия могут использоваться и более сложные выражения. Например, найдем все товары, у которых совокупная стоимость больше 90 000: 
SELECT * FROM Products WHERE Price * ProductCount > 90000;  

+ **AND, OR, NOT**  
SELECT * FROM Products WHERE Manufacturer = 'Samsung' AND Price > 50000;    
SELECT * FROM Products WHERE Manufacturer = 'Samsung' OR Price > 50000;  
Применение оператора NOT - выберем все товары, у которых производитель не Samsung:  
SELECT * FROM Products WHERE NOT Manufacturer = 'Samsung';  
Но в большинстве случаев можно обойтись без оператора NOT. Предыдущий пример мы можем переписать следующим образом:  
SELECT * FROM Products WHERE Manufacturer <> 'Samsung'  
Также в одной команде SELECT можно использовать сразу несколько операторов:
SELECT * FROM Products WHERE Manufacturer = 'Samsung' OR Price > 30000 AND ProductCount > 2;  
Так как **оператор AND имеет более высокий приоритет**, то сначала будет выполняться 
подвыражение Price > 30000 AND ProductCount > 2, и только потом оператор OR. (То есть здесь выбираются товары, 
которыех на складе больше 2 и у которых одновременно цена больше 30000, либо те товары, производителем которых является Samsung.)  
С помощью скобок мы также можем переопределить порядок операций:  
SELECT * FROM Products WHERE (Manufacturer = 'Samsung' OR Price > 30000) AND ProductCount > 2;    

+ **IS NULL**  
Для проверки на наличие Null применяется оператор IS NULL.  
SELECT * FROM Products WHERE ProductCount IS NULL;  
Если, наоборот, необходимо получить строки, у которых поле ProductCount не равно NULL, то можно использовать оператор NOT:  
SELECT * FROM Products WHERE ProductCount IS NOT NULL;  
[подробнее](https://metanit.com/sql/postgresql/3.3.php)  

**Операторы сравнения при поиске текстовых данных** 
+ **LIKE**   
Ключевое слово LIKE, которое в сочетании со специальными символами ищет часть текстовой строки и возвращает совпадения.  
SELECT * FROM my_contacts Where location LIKE '%CA’;  
**Знак %** говорит, что мы ищем все значения локэйшен, которые заканчиваются на СА. Знак % — обозначает любое количество произвольных символов.
Также можно использовать %часть слова%, если ищем часть в середине слова.  
**Знак подчеркивания (_)** — представляет ровно один произвольный символ.  
SELECT first_name FROM my_contacts Where first_name LIKE '_им';
Запрос возвращает имена, которые со стоят из одной буквы + ≪иМ≫: KиM,  ТиМ и т.д.  

**Проверка вхождения значений в диапазон**  
**Обычный вариант**  
SELECT drink_name FROM drink_info WHERE calories>= 30  AND calories<= 60;  

+ **BETWEEN**  
Конструкция BETWEEN эквивалентна использованию операторов <= и >=, но не < и >.  
SELECT drink_name FROM drink_info WHERE calories BETWEEN 30 AND 60; - [30, 60]  
SELECT drink_name FROM drink_info WHERE drink_name BETWEEN 'Д ' AND 'O';  
Запрос возвращает названия всех напитков, начинающихся с Д, заканчивающихс О и всех букв между ними.  

+ **IN (совпадает со значением из набора)**   
После IN следует набор значений в круглых скобках. Если значение столбца совпадает с одним из значений набора, 
то запись или заданное подмножество столбцов включаются в результат запроса.  
SELECT date_name FROM black_book WHERE rating IN ('оригинально', 'потрясающе', 'неплохо');  
NOT IN (не входит в набор значений)  
SELECT date_name FROM black_book WHERE rating NOT IN ('оридтинально', 'потрясающе', ’неплохо’);   

+ **Другие применения NOT**  
Ключевое слово NOT может использоваться не только с IN, но и с BETWEEN и LIKE. Однако необходимо помнить, что NOT следует сразу же после WHERE.  
SELECT drink_name FROM drink_info WHERE NOT carbs BETWEEN 3 AND 5;  
Если ключевое слово Not используется с And или Or, оно записывается после And или Or.  
SELECT date_name FROM black_book WHERE date_name LIKE 'A%' and NOT date name LIKE 'E%';  

+ **Получение части строки**  
**Right, Left**  
Для выделения заданного количества символов в столбце используются функции RIGHT() и LEFT();  
SELECT RIGHT (location , 2) FROM my_contacts;  
Функция выделяет два последних символа из столбца location;
  
+ **SUBSTRING**  
Функция SUBSTRING(выражение, начальная позиция, длина) позволяет извлечь из выражения его часть заданной длины, 
начиная от заданной начальной позиции. Выражение может быть символьной или бинарной строкой, а также иметь тип text или image.  
Например, если нам потребуется получить три символа в названии корабля, начиная со второго символа:
SELECT name, SUBSTRING(name, 2, 3) FROM Ships; (выведет столбец name и столбец SUBSTRING)  
+ **SUBSTR**  
Команда SUBSTR (interests , LENGTH (interest1) +2) возвращает часть строки interest1, отрезав от нее левую часть указанной длины.
UPDATE my_contacts SET interests = SUBSTR (interest, LENGTH (interest1)+2);  

+ **AS**  
С помощью оператора AS можно изменить название выходного столбца или определить его псевдоним:  
SELECT ProductCount AS Title, Manufacturer, Price * ProductCount  AS TotalSum FROM Products;  

[к оглавлению](#SQL-Jdbc)  

## Alter
**Добавление нового столбца**  
ALTER TABLE Customers ADD Phone CHARACTER VARYING(20);  
**Удаление столбца**    
ALTER TABLE Customers DROP COLUMN Address;    
**Изменение типа столбца** 
Для изменения типа применяется ключевое слово TYPE.  
ALTER TABLE Customers ALTER COLUMN FirstName TYPE VARCHAR(50);  
**Изменение ограничений столбца**  
Для добавления ограничения применяется оператор SET, после которого указывается ограничение. 
Например, установим для столбца FirstName ограничение NOT NULL:  
ALTER TABLE Customers ALTER COLUMN FirstName SET NOT NULL;  
**Для удаления ограничения применяется оператор DROP**, после которого указывается ограничение. 
Например, удалим выше установленное ограничение:  
ALTER TABLE Customers ALTER COLUMN FirstName DROP NOT NULL;  
**Изменение ограничений таблицы**    
Добавление первичного ключа PRIMARY KEY:  
ALTER TABLE Customers ADD PRIMARY KEY (cust_id);  
Добавление ограничение UNIQUE - определим для столбца Email уникальные значения:  
ALTER TABLE Customers ADD UNIQUE (Email);  
Мы можем явным образом назначить ограничению при добавлении имя с помощью оператора CONSTRAINT.  
ALTER TABLE Customers ADD CONSTRAINT phone_unique UNIQUE (Phone);  
**Удалить ограничение**  
Чтобы удалить ограничение, надо знать его имя:  
ALTER TABLE Customers DROP CONSTRAINT phone_unique;  
**Переименование столбца и таблицы**  
Переименуем столбец Address в City:  
ALTER TABLE Customers RENAME COLUMN Address TO City;  
Переименуем таблицу Customers в Users:  
ALTER TABLE Customers RENAME TO Users;  
[подробнее](https://metanit.com/sql/postgresql/2.6.php)   
  
+ Limit и offset  
Выбрать **limit** записей, начиная с **(offset+1)**-ой:  
SELECT* FROM students LIMIT 10 OFFSET 14; (получим 10 записей, начиная с 15-ой)  
offset - это смещение, т.е. чтобы получить вторую запись, а не первую  offset = 1    

+ Значение по умолчанию в столбце таблицы    
CREATE TABLE shop_goods (id serial primary key, cost DEC(3,2) NOT NULL DEFAULT 1.00);  
cost - Этот столбец ВСЕГДА должен содержать значение. Для этого мы не только объявляем его с ключевыми словами NOT NULL, но и присваиваем значение по умолчанию 1.00  

[к оглавлению](#SQL-Jdbc)  

## Ограничения столбцов и таблиц 
+ **UNIQUE**  
Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут UNIQUE  
CREATE TABLE Customers (Id SERIAL, FirstName varchar(30) UNIQUE );  
В данном случае FirstName будет иметь уникальное значение. И мы не сможем добавить в таблицу две строки,
у которых значения для этих столбцов будет совпадать.  
Также мы можем определить этот атрибут на уровне таблицы:  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY, Email varchar(30), Phone varchar(30), Age INTEGER, UNIQUE(Email, Phone));  
или: CREATE TABLE Customers (Id SERIAL PRIMARY KEY, Email varchar(30), Phone varchar(30), Age INTEGER,  UNIQUE(Email), UNIQUE(Phone));  
+ **CHECK**   
Ключевое слово CHECK задает ограничение для диапазона значений, которые могут храниться в столбце.
Для этого после слова CHECK указывается в скобках условие, которому должен соответствовать столбец.  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY,
Age INT CHECK(Age >0 AND Age < 100),  
Email VARCHAR(30) CHECK(Email !=''),   
Phone VARCHAR(20) UNIQUE CHECK(Phone !=''));  
+ **CONSTRAINT**  
С помощью ключевого слова CONSTRAINT можно задать имя для ограничений. В качестве ограничений могут использоваться **PRIMARY KEY, UNIQUE, CHECK**.
Необязательно задавать имена ограничений, но, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.  
CREATE TABLE Customers (   
Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,
Email VARCHAR(30) CONSTRAINT customers_email_key UNIQUE,
Phone VARCHAR(20) CONSTRAINT customers_phone_key UNIQUE); 
Мы задали названия: customer_Id, customers_email_key, customers_phone_key.    
И также можно задать все имена ограничений через атрибуты таблицы:  
CREATE TABLE Customers ( Id SERIAL, Age INTEGER, Email VARCHAR(30), Phone VARCHAR(20),  
CONSTRAINT customer_Id PRIMARY KEY(Id),  
CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),  
CONSTRAINT customers_email_key UNIQUE(Email),  
CONSTRAINT customers_phone_key UNIQUE(Phone));  

[к оглавлению](#SQL-Jdbc) 

## UPDATE/DELETE  
**UPDATE**  
Например, увеличим у всех товаров цену на 3000:  
UPDATE Products SET Price = Price + 3000;  
В данном случае обновление касается всех строк.
С помощью выражения WHERE можно с помощью условию конкретизировать обновляемые строки:  
UPDATE Products SET Manufacturer = 'Samsung Inc.' WHERE Manufacturer = 'Samsung';  
Также можно обновлять сразу несколько столбцов:  
UPDATE Products SET Manufacturer = 'Samsung', ProductCount = ProductCount + 3 WHERE Manufacturer = 'Samsung Inc.';

**DELETE**     
Например, удалим строки, у которых производитель - Apple:
DELETE FROM Products WHERE Manufacturer='Apple';  
Если необходимо вовсе удалить все строки вне зависимости от условия, то условие можно не указывать:  
DELETE FROM Products;  

[к оглавлению](#SQL-Jdbc)    
  
## Что такое первичный ключ?  
С помощью выражения PRIMARY KEY столбец можно сделать первичным ключом. Первичный ключ - ункиальный идентификатор строки в таблице.
В качестве первичного ключа необязательно должны выступать столбцы с типом SERIAL, они могут представлять любой другой тип.  
CREATE TABLE Customers (Id SERIAL PRIMARY KEY);  
CREATE TABLE Customers (Id SERIAL, FirstName varchar(30), **PRIMARY KEY(Id)**);  
**Первичный ключ может быть составным** (compound key).
Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать строку в таблице:  
CREATE TABLE OrderLines (OrderId INTEGER, ProductId INTEGER, Quantity INTEGER, PRIMARY KEY (OrderId, ProductId));  

[к оглавлению](#SQL-Jdbc)  

## Что такое внешний ключ?  
**Внешний ключ SQL — это ключ, используемый для объединения данных двух таблиц.**
Часто информация об объекте распределена по нескольким таблицам, внешний ключ обеспечивает возможность получить полную информацию об объекте.   
Внешний ключ устанавливается для столбца из зависимой, 
подчиненной таблицы (referencing table), и указывает на один из столбцов из главной таблицы (обычно на первичный ключ). 
Т.е. внешний ключ - это поле значение, которого равно конкретному значению первичного ключа другой таблицы, 
тем самым мы можем понять, какая запись главной таблицы соответствует полю внешнего ключа.    
Внешний ключ – это ограничение, которое поддерживает согласованное состояние данных между двумя таблицами, 
обеспечивая так называемую ссылочную целостность. **Этот тип целостности означает,
что всегда есть возможность получить полную информацию об объекте, распределенную по нескольким таблицам.**  
Т.е. таким образом мы можем разделить информацию об объекте на неск. таблиц, например,
из таблицы с заказами вынести поля покупателя и заказанного продукта в отдельные таблицы.  
Определение внешнего ключа на уровне таблицы выглядело бы следующим образом:    
CREATE TABLE Customers ( Id SERIAL PRIMARY KEY, Age INTEGER,  FirstName VARCHAR(20) NOT NULL);  
CREATE TABLE Orders (Id SERIAL PRIMARY KEY, CustomerId INTEGER, Quantity INTEGER, FOREIGN KEY (CustomerId) REFERENCES Customers (Id));  
 
**ON DELETE и ON UPDATE**     
С помощью выражений ON DELETE и ON UPDATE можно установить действия, 
которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы:  
+ CASCADE: автоматически удаляет/изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.
+ RESTRICT: предотвращает какие-либо действия в зависимой таблице при удалении/изменении связанных строк в главной таблице.
То есть фактически какие-либо действия отсутствуют.
NO ACTION: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице.
**И генерирует ошибку.** В отличие от RESTRICT выполняет отложенную проверку на связанность между таблицами.
+ SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.
+ SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. 
Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL.  
[подробнее](https://metanit.com/sql/postgresql/2.5.php)
[подробнее](http://www.sql-tutorial.ru/ru/book_foreign_key.html)  

[к оглавлению](#SQL-Jdbc)  

## Что такое нормализация БД?  
Нормализация - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам. 
Нормальные формы - это линейная последовательность правил, применяемых к БД, причем чем выше номер нормальной формы,
тем совершеннее структура БД.  
Нормализация - это  процесс, при котором таблицы БД организуются, разъединяются и данные приводятся в порядок.
**Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, 
возникающих при добавлении, редактировании и удалении строк таблицы.** 
Аномалии изменения данных - это сложности при операциях вставки, изменения и удаления данных, возникающие из-за структуры БД. 
Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, 
и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. 
**Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.**
Хотя существует много уровней, обычно достаточно выполнить нормализацию до Третьей нормальной формы (3НФ).  

В ненормализованной форме таблица может хранить информацию о двух и более сущностях. 
Также она может содержать повторяющиеся столбцы. Также столбцы могут хранить повторяющиеся значения.
В нормализованной же форме каждая таблица хранит информацию только об одной сущности.  
Здесь атрибут Teacher функционально зависит от атрибута Course (Course → Teacher).
То есть зная название курса, мы можем определить его преподавателя. 
И в этом случае можно говорить, что между атрибутами Course и Teacher есть связь 1:1,
а между Teacher и Course связь 1:N, так как есть несколько курсов, которые может вести один преподаватель.
При этом атрибут Course функционально не зависит от атрибута Teacher.
Функциональная зависимость описывает связь между атрибутами отношения. 
Например, если атрибут В функционально зависит от атрибута А (А → В), то каждое значение атрибута А связано только с одним значением атрибута В.  
В таблице в нормализованной базе данных единственным детерминантом должен быть атрибут, 
который является первичным ключом. А все остальные атрибуты должны функционально зависеть от первичного ключа. 
 
+ Первая нормальная форма предполагает, что таблица не должна содержать повторяющихся столбцов или таких столбцов, которые содержат наборы значений **(атомарность данных)**.
+ Вторая нормальная форма предполагает применяется к тем таблицам, которые имеют составной первичный ключ,
то есть где первичный ключ состоит из нескольких атрибутов.  
**Во второй нормальной форме каждый столбец в таблице, который не является ключом, должен полностью функционально зависеть от ключа.**
**(По первчиному ключу можно определить любой стоблец - они полностью функционально зависят от него, но они все еще могут зависеть друг от друга)**
Если в таблице несоставной первичный ключ, то в этом случае считается, 
что все остальные атрибуты автоматически находятся в полной функциональной зависимости от первичного ключа.  
То есть, если атрибут А составляют несколько значений, скажем, А1 и А2, то атрибут В полностью функционально зависит от А, если он зависит и от А1 и от А2 (А1, А2 → В).
**Если атрибут В зависит только от какого-либо подмножества из атрибута А, например, только от А1, то имеет место частичная функциональная зависимость. 
(чтобы этого избежать обычно таблица разъединяется)**    
+ Третья нормальная форма предполагает, что каждый столбец, не являющийся ключом, должен зависеть только от столбца, 
который является ключом, то есть должна отсутствовать транзитивная функциональная зависимость. **(исключается зависимость столбцов друг от друга)** 
Транзитивная функциональная зависимость выражается следующим образом: А → В и В → С. 
То есть атрибут С транзитивно зависит от атрибута А, если атрибут С зависит от атрибута В,
а атрибут В зависит от атрибута А (при условии, что атрибут А функционально не зависит ни от атрибута В, ни от атрибута С).
Если столбец зависит не только от первичного ключа, то данный столбец находится не в той таблице,
в которой он должен находиться, либо же является производным от других столбцов.  
Для нормализации из исходной таблицы те атрибуты, которые находятся в транзитивной зависимости от ключа, 
выносятся в отдельную таблицу с копией того атрибута, от которого они непосредственно зависят. 
[подробнее](https://metanit.com/sql/tutorial/2.1.php)
[к оглавлению](#SQL-Jdbc)   

## Что такое денормализация БД? 
Это намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации,
обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.

Добавление "избыточных" данных делается с целью:  
+ Для сохранения истории.  
+ Повышение производительности запросов за счет экономии на объединениях.  
+ Предварительные вычисления часто запрашиваемых значений.    
[к оглавлению](#SQL-Jdbc)  

## Что такое кластерный и некластерный индекс?  
Индекс – это средство, обеспечивающее быстрый доступ к **строкам** таблицы на основе значений одного или нескольких столбцов.  
Индекс — это и есть отсортированный набор значений.  
В самом простом случае, индекс необходимо создавать для тех колонок, которые присутствуют в условии WHERE, ORDER BY  
Рассмотрим запрос из примера:  
SELECT * FROM users WHERE age = 29  
Нам необходимо создать индекс на колонку age:  
CREATE INDEX age ON users(age);  

id | name   | age  
1  | Den    | 29  
2  | Alyona | 15  
3  | Putin  | 89  
4  | Petro  | 12    
После создания индекса на колонку age, MySQL сохранит все ее значения в отсортированном виде.
Кроме этого, будет сохранена связь между значением в индексе и записью, которой соответствует это значение. 
Обычно для этого используется первичный ключ.  
  
age index и связь с записями  
12: 4    
15: 2    
29: 1    
89: 3  

Кла́стер (англ. cluster — скопление, кисть, рой) — объединение нескольких однородных элементов, которое может рассматриваться как самостоятельная единица, 
обладающая определёнными свойствами.    

Кластерные индексы  
Обычные индексы являются некластерными. Это означает, что сам индекс хранит только ссылки на записи таблицы.
Когда происходит работа с индексом, определяется только список записей (точнее список их первичных ключей),
подходящих под запрос. После этого происходит еще один запрос — для получения данных каждой записи из таблицы по индексу.  

Кластерный индекс (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде, а данные всей строки.
При работе с таким индексом не требуется дополнительной операции чтения данных.  
При использовании кластерного индекса строки таблицы сортируются по столбцу, к которому применяется кластерный индекс.
Поэтому в таблице может быть только один кластерный индекс, потому что вы не можете упорядочить таблицу двумя разными столбцами.  
CREATE CLUSTERED INDEX ix_employees_name ON Employees(Employee_Surname);  
[подробнее](https://riptutorial.com/ru/sql/example/13009/%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81)  
[подробнее](https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql)  

[к оглавлению](#SQL-Jdbc)   

## Что такое SQL курсор?  
Курсор — это указатель на эту контекстную область.
SQL управляет контекстной областью с помощью курсора. 
Курсор содержит строки (одну или несколько), возвращаемые оператором SQL. Набор строк, которые содержит курсор, называется активным набором.
Вы можете назвать курсор так, чтобы на него можно было ссылаться в программе для выборки и обработки строк, возвращаемых оператором SQL, по одной за раз.
Явные курсоры являются программируемыми курсорами для получения большего контроля над областью контекста.  
"Курсор (current set of record) – временный набор строк, которые можно перебирать последовательно, с первой до последней."  
[подробнее](https://coderlessons.com/tutorials/bazy-dannykh/izuchite-pl-sql/pl-sql-kursory)  
[к оглавлению](#SQL-Jdbc)  

## Опишите шаги по созданию и использованию курсора?  
При работе с курсорами используются следующие команды.
+ **Объявление курсора**: 
DECLARE имя_курсора CURSOR FOR SELECT текст_запроса
Любой курсор создается на основе некоторого оператора SELECT.
+ **Открытие курсора**:
OPEN имя_курсора
Для того чтобы с помощью курсора можно было читать строки, его надо обязательно открыть.
+ **Чтение следующей строки из курсора**:
FETCH имя_курсора INTO список_переменных  
Выборка курсора вовлекает доступ к одной строке за один раз.
Переменные в списке должны быть в том же количестве и того же типа, что и столбцы курсора. 
Глобальная переменная @@FETCH_STATUS принимает ненулевое значение, если строк в курсоре больше нет. Если же набор строк еще не исчерпан, 
то @@FETCH_STATUS равна нулю, и оператор FETCH перепишет значения полей из текущей строки в переменные. 
+ **Закрытие курсора**:
CLOSE имя_курсора
+ Для **удаления курсора из памяти** используется команда 
DEALLOCATE имя_курсора

Для иллюстрации использования курсора создадим процедуру, которая будет выбирать данные из одной таблицы, 
перебирать их в курсоре анализируя, есть ли такие данные во второй таблице и вставлять в третью таблицу, 
если данные записи удовлетворяют определённым критериям.
```sql
CREATE PROCEDURE [dbo].[MyProcedure] AS

DECLARE @ID INT
DECLARE         @QUA INT
DECLARE @VAL VARCHAR (500)
DECLARE @NAM VARCHAR (500)
/*Объявляем курсор*/
DECLARE @CURSOR CURSOR
/*Заполняем курсор*/
SET @CURSOR  = CURSOR SCROLL
FOR
SELECT  INDEX, QUANTITY, VALUE,  NAME  
  FROM  My_First_Table WHERE  QUANTITY > 1
/*Открываем курсор*/
OPEN @CURSOR
/*Выбираем первую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
/*Выполняем в цикле перебор строк*/
WHILE @@FETCH_STATUS = 0
BEGIN

        IF NOT EXISTS(SELECT VAL FROM My_Second_Table WHERE ID=@ID)
        BEGIN
/*Вставляем параметры в третью таблицу если условие соблюдается*/
                INSERT INTO My_Third_Table (VALUE, NAME) VALUE(@VAL, @NAM)
        END
/*Выбираем следующую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
END
CLOSE @CURSOR
```  

[к оглавлению](#SQL-Jdbc) 
      
## Что-такое-подзапрос?  
Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы.  
Это запрос, который выполнится перед основным и результаты которого будут данными,
из которых будет производиться дальнейшая обработка основным запросом.  
Подзапросы могут также выполняться и к той же таблице, к которой вызывается основной запрос:  
Например, найдем товары, которые имеют минимальную цену:    
SELECT * FROM Products WHERE Price = (SELECT MIN(Price) FROM Products);  
**Коррелирующие подзапросы**  
Коррелирующие подзапросы - запросы, результаты которых зависят от строк, которые извлекаются в основном запросе.  
Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре:  
SELECT  CreatedAt, Price, (SELECT ProductName FROM Products WHERE Products.Id = Orders.ProductId) AS Product FROM Orders;    
Здесь для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId.
И каждый подзапрос может возвращать различные данные.  
Часто можно заменить на join. 
[подробнее](https://metanit.com/sql/postgresql/4.7.php)

[к оглавлению](#SQL-Jdbc)  
## Какие типы соединений (join) таблиц существуют? В чем их разница?  
## Добавить картинку
Нередко возникает ситуация, когда нам надо получить данные из нескольких таблиц, для этого можно применять JOIN-ы.  
+ **INNER JOIN** (JOIN) 
SELECT столбцы FROM таблица1 [INNER] JOIN таблица2 ON условие1 [[INNER] JOIN таблица3 ON условие2];  
Как правило, для соединения применяется первичный ключ главной таблицы и внешний ключ зависимой таблицы.  
Выбираются только совпадающие данные из объединяемых таблиц.   
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName FROM Orders  
JOIN Products ON Products.Id = Orders.ProductId  
JOIN Customers ON Customers.Id=Orders.CustomerId;  
Получим заказ с информацией о покупателе из таблицы Customers и о продукте из таблицы Products.  
Условия после ключевого слова ON могут быть более сложными по составу.
Например, выбирем все заказы на товары, производителем которых является Apple:  
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName FROM Orders  
JOIN Products **ON Products.Id = Orders.ProductId AND Products.Company='Apple'**  
JOIN Customers ON Customers.Id=Orders.CustomerId ORDER BY Customers.FirstName;    
+ **Cross Join**(перекрестное соединение)  
Перекрестное соединение создает набор строк, где каждая строка из одной таблицы соединяется с каждой строкой из второй таблицы. 
Например, соединим таблицу заказов Orders и таблицу покупателей Customers:  
SELECT * FROM Orders CROSS JOIN Customers;  
Если в таблице Orders 3 строки, а в таблице Customers то же три строки,
то в результате перекрестного соединения создается 3 * 3 = 9 строк вне зависимости, связаны ли данные строки или нет.  
Также можно опустить оператор CROSS JOIN: SELECT * FROM Orders, Customers;  
+ **OUTER JOIN**  
SELECT столбцы FROM таблица1 {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1 [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]  
Такое объединение вернет данные из обеих таблиц (совпадающие по условию объединения)
ПЛЮС дополнит выборку оставшимися данными из внешней таблицы, которые по условию не подходят, заполнив недостающие данные значением NULL.    
LEFT: выборка будет содержать все строки из первой или левой таблицы  
RIGHT: выборка будет содержать все строки из второй или правой таблицы  
FULL: выборка будет содержать все строки из обеих таблиц  
После JOIN указывается присоединяемая таблица, а затем идет условие соединения после оператора ON.  
Left Join выбирает все строки первой таблицы и затем присоединяет к ним строки правой таблицы.  
SELECT FirstName, CreatedAt, ProductCount, Price FROM Customers LEFT JOIN Orders ON Orders.CustomerId = Customers.Id;  
Этот запрос выбирает все строки из таблицы Customers, затем дополняет их строками из таблицы Orders по условию ON Orders.CustomerId = Customers.Id,
если же для строки Customers не найдено соответствие по условию, эти поля будут заполнены NULL.  
Удобно использовать, если нужно посмотреть **обязательно все* объекты таблицы, плюс дополнительную информацию из связанных таблиц.  
SELECT Customers.FirstName, Orders.CreatedAt,  Products.ProductName, Products.Company FROM Orders   
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id  
LEFT JOIN Products ON Orders.ProductId = Products.Id;  
И также можно применять более комплексные условия с фильтрацией и сортировкой. 
Например, выберем все заказы с информацией о клиентах и товарах по тем товарам, у которых цена больше 55000, и отсортируем по дате заказа:  
SELECT Customers.FirstName, Orders.CreatedAt, Products.ProductName, Products.Company FROM Orders   
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id  
LEFT JOIN Products ON Orders.ProductId = Products.Id  
WHERE Products.Price > 55000 ORDER BY Orders.CreatedAt;  
**Или выберем только тех пользователей из Customers, у которых нет заказов в таблице Orders: (т.е. тех, для которых нет совпадения)**:  
**SELECT FirstName FROM Customers LEFT JOIN Orders ON Customers.Id = Orders.CustomerId WHERE Orders.CustomerId IS NULL;**  
Также можно комбинировать Inner Join и Outer Join:  
SELECT Customers.FirstName, Orders.CreatedAt, Products.ProductName, Products.Company FROM Orders   
JOIN Products ON Orders.ProductId = Products.Id AND Products.Price > 45000  
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id ORDER BY Orders.CreatedAt;  
Вначале по условию к таблице Orders через Inner Join присоединяется связанная информация из Products, 
затем  к этеим записям через Outer Join добавляется информация из таблицы Customers.  
+ **FULL JOIN**  
Возвращает объединение объединений LEFT и RIGHT таблиц, комбинируя результат двух запросов.
Также для тех строк, где условие не выполняется проставится NULL.
Чтобы получить обе таблицы, но без совпадающего множества.  
SELECT FirstName, CreatedAt, ProductCount, Price FROM Customers FULL OUTER JOIN Orders
ON Orders.CustomerId = Customers.Id where Orders.CustomerId is Null or Customers.Id is Null;  
+  **SELF JOIN**  
Таблица может быть соединена с самой собой, с разными строками, соответствующими друг другу.  
В  примере для каждого сотрудника в таблице базы данных  возвращается запись, содержащая имя сотрудника вместе с соответствующим именем менеджера сотрудника.
Поскольку менеджеры также являются сотрудниками, таблица объединяется с собой.  
[подробнее](https://riptutorial.com/ru/sql/example/940/self-join)   
    
[подробнее](http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html)
[подробнее](https://metanit.com/sql/postgresql/6.3.php)  

[к оглавлению](#SQL-Jdbc)  

## Что такое group by  
GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM). 
все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть указаны в предложении GROUP BY.
В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах. 
После чего к каждой группе будут применены агрегатные функции. Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные,
то есть при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.  
Например, сгруппируем товары по производителю:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products GROUP BY Company;  
Т.е. для повторяющихся компаний мы сформируем группы и посчитаем число вхождений.  
Оператор GROUP BY может выполнять группировку по множеству столбцов.  
SELECT Company, ProductCount, COUNT(*) AS ModelsCount FROM Products GROUP BY Company, ProductCount;  
В данном случае группировка происходит по совпадению **одновременно двух столбцов** у строки (как бы по составному столбцу)  
[подробнее](https://metanit.com/sql/postgresql/4.6.php)
[подробнее](https://sql-academy.org/ru/guide/groupping-aggregate-functions )  

[к оглавлению](#SQL-Jdbc)  

## Что такое HAVING? Разница с Where?  
Оператор HAVING указывает, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп. 
Его использование аналогично применению оператора WHERE.  
Например, сгруппируем по производителям и найдем все группы, для которых определено более 1 модели:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products GROUP BY Company HAVING COUNT(*) > 1;  
При этом в одной команде мы можем использовать выражения WHERE и HAVING:  
SELECT Company, COUNT(*) AS ModelsCount FROM Products WHERE Price * ProductCount > 80000 GROUP BY Company HAVING COUNT(*) > 1;  
То есть в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000.
Затем выбранные товары группируются по производителям. И далее фильтруются сами группы - выбираются те группы,
которые содержат больше 1 модели.  
Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING:  
SELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units FROM Products WHERE Price * ProductCount > 80000  
GROUP BY Company  
HAVING SUM(ProductCount) > 2  
ORDER BY Units DESC;  
В дополнение к оператору GROUP BY PostgreSQL поддерживает еще три специальных расширения для группировки данных: GROUPING SETS, ROLLUP и CUBE.  
Оператор ROLLUP добавляет суммирующую строку в результирующий набор.  

[подробнее](https://metanit.com/sql/postgresql/4.6.php)  
[к оглавлению](#SQL-Jdbc)  

##  Другие запросы: Distinct, Count
**DICTINCT**  
Оператор DISTINCT позволяет выбрать уникальные данные по определенным столбцам.  
SELECT DISTINCT Manufacturer FROM Products;  
  
Агрегатные функции вычисляют одно значение над некоторым набором строк. Агрегатные функции: AVG, COUNT(*), SUM, MIN, MAX.  
COUNT(expression): находит количество строк в запросе, для которых expression не содержит значение NULL.
STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку.  
Если в наборе нет строк, то все агрегатные функции за исключением COUNT(*) возвращают значение NULL.  
Вторая форма функции COUNT(*) возвращает количество строк по определенному столбцу, при этом строки со значениями NULL игнорируются:  
SELECT COUNT(DISTINCT Company) FROM Products;  
[подробнее](https://metanit.com/sql/postgresql/4.1.php)    

[к оглавлению](#SQL-Jdbc)  

##  Составные типы данных  
**Массивы**  
Столбцы в таблице в PostgreSQL могут представлять массивы, например,
массивы чисел INTEGER или массивы строк VARCHAR или массивы других типов данных.  
create table posts (id serial primary key, title varchar(30), body text, tags varchar(10)[]);  
Добавим в эту таблицу одну статью с набором тегов:  
insert into posts(title, body, tags) values('Post Title', 'Post Text', '{"sql", "postgres", "database", "plsql"}');  
Как и данные любого другого столбца, мы можем извлечь данные массива:  
select tags from posts;  
Однако с помощью индексов мы также можем конкретизировать, какие именно элементы массива мы хотим получить:  
select tags[1:3] from posts;  
Вначале идет индекс начала диапазона, а затем индекс конца диапазона. То есть в данном случае извлекаем три тега с первого по третий.  
При обновлении строки мы можем изменять как в целом все теги, так и какие-то конкретные теги:  
Переустановим массив:  
update posts set tags='{"sql", "postgres", "database"}' where id=1;  
Переустановим конкретный элемент, например, второй:  
update posts set tags[2]='system' where id=1;  
**Перечисления ENUM**  
PostgreSQL имеет специальный тип данных, который называется enum и который представляет набор констант. 
И столбец подобного типа может в качестве значения принимать одну из этих констант.  
Для создания перечисления используется команда CREATE TYPE. Например, создадим простейшее перечисление:  
create type request_state as enum ('created', 'approved', 'finshed');  
Данное перечисление называется "request_state".
После слова enum в скобках указывается через запятую список констант, которые составляют данное перечисление. 
То есть в данном случае перечисление request_status может принимать три значения: 'created', 'approved', 'finshed'.  
После создания перечисления мы можем использовать его в качестве типа столбца.  
create table requests (id serial primary key, title varchar(30), status request_state);  
Здесь третий столбец - status представляет перечисление request_state и может принимать одно из трех выше указанных значений.  
insert into requests(title, status) values ('Request 1', 'created');  
Кроме того, большую роль играет регистр символов, например, "created" не эквивалентно "Created".  
[подробнее](https://metanit.com/sql/postgresql/5.1.php)   
[подробнее](https://metanit.com/sql/postgresql/5.2.php)  

[к оглавлению](#SQL-Jdbc)      
  
## Множества: Union, EXCEPT, INTERSECT    
**Union (объединение множеств)**    
Оператор UNION позволяет объединить два множества (условно две таблицы). 
(т.е. если у нас есть две таблицы "сотрудники" и "клиенты" с полями имени и фамилии, их можно объединить в одну таблицу)
Но в отличие от inner/outer join объединения соединяют не столбцы разных таблиц, а два однотипных набора в один.  
Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами 
- именем (FirstName) и фамилией (LastName). Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц:  
SELECT FirstName, LastName FROM Customers UNION SELECT FirstName, LastName FROM Employees;  
В данном случае из первой таблицы выбираются два значения - имя и фамилия клиента. 
Из второй таблицы Employees также выбираются два значения - имя и фамилия сотрудников. 
То есть при объединении количество выбираемых столбцов и их тип совпадают для обеих выборок.  
**Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются.**
В случае с таблицами Customers и Employees сотрудники банка могут быть одновременно его клиентами и содержаться в обеих таблицах. 
Если же необходимо при объединении сохранить все, в том числе повторяющиеся строки, то для этого необходимо использовать оператор ALL  
SELECT FirstName, LastName FROM Customers UNION ALL SELECT FirstName, LastName  FROM Employees;  
При этом названия столбцов объединенной выборки будут совпадать с названия столбцов первой выборки. 
И если мы захотим при этом еще произвести сортировку, 
то в выражениях ORDER BY необходимо ориентироваться именно на названия столбцов первой выборки.  
Для объединения строк применяется оператор ||. (т.е. имя и фамилию можно объекдинить в один столбец)  
SELECT FirstName || ' ' || LastName AS FullName FROM Customers
UNION SELECT FirstName || ' ' || LastName AS EmployeeName  FROM Employees;    
[подробнее](https://metanit.com/sql/postgresql/6.5.php)  

**EXCEPT (разность множеств)**  
Оператор EXCEPT в PostgreSQL позволяет найти разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй.  
И допустим, нам надо найти всех клиентов банка, которые не являются его сотрудниками:  
SELECT FirstName, LastName FROM Customers EXCEPT SELECT FirstName, LastName FROM Employees;  

**INTERSECT (пересечение множеств)**   
Оператор INTERSECT позволяет найти общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения множеств.  
Найдем всех сотрудников банка, которые одновременно являются его клиентами:  
SELECT FirstName, LastName FROM Employees INTERSECT SELECT FirstName, LastName FROM Customers;

[к оглавлению](#SQL-Jdbc)   

## Что такое транзакция?  
Транзакции позволяют выполнять ряд операций в виде одного целостного пакета. 
И если хотя бы одна из этих операций завершится неудачно, то произойдет откат выполнения остальных операций.  
Транзакция Transaction включает одно или несколько изменений в базе данных, 
которые после выполнения либо все фиксируются (commit), либо все откатываются назад (rollback).  
```java
Connection connection = ...;
// Сброс автофиксации
connection.setAutoCommit(false);
// Первая транзакция
PreparedStatement updateSales = connection.prepareStatement(
         "UPDATE COFFEES SET SALES = ? WHERE COF_NAME LIKE ?");
updateSales.setInt(1, 50);
updateSales.setString(2, "Colombian");
updateSales.executeUpdate();

// Вторая транзакция
PreparedStatement updateTotal = connection.prepareStatement(
        "UPDATE COFFEES SET TOTAL = TOTAL + ? WHERE COF_NAME LIKE ?");
updateTotal.setInt(1, 50);
updateTotal.setString(2, "Colombian");
updateTotal.executeUpdate();
// Завершение транзакции
connection.commit();
// Восстановление по умолчанию
connection.setAutoCommit(true);  
```  
[подробнее](http://java-online.ru/jdbc-transaction.xhtml)    

[к оглавлению](#SQL-Jdbc)  

## Требования ACID к СУБД  
В информатике акроним ACID описывает требования к транзакциям (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.    
**Atomicity — Атомарность**  
Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
Будут либо выполнены все её подоперации, либо не выполнено ни одной.  
**Consistency — Согласованность**  
После завершения операции в БД останутся только согласованные (с точки зрения бизнес логики) данные.
Например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять,
не выйдет ли в результате отрицательных значений.  
**Isolation — Изолированность**  
**Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.**
**Другие клиенты (потоки, операции) не видят промежуточных несогласованных данных во время выполнения операции.**  
Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности).  
**Долговечность (durability)**
Изменения, получившиеся в результате транзакции, должны оставаться сохраненными вне зависимости от каких-либо сбоев.
Иначе говоря, если пользователь получил сигнал о завершении транзакции, он может быть уверен, что данные сохранены.  
(Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения,
сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.)    

[к оглавлению](#SQL-Jdbc)    
   
## Что такое хранимые процедуры?  
Нередко операция с данными представляет набор инструкций, которые необходимо выполнить в определенной последовательности. 
Например, при добавлении покупке товара необходимо внести данные в таблицу заказов. Однако перед этим надо проверить,
а есть ли покупаемый товар в наличии. Возможно, при этом понадобится проверить еще ряд дополнительных условий.
То есть фактически процесс покупки товара охватывает несколько действий, которые должны выполняться в определенной последовательности. 
И в этом случае более оптимально будет инкапсулировать все эти действия в один объект - хранимую процедуру (stored procedure).
**То есть по сути хранимые процедуры представляет набор инструкций, которые выполняются как единое целое.**
Тем самым хранимые процедуры позволяют упростить комплексные операции и вынести их в единый объект. 
Изменится процесс покупки товара, соответственно достаточно будет изменить код процедуры. То есть процедура также упрощает управление кодом.
Также хранимые процедуры позволяют ограничить доступ к данным в таблицах
и тем самым уменьшить вероятность преднамеренных или неосознанных нежелательных действий в отношении этих данных.
И еще один важный аспект - производительность. Хранимые процедуры обычно выполняются быстрее,
чем обычные SQL-инструкции. Все потому что код процедур компилируется один раз при первом ее запуске, а затем сохраняется в скомпилированной форме.
Для создания хранимой процедуры применяется команда CREATE PROCEDURE или CREATE PROC.  
CREATE PROCEDURE ProductSummary AS SELECT ProductName AS Product, Manufacturer, Price FROM Products  
**Таким образом, хранимая процедура имеет три ключевых особенности: упрощение кода, безопасность и производительность.**  
Для выполнения хранимой процедуры вызывается команда EXEC или EXECUTE.  
[подробнее](https://metanit.com/sql/sqlserver/11.1.php)
[к оглавлению](#SQL-Jdbc)  

## Что такое триггер? (Какие типы триггеров вы знаете?)  
Триггеры представляют специальный тип хранимой процедуры,
которая вызывается автоматически при выполнении определенного действия над таблицей или представлением,
в частности, при добавлении, изменении или удалении данных, то есть при выполнении команд INSERT, UPDATE, DELETE. (немного напоминают аспекты)  
CREATE TRIGGER имя_триггера ON {имя_таблицы | имя_представления} {AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE] AS выражения_sql;  
Мы можем использовать один из двух типов:  
AFTER: выполняется после выполнения действия. Определяется только для таблиц.  
INSTEAD OF: выполняется вместо действия (то есть по сути действие - добавление, изменение или удаление - вообще не выполняется).
Определяется для таблиц и представлений.  
CREATE TRIGGER Products_INSERT_UPDATE  
ON Products  
AFTER INSERT, UPDATE  
AS  
UPDATE Products  
SET Price = Price + Price * 0.38  
WHERE Id = (SELECT Id FROM inserted)    
  
[подробнее](https://metanit.com/sql/sqlserver/12.1.php)
[к оглавлению](#SQL-Jdbc)    

## Что такое view  
Представления или Views представляют виртуальные таблицы - т.е. представляют таблицы, но сами данные хранятся в других таблицах, а 
оин извлекают эти данные в момент обращения к ним. 
Представления дают нам ряд преимуществ. Они упрощают комплексные SQL-операции.
Они защищают данные, так как представления могут дать доступ к части таблицы, а не ко всей таблице.
Представления также позволяют возвращать отформатированные значения из таблиц в нужной и удобной форме.  
CREATE VIEW OrdersProductsCustomers AS SELECT Orders.CreatedAt AS OrderDate, Customers.FirstName AS Customer, Products.ProductName As Product    
FROM Orders   
INNER JOIN Products ON Orders.ProductId = Products.Id  
INNER JOIN Customers ON Orders.CustomerId = Customers.Id  
То есть данное представление фактически будет возвращать сводные данные из трех таблиц.
И после его создания мы сможем его увидеть в узле Views у выбранной базы данных в SQL.  
[подробнее](https://metanit.com/sql/sqlserver/10.1.php)  

[к оглавлению](#SQL-Jdbc) 

## Для чего используется конструкция try-with-resources  
Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally в которой
и происходит закрытие без участия разработчика. Конструкция является так называемым «синтаксическим сахаром»
и создана для облегчения жизни программиста. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.  

[к оглавлению](#SQL-Jdbc)  

## Опишите процесс создания запроса через JDBC  

+ Загрузка драйвера базы данных.Для загрузки/использования нашего драйвера можно пойти двумя путями. 
Первый – это вписать имя драйвера в код программы. В этом случае мы не сможем изменить СУБД без перекомпиляции. 
Второй – это подключать драйвер из командной строки Java (JVM). 
Следующей строчкой мы загружаем драйвер, и он автоматически зарегистрируется себя для использования вместе с JDBC.
```java
Class.forName(“postgresql.Driver”);
```
Во втором же случае мы используем ключ –D для подключения драйвера.
```java
java –Djdbc.drivers=postgresql.Driver myClass
```
+ Для соединения с базой данных используют класс Connection:
```java
Connection dbh = DriverManager.getConnection(url, user, passwd);
```
+ Установив соединение, мы можем выполнять sql-запросы к нашей базе данных. 
Для примера, рассмотрим небольшой кусок кода на Java:
```java
Statement st = dbh.createStatement();

ResultSet rs = st.executeQuery(
"select * from flowers_tbl where (flowers_id in (1,2,3,4,5,6,7,8,9))"
);

while (rs.next())
{
  System.out.println(rs.getString(1));
}
rs.close();
st.close();
```

Для того, чтобы посылать запросы к базе данных, необходимо создать экземпляр класса Statement st. 
Метод executeQuery этого класса отправляет переданный ему запрос к базе данных и в качестве ответа возвращает результат 
в виде класса ResultSet.

В конце надо закрыть все ресурсы.  

[к оглавлению](#SQL-Jdbc) 

## Дполнительно:  
**Команды PostgreSQL:**  
+ create database test; 
+ use test;  
или \c test; для postgresql  
Приказать СУБД использовать созданную базу данных
+ drop table students; 
 
**Команды SQL:**  
+ DESC students;  
Посмотреть описание созданной таблицы.
+ SHOW CREATE TABLE users;  
В MySql возвращает команду CREATE TABLE, которая была использована для создания таблицы.  
+ insert into students values ('', 'Petr', '2000-06-02');  
Два апострофа означают,что значение первичного ключа должно генерироваться автоматически.
  
**Получение части строки:**  
SUBSTRING_INDEX ()    
Функция SUBSTRING_INDEX () находит все символы текстового значения, предшествующие заданному символу или подстроке.
Запятая заключается в апострофы, а функция SUBSTRING INDEX () возвращает все символы, стоящие перед запятой:  
SELECT SUBSTRING_INDEX (location, ’,’ , 1 ) FROM my__contacts; (1 – значит, что ищется первая запятая)  
[подробнее](http://old.code.mu/sql/substring_index.html)  

[к оглавлению](#SQL-Jdbc)   





 
 
  
  



