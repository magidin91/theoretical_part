## Garbage Collection

+ [Чем java отличается от с++](#Чем-java-отличается-от-с)
+ [Что такое менеджер памяти](#Что-такое-менеджер-памяти)
+ [Какой механизм используется в Java для управления памятью](#Какой-механизм-используется-в-Java-для-управления-памятью)
+ [Опишите процесс работы сборщика мусора](#Опишите-процесс-работы-сборщика-мусора)
+ [Какие алгоритмы сборщика вы знаете](#Какие-алгоритмы-сборщика-вы-знаете)
+ [Чем отличаются сборщики мусора](#Чем-отличаются-сборщики-мусора)
+ [Расскажите про утилиты для анализа памяти](#Расскажите-про-утилиты-для-анализа-памяти)
+ [Что такое ссылки](#Что-такое-ссылки)
+ [Какие типы ссылок вы знаете](#Какие-типы-ссылок-вы-знаете)
+ [Чем они отличаются](#Чем-они-отличаются)
+ [Расскажите про String pool, Int pool](#расскажите-про-string-pool-int-pool)
+ [Расскажите о String.intern](#расскажите-о-stringintern)
+ [Что такое профайлер](#Что-такое-профайлер)
+ [Как использовать VisualVM](#Как-использовать-VisualVM)
+ [Чем отличается sampling от profiling](#Чем-отличается-sampling-от-profiling)
+ [Расскажите о benchmark](#Расскажите-о-benchmark)
+ [Расскажите о методе finalized](#Расскажите-о-методе-finalized)
+ [Расскажите о методе clone](#Расскажите-о-методе-clone)
+ [Расскажите о Stack, Heap](#Расскажите-о-Stack,-Heap)

Дополнительные теория:

JRE
[JRE](https://topjava.ru/blog/what-is-the-jre) (Java Runtime Environment) - среда выполнения java - программ. 
Узнать версию JRE можно с помощью командной строки:  **java -version**. 

JRE - это часть программного обеспечения, предназначенная для запуска другого программного обеспечения. 

Принцип write once, run anywhere (WORA) – написано однажды, выполняется где угодно.
JRE сглаживает разнообразие операционных систем, гарантируя, что программы Java могут работать практически на любой ОС без изменений. 
Среда выполнения Java — это уровень программного обеспечения, работающий поверх операционной системы и предоставляющий дополнительные службы, специфичные для Java.
Она также обеспечивает дополнительные возможности. Автоматическое управление памятью — одна из самых важных функций JRE, гарантирующая, что программистам не придется вручную управлять распределением памяти.

JRE — это программа, которая берет ваш Java-код, объединяет его с необходимыми библиотеками и запускает JVM для его выполнения. 
Как среда выполнения для Java, **JRE содержит основные библиотеки классов (io, awt, net итд), загрузчик классов и виртуальную машину Java**(которая включает Java Interpreter, GC, Threading итд). 
+ Загрузчик классов отвечает за правильную загрузку классов и их связь с основными библиотеками классов Java.
Эта важная часть программного обеспечения загружает **скомпилированный** Java-код в память и соединяет с соответствующими библиотеками.
+ JVM отвечает за обеспечение Java-приложений ресурсами, необходимыми для их запуска и эффективной работы, а также выполняет приложение

Как разработчик вы будете работать с JDK и JVM, потому что эти компоненты вы будете использовать для разработки и запуска ваших Java-программ. 
Как пользователь Java-программ, вы будете использовать JRE, которая позволяет запускать эти программы.

JRE не очень ощутима на стадии разработки, где она просто запускает ваши приложения в операционной системе или IDE. 
JRE играет более заметную роль в devops и системном администрировании, потому что тут она используется для мониторинга и конфигурации.
В основном JRE предоставляет инструменты, которые вы можете использовать для настройки и управления характеристиками Java приложения.
Использование памяти является самым ярким примером.

JVM
В 1995 году, JVM представила две революционных концепции, которые с тех пор стали стандартом в современной разработке:
«Написал один раз, запускай везде» и автоматическое управление памятью.
Виртуальная машина означает, что JVM является абстракцией фактической машины, такой как сервер, на которой работают программы. 
Независимо от операционной системы или технического обеспечения, JVM создает предсказуемую среду для запускаемых внутри нее программ.

JVM — это программное обеспечение, которое выполняет код и предоставляет среду выполнения для этого кода, предоставляет и контролирует использование ресурсов Java приложением.

Механизм выполнения в JVM
Как только загрузчик классов выполнил свою работу по загрузке классов, JVM начинает выполнять код каждого класса.
Выполнение кода включает управление доступом к системным ресурсам.
Механизм выполнения JVM стоит между работой программы, с ее запросами на файловые, сетевые ресурсы и ресурсы памяти, и операционной системой, которая обеспечивает эти ресурсы.

Вспомните, что JVM отвечает за очистку неиспользуемой памяти, а сборщик мусора — это механизм, который эту очистку осуществляет.
JVM также отвечает за распределение и поддержание ссылочной структуры, которую разработчик принимает, как должное. **Например, 
при использовании ключевого слова new, механизм выполнения JVM осуществляет запрос к операционной системе на выделение памяти.**

Изначально виртуальная машина Java предназначалась только для Java,
но сегодня она может поддерживать разные скриптовые и другие языки программирования, включая Scala, Groovy и Kotlin. 

JDK
[JDK](https://topjava.ru/blog/what-is-the-jdk) — это реализация спецификации платформы Java, включающая в себя компилятор и библиотеки классов.

Компилятор — это программа, способная принимать исходные файлы с расширением .java, которые являются обычным текстом, и превращать их в исполняемые файлы с расширением .class. (команда javac)
Source code содержит исходники публичных классов из Java Core Api. 
Установка этого пункта позволит вам обращаться к исходному коду классов при разработке ваших приложений.



## Чем java отличается от с++
C++ поддерживает как процедурное, так и объектно-ориентированное программирование; поэтому он называется гибридным.

+ Управление памятью
В с++ вся память программы управлялась программистом. 
В Java память программ управляется виртуальной машиной Java. JVM управляет памятью через процесс, 
названный сборкой мусора, который непрерывно определяет и устраняет неиспользуемую память в программах. 
В большинстве случаев делегирование управления памятью высокоточному процессу, такому как JVM, дает лучшую производительность и защищает от ошибок, нежели ручное управление

+ Многопоточность
C++ не имеет встроенной поддержки потоков. Для этих целей используются нестандартизированные библиотеки третьих сторон.

+ C++ поддерживает множественное наследование.

+ Независимость от платформы
C++ генерирует объектный код; тот же код может не запускаться на разных платформах.
Java, по большей мере, интерпретируется, поэтому не зависит от платформы.  

[к оглавлению](#Garbage-Collection)

## Что такое менеджер памяти
Менеджер памяти — часть компьютерной программы, обрабатывающая запросы на выделение и освобождение оперативной памяти.
В Java - это JVM, а конкретнее  GC.  

[к оглавлению](#Garbage-Collection)

## Какой механизм используется в Java для управления памятью
JVM --> Garbage Collection.  

[к оглавлению](#Garbage-Collection)

## Опишите процесс работы сборщика мусора
https://habr.com/ru/post/269621/
Преследуя свои цели, различные сборщики мусора используют разные подходы к организации памяти и ее очистке, 
но их объединяет общая черта — все они опираются на **слабую гипотезу о поколениях**. 
Ее приложение к сборке мусора в частности означает, что подавляющее большинство объектов живут крайне недолго.
Подавляющее большинство объектов создаются на очень короткое время, они становятся ненужными практически сразу после их первого использования.
Все это навело разработчиков на мысль, что в первую очередь необходимо сосредотачиваться на очистке тех объектов, 
которые были созданы совсем недавно. Именно среди них чаще всего находится бóльшее число тех, кто уже отжил свое,
и именно здесь можно получить максимум эффекта при минимуме трудозатрат.
Вот тут и возникает идея разделения объектов на младшее поколение (young generation) и старшее поколение (old generation). 
В соответствии с этим разделением и процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только младшее поколение, 
и полную сборку (full GC), которая может затрагивать оба поколения.
 Малые сборки выполняются достаточно часто и удаляют основную часть мертвых объектов. 
 Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к исчерпанию и малой сборкой уже не обойтись.

При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. 
Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение.
В старшем поколении объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.  

[к оглавлению](#Garbage-Collection)

## Какие алгоритмы сборщика вы знаете
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:
+ Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. 
На слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. 
Останавливает приложение и в однмо потоке последовательно выполняет сборку мусора.
+ Parallel  — наследует подходы к сборке от последовательного сборщика, но добавляет многопоточность  при переносе объектов в старшее поколение, 
и при уплотнении данных в старшем поколении, а также возможности по автоматической подстройке под требуемые параметры производительности. (при этом приложение также останавилвается) 
+ Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. 
Подходит для работы с относительно большими объемами данных в памяти. Малая и старшая сборки здесь всегда разделены.
Часть старшей сборки производит в конкурентном режиме. Пометку выживших объектов и удаление мертвых объектов сборщик CMS выполняет  параллельно с работой основной программы, т.е. конкурирует.
+ Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах 
и оперирующих большими объемами данных.
Отличие в малых сборках - очистка выполняется **не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени**,
при этом выбирает для очистки те регионы, **в которых скопилось наибольшее количество мусора**.
Отсюда как раз название Garbage First — мусор в первую очередь. 
Смешанные сборки: при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. 
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках 
таким образом, чтобы не выходить за требуемое время сборки. Т.е. и малая, и смешанная сборка напрпвлена на не превышение желаемого времени STW.

**Serial GC** (он же последовательный сборщик)

С этим сборщиком все достаточно просто, так как вся его работа — это один сплошной STW. 
**В начале каждой сборки мусора работа основных потоков приложения останавливается и возобновляется только после окончания сборки.**
Причем всю работу по очистке Serial GC выполняет не торопясь, в одном потоке, последовательно, за что и удостоился своего имени.
Использование Serial GC включается опцией -XX:+UseSerialGC.

Алгоритм:
При использовании данного сборщика куча разбивается на четыре региона, 
три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему.
Малая сборка:
Когда Eden заполняется, живые объекты переносятся в пустой регион Survivor (Survivor 0).
В след. раз когда Eden заполняется, Eden и Survivor 0 очищаются, живые объекты переносятся в Survivor 1.
Далее когда Eden заполняется, объекты из Eden и Survivor 1 переносятся в Survivor 0.
JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, 
и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение.
Т.е. далее при заполнении Eden, объекты из Eden перейдут в Survivor 1, а выжившие из Survivor 0 уже в Tenured.
(Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured)

В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора, работающая с объектами из обоих поколений.

Существуют объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. 
В этом случае они размещаются сразу в Tenured.


Важными факторами в описанных процессах являются абсолютный размер кучи и относительные размеры регионов внутри нее.
По мере заполнения кучи данными JVM может не только проводить чистку памяти, но и запрашивать у ОС выделение дополнительной памяти для расширения регионов.
Причем в случае, если реально используемый объем памяти падает ниже определенного порога, JVM может вернуть часть памяти операционной системе.
Тут также стоит отметить, что по умолчанию младшее поколение занимает одну треть всей кучи, а старшее, соответственно, две трети. 
При этом каждый регион Survivor занимает одну десятую младшего поколения, то есть Eden занимает восемь десятых.

Достоинства и недостатки
Основное достоинство данного сборщика очевидно — это непритязательность по части ресурсов компьютера. 
Так как всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.
Главный недостаток тоже понятен — это долгие паузы на сборку мусора при заметных объемах данных. 
Кроме того, видно, что все настройки Serial GC крутятся вокруг размеров различных регионов кучи. 
То есть для тонкой настройки требуется самому что-то изучать, настраивать, экспериментировать и прочее.

**Parallel GC**
Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, 
то почти наверняка JVM остановит свой выбор на Parallel GC.
Основные отличия этого сборщика от последовательного: во-первых, **сборкой мусора занимаются несколько потоков параллельно**; 
во-вторых, **данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности**.
**Малая пользуется многопоточностью при переносе объектов в старшее поколение, 
а полная — при уплотнении данных в старшем поколении.**

При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden,
Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. 

Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только он может переносить данные,
чтобы не мешать другим потокам. 
Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти.

Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, 
ориентированные на достижение необходимой вам эффективности сборки мусора. 
Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — 
и сборщик будет изо всех сил стараться не превышать заданные пороги.
При этом Parallel GC оставляет нам возможность самостоятельно корректировать размеры регионов, как и в последовательном сборщике. 
Но не рекомендуется делать и то и другое одновременно, чтобы не дезориентировать алгоритмы автоматической подстройки.

Ситуации STW
Как и в случае с последовательным сборщиком, на время операций по очистке памяти все основные потоки приложения останавливаются. 
Разница только в том, что пауза, как правило, короче за счет выполнения части работ в параллельном режиме.

Установка желаемых параметров производительности сборщика выполняется с помощью опций -XX:MaxGCPauseMillis=? и -XX:GCTimeRatio=?.

Достоинства и недостатки

Бесспорным плюсом данного сборщика на фоне Serial GC является возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время cборок. 
При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.
Определенная фрагментация памяти, конечно, является минусом, но вряд ли она будет существенной для большинства приложений, 
так как сборщиком используется относительно небольшое количество потоков.


**CMS GC** (Concurrent Mark Sweep)

**Первостепенной задачей CMS GC и G1 GC** является минимизация пауз при наведении порядка в памяти приложений,
оперирующих средними и большими объемами данных, то есть по большей части в памяти серверных приложений.
Два этих сборщика объединяют общим названием «mostly concurrent collectors», то есть «по большей части конкурентные сборщики». 
Это связано с тем, что часть своей работы они выполняют параллельно с основными потоками приложения, 
то есть в какие-то моменты конкурируют с ними за ресурсы процессора. 

Использование CMS GC включается опцией -XX:+UseConcMarkSweepGC.

Мы уже встречали слова Mark и Sweep при рассмотрении последовательного и параллельного сборщиков.
Они обозначали два шага в процессе сборки мусора в старшем поколении: пометку выживших объектов и удаление мертвых объектов.
Сборщик CMS получил свое название благодаря тому, что **выполняет указанные шаги параллельно с работой основной программы**.

При этом CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC:
регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. 
Отличия начинаются только тогда, когда дело доходит до полной сборки. 
В случае CMS ее называют старшей (major) сборкой, так как она не затрагивает объекты младшего поколения. 
В результате, малая и старшая сборки здесь всегда разделены. Одним из побочных эффектов такого разделения является то, 
что все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. 
Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Сборщик CMS достаточно интеллектуальный. Например, он старается разносить во времени малые и старшие сборки мусора, 
чтобы они совместно не создавали продолжительных пауз в работе приложения.

Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. 
В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме. Такая ситуация называется сбоем конкурентного режима.

Ситуации STW

Из всего сказанного выше следует, что при обычной сборке мусора у CMS GC существуют следующие ситуации, приводящие к STW:
+ Малая сборка мусора. Эта пауза ничем не отличается от аналогичной паузы в Parallel GC. (Конкурентный режим работает только в старшей сборке)
+ Начальная фаза поиска живых объектов при старшей сборке (так называемая initial mark pause). Эта пауза обычно очень короткая.
+ Фаза дополнения набора живых объектов при старшей сборке (известная также как remark pause). Она обычно длиннее начальной фазы поиска.

Достоинства и недостатки

Достоинством данного сборщика по сравнению с рассмотренными ранее Serial / Parallel GC является его ориентированность на минимизацию времен простоя,
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.
Вспомним еще, что данный сборщик не уплотняет объекты в старшем поколении, что приводит к фрагментации Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению (конкретно — старшему поколению) больше памяти, 
чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).
Ну и долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти CMS’у удается их полностью избегать.

**G1 GC** (Garbage First)
G1 включается опцией Java -XX:+UseG1GC.

Интересен он прежде всего тем, что не является явным продолжением линейки Serial / Parallel / CMS, 
а использует уже существенно отличающийся подход к задаче очистки памяти.
Он изначально позиционировался как сборщик для приложений с большими кучами (от 4 ГБ и выше), 
для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет уменьшения пропускной способности.

G1 измененил подход к организации кучи. Здесь память разбивается на множество регионов одинакового размера. 
Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. 
Исключение составляют только так называемые громадные (humongous) регионы, которые создаются объединением обычных регионов для размещения очень больших объектов.

Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд 
и даже могут менять свою принадлежность к тому или иному поколению.

Отличие в малых сборках - очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени.
При этом он выбирает для очистки те регионы, в которых,  скопилось наибольшее количество мусора.
Отсюда как раз название Garbage First — мусор в первую очередь.

А с полной сборкой (она называется смешанной (mixed)) все немного хитроумнее, чем в рассмотренных ранее сборщиках. 
В G1 существует процесс, называемый циклом пометки (marking cycle почти аналогично mark and sweep),
который работает параллельно с основным приложением и составляет список живых объектов. 
После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения,
подлежащих очистке, добавляется некоторое количество регионов старшего поколения. 
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках 
таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

Ситуации STW
Если резюмировать, то у G1 мы получаем STW в следующих случаях:
+ Процессы переноса объектов между поколениями. Для минимизации таких пауз G1 использует несколько потоков.
+ Короткая фаза начальной пометки корней в рамках цикла пометки.
+ Более длинная пауза в конце фазы remark и в начале фазы cleanup цикла пометки.

Достоинства и недостатки

G1 DukeВ целом считается, что сборщик G1 более аккуратно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 
При этом он лишен и некоторых других недостатков CMS, например, он не фрагментирует память.

Расплатой за достоинства G1 являются ресурсы процессора, которые он использует для выполнения достаточно большой части своей работы параллельно 
с основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности по умолчанию для G1 является 90%. 
Для Parallel GC, например, это значение равно 99%. Это, конечно, не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, 
но данную особенность следует всегда иметь в виду.  

[к оглавлению](#Garbage-Collection)

## Чем отличаются сборщики мусора
+ Между сборщиками существуют и заметные различия, проявляющиеся в ответах на следующие вопросы:
+ Какое количество регионов кучи используется, каково их назначение и размеры? Как эти размеры изменяются динамически?
+ Как устроен перевод объектов из младшего поколения в старшее?
+ Какие из работ по сборке мусора выполняются параллельно с работой основной программы, а какие приводят к ее остановке?
+ Каким образом сборщик мусора автоматически подстраивается под требуемые параметры производительности? Каким из них отдает приоритет?
+ Какие существуют возможности по настройке сборщика?  

[к оглавлению](#Garbage-Collection)

## Расскажите про утилиты для анализа памяти
1. JConsole – это встроенный профайлер производительности Java
2. VisualVM - визульаное продолжение JConsole
3. JProfiler - платная утилита

Все утилиты для анализа памяти позволяют мониторить работу JVM, в частности кол-во используемой памяти,
сборки мусора, кол-во созданных объектов, кол-во занятой памяти в поколених,  кол-во загруженных классов, запущенных потоков итд.

[к оглавлению](#Garbage-Collection)

## Что такое ссылки
Ссылки в Java — указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, в которой хранится объект.
Объявленная переменная  хранит не состояние объекта, а ссылку на него, сам же объект хранится в определённой куче. 

Ссылка на объект занимает в стеке память равную машинному слову.
Технически ссылки обычно равны размеру машинного слова, т.е. 32 бит на 32-битной машине и 64 бит на 64-битной машине, 
хотя некоторые 64-разрядные JVM используют специальная магия, чтобы разрешить 32-битные ссылки.

Java передает все по значению. С примитивами, вы получаете копию содержимого. С ссылками вы получаете копию ссылки.  

[к оглавлению](#Garbage-Collection)

## Какие типы ссылок вы знаете
+ сильные ссылки (strong reference)
+ мягкие ссылки (SoftReference)
+ слабые ссылки (WeakReference)
+ фантомные ссылки (PhantomReference)  

[к оглавлению](#Garbage-Collection)

## Чем они отличаются
[подробнее](https://habr.com/ru/post/169883/)

Наиболее важные методы при работе с этими классами:
get() — возвращает объект, на который ссылается эта ссылка;(он объявлен у класса Reference, от которого наследуются SoftReference, WeakReference, PhantomReference)
clear() — удаляет ссылку на объект.

1. сильные ссылки (strong reference). Это обычные ссылки которые мы всегда используем.
Когда мы объявляем Rectangle rect = new Rectangle(), то объект на который ссылается rect не может быть удален сборщиком мусора из памяти до тех пор,
пока на этот объект есть хотя бы одна сильная ссылка;

2. мягкие ссылки (SoftReference). Объявление мягкой ссылки выглядит так: SoftReference<Rectangle> rect = new SoftReference<Rectangle>(new Rectangle());
SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. Потом. Наверно.
**Важно понимать, что метод get() может вернуть null. Это происходит в том случае, когда память вашей программы заполнена и появляется вероятность возникновения OutOfMemoryError, 
тогда сборщик мусора удаляет объекты на которые ссылаются мягкие ссылки. Именно этот вид ссылок удобно использовать для кеширования объектов.**

Главная плюшка SoftReference в том что JVM сама следит за тем нужно удалять из памяти объект или нет. 
И если осталось мало памяти, то объект будет удален. Это именно то, что нам нужно при кэшировании.
Если говорить про производительность, то стоить отметить что часто, ошибочно, люди используют WeakReference для построения кэша там где стоит использовать SoftReference. 
Это приводит к низкой производительности кэша. На практике weak-ссылки быстро будут удалены из памяти, как только исчезнут strong-ссылки на объект. 
И когда нам реально понадобиться вытянуть объект с кэша, мы увидим что его там уже нет.

Есть еще такой класс – ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить.
Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. 
При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.

3. слабые ссылки (WeakReference).
[Подробнее](https://javadevblog.com/tipy-ssy-lok-v-java-strongreference-weakreference-softreference-i-phantomreference.html)
WeakReference<Rectangle> rect = new WeakReference<Rectangle>(new Rectangle());
Когда GC определяет, что объект доступен только через weak-ссылки, то этот объект удаляется из памяти.
Выгодно использовать, в случаях, когда при удалении строгой ссылки, объект должен быть тоже удален

Тут стоить вспомнить про ReferenceQueue и проследить за порядком удаления объекта с памяти. 
Напомню что для WeakReference и SoftReference алгоритм попадания в ReferenceQueue одинаковый. 
Итак, запустился GC и определил что объект доступен только через weak-ссылки. Этот объект был создан так:
StrIngBuilder AAA = new StringBuilder(); ReferenceQueue queue = new ReferenceQueue();
WeakReference weakRef = new WeakReference(AAA, queue);

Сначала GC очистит weak-ссылку, то есть weakRef.get() – будет возвращать null. 
Потом weakRef будет добавлен в queue и соответственно queue.poll() вернет ссылку на weakRef. 
Теперь посмотрим, как это можно использовать.

WeakReference отлично подходит для хранения метаданных, например, для хранения ссылки на ClassLoader. 
Если ни один класс не загружен, то не стоит ссылаться на ClassLoader.
Именно поэтому WeakReference делает возможность сборщику мусора выполнить свою работу с ClassLoader, как только на него удалится последняя сильная ссылка.

// какой-то объект
Student student = new Student();
// слабая ссылка на него
WeakReference<Student> weakStudent = new WeakReference<Student>(student);
// теперь объект Student может быть собран сборщиком мусора
student = null;

В качестве примера использования такой структуры данных можно привести следующую ситуацию: 
допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. 
В этом случае добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения - нужную информацию. 
Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. 
Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из WeakHashMap.

4. фантомные ссылки (PhantomReference). 
ReferenceQueue<Object> queue = new ReferenceQueue<>();
PhantomReference<Object> rect = new PhantomReference<Object>(new Object(), queue);

Резюме:
Фантомная ссылка попадает в очередь, когда не осталось ни Strong, WeakReference или SoftReference ссылок после вызова метода finalize().
Метод get() из ссылки всегда возвращает null, чтобы мы не могли получить ссылку на объект и восстановить его. 
Таким образом, когда ссылка появляется в очереди, это значит, что объект наверняка будет удален.
Также этот тип ссылки используется для очистки ресурсов объекта перед его удалением.

Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок.
Применение PhantomReference связано с тонкостями метода finalize() и является альтернативой его переопределения.
PhantomReference может использоваться в ситуациях, когда использование finalize() не имеет смысла.
Он является сигналом о том, что объект уже финализирован и сборщик мусора готов вернуть свою память.
PhantomReference - самая слабая ссылка. Одна из тонкостей в том, что объект по фантомной ссылке недоступен сразу, хотя еще не удален из памяти. 

1. Сборщик удаляет любой объект условно в два «прохода».
+ В первый проход он только смотрит на объекты, и, если надо, помечает его как «ненужный, подлежащий удалению». 
Если у этого объекта был переопределен метод finalize(), он вызывается. Или не вызывается — поведение finalize() точно не предугадать.
+ Во второй проход сборщика объект  удаляется, и память освобождается. 
Такое непредсказуемое поведение сборщика мусора создает для нас ряд проблем:

Мы не знаем когда именно начнется работа сборщика мусора. Мы не знаем будет ли вызван метод finalize(). 
Плюс ко всему, во время работы finalize() может быть создана strong-ссылка на объект, и тогда он вообще не будет удален. 
В системах, требовательных к объему свободной памяти, это может легко привести к OutOfMemoryError.

Все это подталкивает нас к использованию фантомных ссылок:
Если на объект остались только фантомные ссылки, то у него:
+ вызывается метод finalize() (если он переопределен);
+ **если после работы finalize() ничего не изменилось и объект все еще может быть удален, фантомная ссылка на объект помещается в специальную очередь — ReferenceQueue.**
+ **Самое важное, что нужно понимать при работе с фантомными ссылками, — объект не удаляется из памяти до тех пор, пока его фантомная ссылка находится в этой очереди.
Он будет удален только после того, как у фантомной ссылки будет вызван метод clear().**

[Пример использования:](https://javarush.ru/groups/posts/2291-osobennosti-phantomreference)
Фантомная ссылка позволяет точно узнать, что объект удален из памяти. Для этого мы наследуемся от ее класса, 
и добавляем к методу clear выведение информации об успешном удалении ("объект удален").
Далее создаем поток, который постоянно проверяет очередь, и когда в ней появляется фантомная ссылка, мы получаем ее и вызываем метод cleanup(), 
в котором находится метод clear() фантомной ссылки и оповещение об удалении.
Reference ref = null;
//ждем, пока в очереди появятся ссылки
while ((ref = referenceQueue.poll()) == null) {
Далее ((MyPhantomReference) ref).cleanup(); выведет нам - "объект удален".
Теперь мы точно знаем, что объект удален. 
Также таким образом можно освободить ресурсы, связанные с объектом перед его удалением. (например закрыть потоки)

Дополнительно:
Разница в том, что здесь обязательно объявление объекта очереди queue - это представитель класса ReferenceQueue. 
Их функция в том, что когда объект доступный с помощью ссылки удаляется, 
то сам объект ссылки становится доступным в очереди ReferenceQueue. Этот механизм позволяет удалять пустые ссылки.
Слабая ссылка помещается в очередь перед тем, как объект на который она указывает будет финализирован (finalize()) и удален сборщиком мусора.
Т.е. в методе finalize() удаляемого объекта можно назначить строгую ссылку на удаляемый объект, и таким образом "спасти" его от сборщика мусора.
Но слабая ссылка уже будет в очереди и будет уничтожена.
В свою очередь в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue послетого как выполниться метод finalize().

PhantomReference может быть собрана сборщиком мусора, если на объект нет сильных (Strong), слабых ссылок (WeakReference) или мягких (SoftReference).
Этот ссылочный тип отличается от других типов, поскольку он не предназначен для доступа к объекту. 
Он является сигналом о том, что объект уже финализирован и сборщик мусора готов вернуть свою память.
Для этого сборщик мусора помещает его в специальный ReferenceQueue для последующей обработки. 
ReferenceQueue — это место, куда помещаются ссылки на объекты для освобождение памяти.
Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти.
Например, рассмотрим приложение, которое имеет дело с большими изображениями.
Предположим, что мы хотим загрузить изображение в память, когда оно уже находится в памяти, которая готова для сборки мусора. 
В этом случае мы хотим подождать пока сборщик мусора убьет старое изображение и только потом загружать в память новое.
Здесь PhantomReference является гибким и безопасным выбором. Ссылка на старое изображение будет передана в ReferenceQueue после уничтожения старого объекта изображения.
Получив эту ссылку, мы можем загрузить новое изображение в память.
Отличие фантомной ссылки в том, что она помещается в очередь только "по факту" удаления объекта на который она указывает - это и есть её основная функция.

[к оглавлению](#Garbage-Collection)

## Расскажите про String pool, Int pool

Пул строк
Пул строк - это набор строк, который хранится в памяти Java heap. 
Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, 
используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.
Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
*Пул строк помогает экономить большой объем памяти*, но с другой стороны создание строки занимает больше времени.
Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, 
если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.
Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки,
а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.

Integer пул
Как работает кеширование при операции autoboxing?
Начиная с Java 1.5, для целочисленных значений в диапазоне от -128 до + 127 объекты-обёртки кешируются внутри для повторного использования.
- верхнюю границу можно изменять при помощи параметра запуска программы
- границы как и многое в джаве, зависят от конкретной реализации JVM
В классе-обёртке Integer есть внутренний класс IntegerCache. Он объявлен как private static. 
В этом внутреннем классе кешированные объекты находятся в массиве cache[]. 
Кеширование выполняется при первом использовании класса-обёртки. 
После первого использования, вместо создания нового экземпляра (кроме использования конструктора), используются кешированные объекты.

Код метода valueOf() класса Integer выгдядит так:
public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
}

Кэширование касается не только класса-оболочки Integer. Имеются аналогичные реализации кеширования для других классов-оболочек целочисленных типов:
ByteCache, ShortCache, LongCache, CharacterCache.
Кешированные объекты не используются при создании объекта-обёртки с помощью new().

Также есть аналогичная схема для Boolean, только в valueof(boolean) возвращаются просто константы.
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false); 

Примеры:
public class Temp {
    public static void main(String []args){
        Integer i1 = 10;
        Integer i2 = 10;
        System.out.println(i1 == i2);
    }
}
 напечатает он true.

А вот еще один код:
public class Temp {
    public static void main(String []args){
        Integer i1 = 130;
        Integer i2 = 130;
        System.out.println(i1 == i2);
    }
}
Этот код уже выведет false.

В Java есть пул(pool) целых чисел в промежутке [-128;127]. Т.е. если мы создаем Integer в этом промежутке, то вместо того, 
чтобы каждый раз создавать новый объект, JVM берет их из пула. Таким образом, в первом примере i1 и i2 указывают на один и тот же объект из пула, 
а во втором - создаются два разных объекта. Отсюда и результат. Стоит заметить, что в приведенных выше примерах не использовалось ключевое слово new.

public class Temp {
    public static void main(String []args){
        Integer i1 = new Integer(10);
        Integer i2 = new Integer(10);
        System.out.println(i1 == i2);
    }
}
Результатом будет false. Тут мы уже явно говорим, что хотим создать новый(new) объект, так что ссылки разные.

Устаревшие конструкторы Boolean:
System.out.println(new Boolean(true));
System.out.println(new Boolean("true"));
System.out.println(new Boolean("TRUE"));
System.out.println(new Boolean(false));
System.out.println(new Boolean("kek"));
System.out.println(new Boolean(null));

System.out.println(new Boolean(true)==true);

Вывод: true
       true
       true
       false
       false
       false
       true  
       
[к оглавлению](#Garbage-Collection)

## Расскажите о String.intern
https://jsehelper.blogspot.com/2016/01/java-core-3.html
Когда вызывается метод intern, если пул уже содержит строку, равную этому объекту , определяемому через метод  equals(Object), тогда возвращается строка из пула. 
Иначе, этот объект  добавляется к пулу и возвращается ссылка на этот объект. 
Метод intern() используется для хранения строк в пуле строк. Метод intern можно использовать, 
для добавления строки представленной оператором new("новая строка") или методом, 
тогда эта строка попадет в пул и не будет создан новый объект.

("ver" == "v" + "er" выдаст тру, конкатенация не появлияет на результат) 

Примерный алгоритм:
1) Создать множество (hash set) строк
2) Проверить, что строка (как последовательность символов), с которой вы имеете дело, уже в множестве
3) Если да, то использовать строку из множества
4) В противном случае, добавить эту строку в множество и затем использовать ее  

[к оглавлению](#Garbage-Collection)

## Что такое профайлер
Это инструмент для мониторинга производительности Java-приложений и отслеживания узких мест в коде Java.
Профайлер позволяет мониторить программу и анализировать процесс ее выполнения. В java  мы можем следить за работой JVM.
Например, мониторить используемую память, сборки мусора, создаваемые объекты и работающие потоки.  

[к оглавлению](#Garbage-Collection)

## Как использовать VisualVM
VisualVM — это встроенный в JDK профайлер.
Необходимо подключиться к интересующуему нас процессу, и можно мониторить его работу.

Профайлеры вносят свои собственные издержки, так что полезно потратить несколько минут на то, чтобы оценить их. 
Простейший способ обнаружить издержки сначала запустить приложение отдельно, а затем под профайлером, и измерить разницу в производительности. 
Сначала можно запустить приложение с параметром -verbose:gc,  чтобы увидеть циклы сбора мусора, а затем  с подключенным к нему профайлером.
С профайлером может появится последовательность циклов GC, которой в первом случае не было. Это издержки производительности профайлера.

Мы можем мониторить память, сборки мусора, работающие потоки, кол-во загруженных классов и создаванных объектов.
Для анализа можно наблюдать графики, следить за количественным представлением или создать дамп кучи для автономного анализа.  

## Чем отличается sampling от profiling
https://coderlessons.com/articles/java/profilirovanie-java-pod-pokrovom
https://blog.idrsolutions.com/2014/04/profiling-vs-sampling-java-visualvm/

VisualVM’s profiler works by “instrumenting” all of the methods of your code.
This adds extra bytecode to your methods for recording when they’re called, and how long they take to execute each time they are.

VisualVM’s sampler, however, takes a dump of all of the threads of execution on a fairly regular basis, and uses this to work out how roughly how much CPU time each method spends.

При сэмплинге делается множество дампов для получения данных, при этом часть инф-ии может соотвественно теряться, но мы не меняем байткод.
При профайлинге используются инструментальные агенты - код, который следит за выполнением методов, мы получаем все данные, 
но меняется байткод, что может сломать программу или увеличить время работы. Но такой метод более точный.  

[к оглавлению](#Garbage-Collection)
 
## Расскажите о benchmark
https://www.baeldung.com/java-microbenchmark-harness 
https://yandex.ru/turbo/nuancesprog.ru/s/p/8792/
Бенчмарк (от англ. benchmark — «ориентир», «эталон»): Бенчмарк (программирование) — эталонный тест производительности компьютерной системы.

Java Microbenchmark Harness
Самый простой способ по-настоящему проверить свой код — это Java Microbenchmark Harness (JMH).
Он помогает оценить фактическую производительность, *принимая во внимание прогрев JVM и оптимизацию кода*, которые могут сделать результат неясным.
JMH стал де-факто стандартом для тестов производительности и был включен в JDK 12.

Алгоритм создания простого бенчмарка JMH:

1. Добавляем зависмости:
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.19</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.19</version>
</dependency>

2. Создаем бенчмарк методы, используя аннотацию @Benchmark:
```java
import org.openjdk.jmh.annotations.Benchmark;

public class BenchmarkDemo {
    @Benchmark
    public void benchmark1() {
    }

    @Benchmark
    public void benchmark2() {
    }
}

// Добавляем гланвый класс, который запускает бенчмарк процесс

public class BenchmarkRunner {
    public static void main(String[] args) throws Exception {
        org.openjdk.jmh.Main.main(args);
    }
}
```
Далее будет проведено опрделенное число итераций прогрева JVM  и итераций измерения для более точного результата.
В итоге мы получим сводную таблицу с результатами показателей производительности.

Result "gc.BenchmarkDemo.benchmark2":
819726266,834 ±(99.9%) 50134336,159 ops/s [Average]
(min, avg, max) = (125549633,730, 819726266,834, 1018254832,141), stdev = 212271918,539
CI (99.9%): [769591930,675, 869860602,993] (assumes normal distribution)
  
Benchmark                  Mode  Cnt          Score          Error  Units
BenchmarkDemo.benchmark1  thrpt  200  868453297,232 ± 45812959,657  ops/s
BenchmarkDemo.benchmark2  thrpt  200  819726266,834 ± 50134336,159  ops/s
(ops -operations per second)

JMH supports some possible benchmarks: Throughput, AverageTime, SampleTime, and SingleShotTime. 
Также мы можем изменять настройки бенчмарка:

By using the @Fork annotation, we can set up how the benchmark execution happens: the value parameter controls
how many times the benchmark will be executed, and the warmup parameter controls how many times a benchmark will dry run before results are collected, for example:

@Benchmark
@Fork(value = 1, warmups = 2)
@BenchmarkMode(Mode.Throughput)
public void init() {
    // Do nothing
}
Эта инструкция говорит запустить два прогревочных бенчамарка и отбросить результаты, прежде чем начать реальный бенчмарк.
This instructs JMH to run two warm-up forks and discard results before moving onto real timed benchmarking.
Also, the @Warmup annotation can be used to control the number of warmup iterations. For example, @Warmup(iterations = 5)
tells JMH that five warm-up iterations will suffice, as opposed to the default 20.

## Расскажите о методе finalized
@Deprecated(since="9")
protected void finalize() throws Throwable { }

В классе Object finalize не выполняет никакого действия, но наследник может переопределить его.
Например, finalize для объекта, который представляет Connection может закрыть соединение, до того как объект будет удален, т.е. очистит ресурсы.

Finalize –  определен в классе Object, таким образом, доступен для всех без исключения объектов в Java.
finalize() вызывается в исполняющей среде Java непосредственно перед удалением объекта.
Таким образом, сборщик мусора вызывает его для объектов, на которые больше нет ссылок и которые помечены для сбора мусора.

Предназначен этот метод для автоматического освобождения системных ресурсов, занимаемых объектом, на котором будет данный метод вызван.(но не рекомендуется) 
Это кажется удобным, чтобы не помнить постоянно, например, что мы должны закрыть соединение с каким-то ресурсом, когда оно больше не требуется.

Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод finalize(). 
Поэтому Не стоит полагаться на finalize для чистки данных. Во-первых, нет гарантии, что он будет вызван, т.к. где-то может остаться ссылка на объект. 
Во-вторых, нет гарантии на то, в какое время будет вызван метод. Это связано с тем, что после того, как объект становится доступным для сборки,
если в нем переопределен метод finalize, то он не вызывается сразу, а помещается в очередь, которая обрабатывается специально созданным для этого потоком. 
Когда объекты становятся ненужными, они попадут в очередь на финализацию и определенное время еще будут занимать память, вместо того, чтобы миновать этой очереди и сразу утилизироваться.
Стоит отметить, что в очередь на финализацию попадают только те объекты, в которых переопределен метод finalize.
Есть вероятность, что этот метод не будет вызван совсем.

(Есть один способ быть уверенным, что finalize-методы были запущены для объектов, доступных для сборки: вызвать System.runFinalization() или Runtime.getRuntime().runFinalization(). 
Выход из метода осуществляется только тогда, когда все доступные методы объектов для финализации будут выполнены)

finalize() необходим при работе с нативным кодом и освобождения ресурсов там, а исключить вероятность работы Java с С-кодом нельзя.
**И самое главное - начиная с Java 9 этот метод не рекомендуется к использованию.** Но все таки приведем пример его использования.

```java
public class Cup {
    private Spoon spoon;

    public Cup(Spoon spoon) {
        this.spoon = spoon;
    }

    @Override
    protected void finalize()  {
        System.out.println("Чашка исчезает навсегда");
    }

    public static void main(String[] args) {
        Cup cup = new Cup(new Spoon());
        cup = null;
        System.gc();
     }
}
```  

[к оглавлению](#Garbage-Collection)

## Расскажите о методе clone
(Deep clone and shallow clone)
[ссылка](https://www.examclouds.com/ru/java/java-core-russian/cloning)

Бывают случаи, когда надо получить копию объекта, которая НЕ зависит от оригинала. Этот процесс в Java называется клонированием.

Для клонирования объекта в Java можно воспользоваться тремя способами:
+ Переопределение метода clone() и реализация интерфейса Cloneable().
+ Использование конструктора копирования.
+ Использовать для клонирования механизм сериализации.

protected native Object clone() throws CloneNotSupportedException;
Creates and returns a copy of this object.  The precise meaning of "copy" may depend on the class of the object.

- Private — объявляет метод или свойство доступным только в том классе в котором он присутствует. Тоесть к private методам и свойствам мы не можем обращаться ни из объектов, ни из дочерних классов.
- Protected — объявляет метод или свойство защищенными. Тоесть такими, которые не могут быть доступны из объекта, реализующего класс(только если объект не создан внутри самого класса), но вполне может быть использовано в дочерних классах.
- Public — публичный. Классы и методы, объявленные public, могут быть доступны как внутри самого класса, так и в дочерних классах и в объектах, реализовавших класс.

The general intent is that, for any object {@code x}, the expression:
- x.clone() != x will be true, and that the expression:
- x.clone().getClass() == x.getClass() will be {@code true}, but these are not absolute requirements.
While it is typically the case that:
- x.clone().equals(x) will be {@code true}, this is not an absolute requirement.

Класс Object определяет метод clone(), который создает копию объекта. 
Если вы хотите, чтобы экземпляр вашего класса можно было клонировать, необходимо переопределить этот метод и реализовать интерфейс Cloneable. 
Интерфейс Clonable - это интерфейс-маркер, он не содержит ни методов, ни переменных. Интерфейсы-маркер просто определяют поведение классов.
*Object.clone() выбрасывает исключение CloneNotSupportedException при попытке клонировать объект не реализующий интерфейс Cloneable.*

Метод clone() в родительском классе Object является protected, поэтому желательно переопределить его как public. 
Реализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование. Рассмотрим пример:

*Shallow clone* (Поверхностное клонирование)
```java
public class Car implements Cloneable {
    private String name;
    private Driver driver;

    public Car(String name, Driver driver) {
        this.name = name;
        this.driver = driver;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Driver getDriver() {
        return driver;
    }
    public void setDriver(Driver driver) {
        this.driver = driver;
    }

    @Override
    public Car clone() throws CloneNotSupportedException {
        return (Car) super.clone();
    }
}

public class Driver implements Cloneable {
    private String name;
    private int age;

    public Driver(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public Driver clone() throws CloneNotSupportedException {
        return (Driver) super.clone();
    }
}

public class CloneCarDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        Car car = new Car("Грузовик", new Driver("Василий", 45));
        Car clonedCar = car.clone();
        System.out.println("Оригинал:\t" + car);
        System.out.println("Клон:   \t" + clonedCar);

        Driver clonedCarDriver = clonedCar.getDriver();
        clonedCarDriver.setName("Вася");

        System.out.println("Оригинал после изменения имени водителя:\t" + car);
        System.out.println("Клон после изменения имени водителя:   \t\t" + clonedCar);
    }
}
```
В этом примере клонируется объект класса Car. Клонирование выполняется поверхностное - новый объект clonedCar содержит ссылку на тот же объект класса Driver,
что и объект car. Если вас это не устраивает, то необходимо самим написать "глубокое" клонирование - создать новый объект класса Driver. Перепишем метод clone() класса Car:
Пример 2. Deep clone (Глубокое клонирование):

@Override
public Car clone() throws CloneNotSupportedException {
    Car newCar = (Car) super.clone();
    Driver driver = this.getDriver().clone();
    newCar.setDriver(driver);
    return newCar;
}

*Т.е. в этом случае мы также клонируем целевой объект, затем клонируем у целевого объекта клонируем отдельные поля и сетим эти поля в клон объекта.*

3. Конструктор копирования
Еще один вариант клонирования объекта - это конструктор копирования. Создается конструктор, принимающий на вход объект того же класса, который необходимо клонировать:

Пример 3. Конструктор копирования с поверхностным клонированием

```java
public class Car implements Cloneable {
    private String name;
    private Driver driver;

    public Car(String name, Driver driver) {
        this.name = name;
        this.driver = driver;
    }

    /**
     * Конструктор копирования.
     *
     * @param otherCar
     */
    public Car(Car otherCar) {
        this(otherCar.getName(), otherCar.getDriver());
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Driver getDriver() {
        return driver;
    }

    public void setDriver(Driver driver) {
        this.driver = driver;
    }
}
```
Опять же  - пример показывает неглубокое клонирование. Перепишем конструктор для реализации "глубокого" копирования:

Пример 4.  Конструктор копирования с "глубоким" клонированием
public Car(Car otherCar) throws CloneNotSupportedException {
    this(otherCar.getName(), otherCar.getDriver().clone());
}  

[к оглавлению](#Garbage-Collection)

## Расскажите о Stack, Heap
Критерии оценки сборщиков:
+ Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются stop-the-world (или STW).
+ Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
+ Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

Понятно, что добиться улучшения всех трех параметров одновременно практически невозможно. 
Уменьшение максимального времени задержки приводит к учащению сборки мусора, уменьшая пропускную способность.
Либо приходится использовать более ухищренные алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов.
JVM

[Стек и куча в Java](https://topjava.ru/blog/stack-and-heap-in-java)
JVM разделяет используемую ею память на две области: куча (heap), в которой хранятся данные приложения, и не-куча (non-heap), в которой хранится код программы и другие вспомогательные данные.
Metaspace: тут Java хранит малоизменяемою информацию программы, например классы
Heap space: тут Java хранит изменяемый контент
Stack space: тут Java хранит выполнение функций и ссылки на переменные

1. Стек
Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
Стек работает по схеме LIFO (последним вошел, первым вышел). 
Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.
Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится доступным для следующего метода. 
 
Основные особенности стека
Помимо того, что мы рассмотрели, существуют и другие особенности стека:

+ Он заполняется и освобождается автоматически - по мере вызова и завершения новых методов
+ Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
+ Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи
+ является потокобезопасным, поскольку для каждого потока создается свой отдельный стек
+ Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError

Вы можете использовать -Xss для настройки начального размера стека. 
Затем стек динамически растет в соответствии с потребностями программы.
2. Куча

Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.  

Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
1. Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора.
2. Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают определенного порога «возраста», они перемещаются в Old Generation.
3. Metaspace хранит системную информацию. В Metaspace виртуальная машина хранит **метаданные загруженных классов**,**всё статическое содержимое приложения**, 
переменные примитивных типов и ссылки на статические объекты, данные о байткоде и JIT информацию.
По умолчанию, Metaspace увеличивается автоматически. Максимальный размер Metaspace по умолчанию не ограничен ничем кроме предела объёма нативной памяти.
Нативная память - это вся память, которую JVM может использовать для своих нужд. (сюда входит также и стек, и хип.) [Распределение памяти в JVM](https://habr.com/ru/company/otus/blog/445312/)
Однако и здесь у нас есть возможность управления памятью. В результате появления Metaspace, процесс очистки памяти получил некоторые преимущества. 
Теперь сборщик мусора автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает максимального значения. 
До Metaspace был PermGen, который был ограничен по размеру.
Вместе с этим, уменьшилась вероятность получения ошибки OutOfMemoryError.

[Metaspace](https://topjava.ru/blog/permgen-and-metaspace)

Основные особенности кучи

+ Доступ к ней медленнее, чем к стеку, т.к. доступ к этой памяти осуществляется с помощью сложных методов управления памятью, включая Young Generation, Old и Permanent Generation.
+ Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик мусора
+ Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
+ В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код
+ Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
+ Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .
+ Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError

| Свойства                    | Стек                    | Куча                         |
| -------------               |:-------------:          | :-----:                       |
| Использование приложением                   | Для каждого потока используется свой стек           | Пространство кучи является общим для всего приложения                       |
| Размер                    | Предел размера стека определен операционной системой.                |   Размер кучи не ограничен                        |
| Хранение               | Хранит примитивы и ссылки на объекты                |   Все созданные объекты хранятся в куче                      |
|Порядок                 |Работает по схеме последним вошел, первым вышел (LIFO)|  Доступ к этой памяти осуществляется с помощью сложных методов управления памятью, включая Young Generation, Old и Permanent Generation|
|Существование|Память стека существует пока выполняется текущий метод|  Пространство кучи существует пока работает приложение|
|Скорость|Обращение к памяти стека происходит значительно быстрее, чем к памяти кучи| Медленнее, чем стек |
|Выделение и освобождение памяти|Эта память автоматически выделяется и освобождается, когда метод вызывается и завершается соответственно| Память в куче выделяется, когда создается новый объект и освобождается сборщиком мусора, когда в приложении не остается ни одной ссылки на его |  

[к оглавлению](#Garbage-Collection)

