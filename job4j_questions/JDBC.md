## SQL  
  
**JDBC:**
 + [Что такое JDBC API и когда его используют?](#Что-такое-JDBC-API-и-когда-его-используют)  
 + [Опишите процесс создания запроса через JDBC](#Опишите-процесс-создания-запроса-через-JDBC)  
 + [Как JDBC API помогает достичь слабой связи между Java программой и JDBC Drivers API?](#Как-JDBC-API-помогает-достичь-слабой-связи-между-Java-программой-и-JDBC-Drivers-API)
 + [Как используется JDBC DriverManager class?](#Как-используется-JDBC-DriverManager-class)
 + [Расскажите о JDBC DataSource. Какие преимущества он дает?](#Расскажите-о-JDBC-DataSource-Какие-преимущества-он-дает)
 + [Что такое JDBC Connection? Покажите шаги для подключения программы к базе данных.](#Что-такое-JDBC-Connection-Покажите-шаги-для-подключения-программы-к-базе-данных)
 + [Как получить информацию о сервере базы данных из java программы?](#Как-получить-информацию-о-сервере-базы-данных-из-java-программы)
 + [Что такое JDBC Statement?](#Что-такое-JDBC-Statement)
 + [Какие различия между execute, executeQuery, executeUpdate?](#Какие-различия-между-execute-executeQuery-executeUpdate)
 + [Escape-последовательности в запросах Statement](#Escape-последовательности-в-запросах-Statement)
 + [Что такое JDBC PreparedStatement?](#Что-такое-JDBC-PreparedStatement)
 + [Как установить NULL значения в JDBC PreparedStatement?](#Как-установить-NULL-значения-в-JDBC-PreparedStatement)
 + [Как используется метод getGeneratedKeys в Statement?](#Как-используется-метод-getGeneratedKeys-в-Statement)
 + [Какие преимущества в использовании PreparedStatement над Statement?](#Какие-преимущества-в-использовании-PreparedStatement-над-Statement)
 + [Какие есть ограничения PreparedStatement и как их преодолеть?](#Какие-есть-ограничения-PreparedStatement-и-как-их-преодолеть)
 + [Что такое JDBC ResultSet?](#Что-такое-JDBC-ResultSet)
 + [Какие существуют различные типы JDBC ResultSet?](#Какие-существуют-различные-типы-JDBC-ResultSet)
 + [Как используются методы setFetchSize и SetMaxRows в Statement?](#Как-используются-методы-setFetchSize-и-SetMaxRows-в-Statement)
 + [Как вызвать Stored Procedures используя JDBC API?](#Как-вызвать-Stored-Procedures-используя-JDBC-API)
 + [Что такое JDBC Batch Processing и каковы его преимущества?](#Что-такое-JDBC-Batch-Processing-и-каковы-его-преимущества)
 + [Что такое JDBC Transaction Management и зачем он нужен?](#Что-такое-JDBC-Transaction-Management-и-зачем-он-нужен)
 + [Как откатить JDBC транзакцию?](#Как-откатить-JDBC-транзакцию)
 + [Что такое JDBC Savepoint и как он используется?](#Что-такое-JDBC-Savepoint-и-как-он-используется)
 + [Расскажите про Apache DBCP API.](#Расскажите-про-Apache-DBCP-API)
 + [Какие вы знаете уровни изоляции транзакций в JDBC?](#Какие-вы-знаете-уровни-изоляции-транзакций-в-JDBC)
 + [Что вы знаете о JDBC RowSet? Какие существуют различные типы RowSet?](#33-Что-вы-знаете-о-JDBC-RowSet-Какие-существуют-различные-типы-RowSet)
 + [В чем разница между ResultSet и RowSet?](#В-чем-разница-между-ResultSet-и-RowSet)
 + [Приведите пример наиболее распространенных исключений в JDBC.](#Приведите-пример-наиболее-распространенных-исключений-в-JDBC)
 + [Расскажите о типах данных CLOB и BLOB в JDBC.](#Расскажите-о-типах-данных-CLOB-и-BLOB-в-JDBC)
 + [Что вы знаете о «грязном чтении» dirty read в JDBC? Какой уровень изоляции предотвращает этот тип чтения?](#Что-вы-знаете-о-«грязном-чтении»-dirty-read-в-JDBC-Какой-уровень-изоляции-предотвращает-этот-тип-чтения)
 + [Какие есть две фазы commit?](#Какие-есть-две-фазы-commit)
 + [Приведите пример различных типов блокировки в JDBC.](#Приведите-пример-различных-типов-блокировки-в-JDBC)
 + [Как вы понимаете DDL и DML выражения?](#Как-вы-понимаете-DDL-и-DML-выражения)
 + [Какая разница между java.util.Date и java.sql.Date?](#Какая-разница-между-javautilDate-и-javasqlDate)
 + [Как вставить изображение или необработанные данные в базу данных?](#Как-вставить-изображение-или-необработанные-данные-в-базу-данных)
 + [Что вы можете рассказать о фантомном чтении? Какой уровень изоляции его предотвращает?](#Что-вы-можете-рассказать-о-фантомном-чтении-Какой-уровень-изоляции-его-предотвращает)
 + [Что такое SQL Warning? Как возвратить SQL предупреждения в JDBC программе?](#Что-такое-SQL-Warning-Как-возвратить-SQL-предупреждения-в-JDBC-программе)
 + [Как запустить Oracle Stored Procedure с объектами базы данных INOUT?](#Как-запустить-Oracle-Stored-Procedure-с-объектами-базы-данных-INOUT)
 + [Приведите пример возникновения java.sql.SQLException: No suitable driver found.](#Приведите-пример-возникновения-javasqlSQLException-No-suitable-driver-found)
 + [Best Practices в JDBC.](#Best-Practices-в-JDBC)
 + [Что такое ORM](#Что-такое-ORM)   
 
## JDBC 
  
## Что такое JDBC API и когда его используют
JDBC  (Java DataBase Connectivity) — интерфейс (стандарт/API) взаимодействия Java-приложений с различными СУБД. 
(библиотека с интерфейсами взаимодействия с бд) 
Реализован в виде пакета java.sql, входящего в состав Java SE. JDBC основан на концепции драйверов, 
позволяющей получать соединение с БД по специальному url.     
Драйвер JDBC — это сущность, которая реализует определённые интерфейсы JDBC API,
которые преобразуют запросы из программ Java в протокол, понятный СУБД.  

JDBC-драйвер – это конкретная реализация JDBC для определенной СУБД. 
(JDBC содержит интерфейсы, а драйвер классы, которые их реализуют для конкретной СУБД. Их мы подгружаем с помощью зависмости в помнике) 
Он преобразует запросы из программ Java в протокол, понятный СУБД.
В приложении может быть зарегистрировано несколько разных драйверов. (Драйверы делятся на 4 типа.)

Драйвер  загружается один раз с помощью Class.forName() в набор драйверов:    
Class.forName(config.getProperty("driver-class-name"));  
Connection connection = DriverManager.getConnection(config.getProperty("url"), config.getProperty("username"), config.getProperty("password"));    
Получаем коннекшен, с использованием конкретного драйвера. (При соединении к базе, нужный выбирается исходя из URL соединения. 
Например, для jdbc:mysql://localhost:3306/db_name будет использован MySQL JDBC драйвер (при наличии))  
[подробнее](https://javarush.ru/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja)    

[к оглавлению](#SQL)  

## Как JDBC API помогает достичь слабой связи между Java программой и JDBC Drivers API
  
JDBC API используют рефлексию в java для достижения слабой связи между джава программой и JDBC драйверами. 
Драйвер фактически загружается один раз с помощью Class.forName(), а дальше используются возможности JDBC API в Java. 
Таким образом мы пишем код не особо задумываясь какая база данных работает "под капотом". 
При необходимости достаточно указать другой драйвер и не переписывать большое количество кода.
  
[к оглавлению](#SQL)  
 
## Как используется JDBC DriverManager class
 
JDBC DriverManager — фабрика, через которую можно получить объект Database Connection. 
После загрузки JDBC драйвера в память, он регистрирует себя в DriverManager (что можно проверить посмотрев в исходники 
JDBC Driver class). DriverManager используется для получения подключения с помощью зарегистрированных драйверов. 
(метод getConnection())  
 
[к оглавлению](#SQL)  

## Расскажите о JDBC DataSource Какие преимущества он дает  
Класс DataSource предоставляет соединение с сервером БД в виде класса, реализующего интерфейс java.sql.Connection.
То есть, DataSource управляет соединением с базой данных.
JDBC DataSource является интерфейсом пакета javax.sql и является более продвинутым в сравнении с DriverManager 
для подключения к базе данных.  
В дополнение к соединению через Database, DataSource предоставляет следующие дополнительные возможности:

+ Кэширование PreparedStatement для ускорения обработки запросов
+ Настройки Connection timeout
+ Возможности логирования
+ Порог максимального размера ResultSet
+ Поддержка Connection Pooling в контейнере сервлетов, использующий поддержку JNDI.

[к оглавлению](#SQL)  

## Что такое JDBC Connection Покажите шаги для подключения программы к базе данных
  
JDBC Connection — соединение, установленное с сервером базы данных. 
Это своего рода сессия или Socket Connection. Для создания JDBC connection требуется всего два шага:
1) Зарегистрировать и загрузить драйвер с помощью Class.forName(). Класс драйвера будет зарегистрирован для DriverManager 
и загружен в память.
2) Используя DriverManager.getConnection() получить объект Connection. 
В метод необходимо передать URL базы данных, имя и пароль.
  ```sql
  Connection con = null;
  try{
      // load the Driver Class
      Class.forName("com.mysql.jdbc.Driver");
   
      // create the connection now
      con = DriverManager.getConnection("jdbc:mysql://localhost:3306/UserDB",
                      "pankaj",
                      "pankaj123");
      }catch (SQLException e) {
              System.out.println("Check database is UP and configs are correct");
              e.printStackTrace();
      }catch (ClassNotFoundException e) {
              System.out.println("Please include JDBC MySQL jar in classpath");
              e.printStackTrace();
      }
  ```
  [к оглавлению](#SQL)
 
## Как получить информацию о сервере базы данных из java программы
 
С помощью объекта интерфейса DatabaseMetaData можно получить детальную информацию о сервере. 
После подключения к БД мы можем вызывать метод getMetaData() и получить объект DatabaseMetaData. 
Существует множество методов для получения различной информации, например о версии БД, конфигурации и т.п.
```sql
DatabaseMetaData metaData = con.getMetaData();
String dbProduct = metaData.getDatabaseProductName();
```
[к оглавлению](#SQL)
 
## Что такое JDBC Statement  
[подробнее](http://java-online.ru/jdbc-statement.xhtml)  
 
JDBC API Statement используется для выполнения SQL запросов к базе данных.  

Statement, базовый;  
PreparedStatement, наследующий от Statement;  
CallableStatement : SQL выражение с возможностью получить возвращаемое значение из хранимых процедур (SQL Stored Procedures)      

Объект Statement можно получить с помощью метода Connection.getStatement(). 
Вызывая методы execute(), executeQuery(), executeUpdate() и др., можно выполнять различные статичные SQL запросы.
 
В случае динамически созданных SQL запросов внутри java программы, когда введенные пользователем данные могут быть 
не проверенными, можно использовать SQL injection.
 
По умолчанию только один объект ResultSet для каждого Statement может быть открыт в одно и то же время. 
Таким образом, если необходимо работать с несколькими объектами ResultSet одновременно, мы должны использовать различные 
объекты Statement. Все execute() методы в интерфейсе Statement закроют текущий открытый объект ResultSet при выполнении.  

[к оглавлению](#SQL)  
 
## Опишите процесс создания запроса через JDBC  
+ Загрузка драйвера базы данных. Для загрузки/использования нашего драйвера можно пойти двумя путями. 
Первый – это вписать имя драйвера в код программы. В этом случае мы не сможем изменить СУБД без перекомпиляции. 
Второй – это подключать драйвер из командной строки Java (JVM). 
Следующей строчкой мы загружаем драйвер, и он автоматически зарегистрируется себя для использования вместе с JDBC.
```java
Class.forName(“postgresql.Driver”);
```
Во втором же случае мы используем ключ –D для подключения драйвера.
```java
java –Djdbc.drivers=postgresql.Driver myClass
 ```
  + Для соединения с базой данных используют класс Connection:
  ```java
  Connection dbh = DriverManager.getConnection(url, user, passwd);
  ```
  + Установив соединение, мы можем выполнять sql-запросы к нашей базе данных. 
  Для примера, рассмотрим небольшой кусок кода на Java:
  ```java
  Statement st = dbh.createStatement();
  
  ResultSet rs = st.executeQuery(
  "select * from flowers_tbl where (flowers_id in (1,2,3,4,5,6,7,8,9))"
  );
  
  while (rs.next())
  {
    System.out.println(rs.getString(1));
  }
  rs.close();
  st.close();
  ```  
Для того, чтобы посылать запросы к базе данных, необходимо создать экземпляр класса Statement st. 
Метод executeQuery этого класса отправляет переданный ему запрос к базе данных и в качестве ответа возвращает результат 
в виде класса ResultSet.
  
В конце надо закрыть все ресурсы.  
  
[к оглавлению](##SQL)  
  
## Какие различия между execute executeQuery executeUpdate

Существует несколько способов выполнять SQL-запросы в зависимости от типа этого запроса. 
Для этого у интерфейса Statement существует три различных метода: executeQuery(), executeUpdate(), а так же execute(). 
Рассмотрим их отдельно.

Самый базовый метод executeQuery() (для селктов) необходим для запросов, результатом которых является один единственный набор значений, 
таких как у запросов SELECT. Возвращает ResultSet, который не может быть null даже если у результата запроса 
не было найдено значений.  

Метод executeUpdate() используется для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов 
DDL (Data Definition Language — язык определения данных), например, CREATE TABLE и DROP TABLE. 
Результатом оператора INSERT, UPDATE, или DELETE является модификация одной или более колонок в нуле или более строках таблицы. 
Метод executeUpdate() возвращает целое число, показывающее, сколько строк было модифицировано. 
Для выражений типа CREATE TABLE и DROP TABLE, которые не оперируют над строками, возвращаемое методом executeUpdate() 
значение всегда равно нулю.

Метод execute используется, когда операторы SQL возвращают более одного набора данных, более одного счетчика обновлений или и то, и другое.
Такая возможность редко используется программистами.    

Все методы выполнения SQL-запросов закрывают предыдущий набор результатов (result set) у данного объекта Statement. 
Это означает, что перед тем как выполнять следующий запрос над тем же объектом Statement, 
надо завершить обработку результатов предыдущего (ResultSet).  
Объекты Statement закрываются автоматически сборщиком мусора виртуальной машины Java. 
Тем не менее рекомендуется закрывать их явно после того, как работа с ними завершена. 
Закрытие объектов Statement после их использования освобождает ресурсы СУБД и позволяет избежать проблем с памятью.

[к оглавлению](#SQL)  

## Escape-последовательности в запросах Statement  
Объекты Statement могут содержать SQL‑выражения т.н. escape‑синтаксисом – синтаксисом подстановки. 
Escape‑конструкция сигнализирует драйверу о том, что код внутри нее должен обрабатываться особо. 
Драйвер сканирует выражение и находит escape‑последовательности, которые затем заменяются кодом, специфичным для данной СУБД. 
Escape‑синтаксис независим от СУБД и позволяет программисту использовать возможности СУБД, которые иначе никак не доступны.  

1. escape-последовательность с символом
Операция SQL типа LIKE использует шаблонные символы "%" и "_", которые используются для извлечения информации с определенными символами.
Чтобы эти символы интерпретировались в SQL-выражении без изменений, необходимо перед ними установить обратный символ слэша "\".
Этот специальный символ и называется escape-символом.  

В следующем коде осуществляется чтение строки, начинающейся со знака подчеркивания:  
stmt.executeQuery("SELECT name FROM GOODS WHERE NAME LIKE `\_%' {escape `\'};

[к оглавлению](#SQL)

## Что такое JDBC PreparedStatement

Объект PreparedStatement используется для выполнения предкомпилированных SQL-запросов с или без входных (IN) параметров. 
Мы можем использовать сеттеры для установки значений в запрос. Т.к. PreparedStatement является предкомпилированным, 
то он может быть эффективно использован множество раз. PreparedStatement считается лучшим выбором нежели Statement, т.к. 
он автоматически обрабатывает специальные символы, а так же предотвращает, так называемые, SQL injection attack 
(когда в запрос можно подставить свой код).

[к оглавлению](#SQL)

## Как установить NULL значения в JDBC PreparedStatement

Используя метод setNull() для установки null переменной в качестве параметра. 
Этот метод принимает индекс и SQL тип в качестве аргументов: s.setNull(10, java.sql.Types.INTEGER);

[к оглавлению](#SQL)

## Как используется метод getGeneratedKeys в Statement

Если в таблице используется автоматическая генерация ключей, то для их получения используется метод Statement getGeneratedKeys(), 
который вернет сгенерированный ключ.

[к оглавлению](#SQL)

## Какие преимущества в использовании PreparedStatement над Statement

+ PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы.
+ PreparedStatement позволяет использовать динамические запросы с внедрением параметров.
+ PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement 
или при использовании для вызова группы запросов.
+ PreparedStatement позволяет писать объектно-ориентированный код с использованием сеттеров\геттеров. 
В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. 
Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.

[к оглавлению](#SQL)

## Какие есть ограничения PreparedStatement и как их преодолеть

В PreparedStatement нельзя использовать напрямую запросы с IN (входными) параметрами. Есть некоторые обходные пути:

+ Выполнить Single Queries – низкая производительность и вообще не рекомендуется так делать.
+ Использовать Stored Procedure (хранимые процедуры) – являются специфичными для конкретной базы данных и следовательно 
плохи для приложений с возможностью подключения к различным БД.
+ Создание PreparedStatement Query динамически – это хорошее решение, но с потерей кэширования PreparedStatement.
+ Использование NULL в PreparedStatement Query – хорошее решение, если вы знаете максимальное число переменных IN. 
Можно расширить до использования неограниченного кол-во параметров с помощью разбиения на части.

[к оглавлению](#SQL)

## Что такое JDBC ResultSet

JDBC ResultSet — интерфейс, объект которого создается в результате запроса к базе данных. (это курсор субд)  
Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.
Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. 
При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). 
При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице 
полученных результатов.

По умолчанию объект ResultSet не модифицируемый и поддерживает курсор, который способен только к движение вперед. 
Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного 
движения по таблице, а так же возможности обновления:
```sql
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                   ResultSet.CONCUR_UPDATABLE);
```

Объект ResultSet автоматически закрывается при закрытии объекта, который его сгенерировал. 
Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.

Для использования геттера ResultSet можно использовать имя колонки или индекс, который начинается с 1.  
Ещё интересно, что через ResultSet можно обновлять или даже вставлять строки.  

ResultSet взаимодействует с БД и требует подключения к БД.

[к оглавлению](#SQL)

## Какие существуют различные типы JDBC ResultSet

При создании Statement можно задать различные типы получаемого ResultSet.

Три типа объектов ResultSet:

+ **ResultSet.TYPE_FORWARD_ONLY:** тип по умолчанию. Поддерживает движение курсора только в прямом направлении.
+ **ResultSet.TYPE_SCROLL_INSENSITIVE:** Двунаправленный курсор. Объект не чувствителен к изменениям, которые произошли с таблицей после получения результата.
+ **ResultSet.TYPE_SCROLL_SENSITIVE:** Двунаправленный курсор. Объект чувствителен к изменениям, которые произошли с базой данных после создания объекта ResultSet.

Два типа потокобезопасных объектов ResultSet:

+ **ResultSet.CONCUR_READ_ONLY:** Поддерживает только чтение (read only). Применяется по умолчанию.
+ **ResultSet.CONCUR_UPDATABLE:** Поддерживает метод ResultSet update для обновления строк в таблице данных.

[к оглавлению](#SQL)  

## Что вы знаете о JDBC RowSet Какие существуют различные типы RowSet

JDBC RowSet содержит табличные данные в более гибком формате по сравнению с ResultSet. 
Все объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet 
с некоторыми дополнительными функциями. RowSet интерфейс определяется в javax.sql пакета.  

RowSet расширяет ResultSet и делает его совместимым с концепцией JavaBean (то есть с конструктором по умолчанию, сериализуемым и т.д.)  
Главными отличиями RowSet от ResultSet является тот факт, что RowSet есть JavaBean, со свойствами и нотификациями.    
```java
public class RowSetDemo{
public void shouldUseRowSet() throws SQLException {
 	JdbcRowSet jdbcRs = new JdbcRowSetImpl(connection);
 	jdbcRs.setCommand("SELECT * FROM customers");
	jdbcRs.execute();
	jdbcRs.next();
	String name = jdbcRs.getString("name");
}
 ```     

Интересен не только такой подход, но и возможные реализации. Например, CachedRowSet. 
Он является "отключённым" (то есть не использует постоянное подключение к БД) и требует явного выполнения синхронизации с БД:
CachedRowSet jdbcRsCached = new CachedRowSetImpl();
jdbcRsCached.acceptChanges(connection);   

Можно выделить следующие дополнительные функции, предоставляемые RowSet:

Функции похожие на Java Beans со свойствами и get\set методами для работы с ними. RowSet использует модель событий JavaBeans. 
В результате можно посылать уведомления любого зарегистрированного компонента для таких событий, например, движение курсора, 
обновления / вставка / удаление из строки и изменять содержимое RowSet.
Объекты RowSet поддерживают скроллинг по данным (scrollable), а так же являются обновляемыми по умолчанию. 
Так что если СУБД не поддерживает скроллинг или обновляемый ResultSet, мы можем использовать RowSet, чтобы получить эти функции.

RowSet можно разделить на два типа:  
+ Connected RowSet Objects – эти объекты подключаются к БД и очень похожи на объекты ResultSet. 
JDBC API предоставляет только одно подключение объекта RowSet — javax.sql.rowset.JdbcRowSet 
и это является стандартной реализации класса com.sun.rowset.JdbcRowSetImpl.
+ Disconnected RowSet Objects – эти объекты RowSet не требуют подключения к базе данных. 
Они более легковесные и могут быть сериализованы. Такие объекты хорошо подходят для передачи данных по сети. 
Существуют четыре реализации такого типа объектов (disconnected RowSet objects).

Кратко рассмотрим четыре реализации Disconnected RowSet Objects:

+ CachedRowSet — объекты могут получить соединение и выполнить запрос, считать данные ResultSet для заполнения данных RowSet. 
Мы можем управлять и обновлять данные на время отключения от БД и записать измененные данные при очередном подключении.
+ WebRowSet получены из CachedRowSet — такие объекты могут читать и записывать XML документы.
+ JoinRowSet получены из WebRowSet — могут образовывать SQL JOIN без подключения к источнику данных.
+ FilteredRowSet получены из WebRowSet — поддержка применения критериев фильтрации, поэтому видны только выбранные (полученные) данные.

[к оглавлению](#SQL)

## В чем разница между ResultSet и RowSet

Объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet с некоторыми дополнительными функциями. 
Одним из существенных преимуществ является возможность работы с данными без соединения с базой, а так же их легковесность 
и возможности пересылки данных объектов по сети.

Следует ли использовать ResultSet или RowSet зависит от ваших требований. ResultSet, возможно, подойдет к длительным подключениям, 
в то время как RowSet будет лучшим выбором для подключений к базам данных с возможностью дисконекта и обработки полученных данных.  

ResultSet vs RowSet
Что же выбрать? Оба интерфейса выглядят хорошо и сравнительно одинаково. Какой из них использовать? 
Ответ мой любимый: «это зависит». С одной стороны, ResultSet выглядит более низкоуровневым и неудобным.
В RowSet можно и listeners приделывать и в памяти сразу фильтровать и работать с данными в отсутствие базы
(и обновлять кстати можно тоже). Но. Цена этого удобства — память.
ResultSet в общем виде может не иметь доступа более чем к одной строке результатов и обращаться к базе при каждом движении указателя.
И это хорошо: во-первых можно начинать работу с данными, когда они только начали поступать, не дожидаясь, пока сформируется весь ответ.
Во-вторых, если данных слишком много, а памяти слишком мало, может не получиться их обработать. 
Я могу дать только такой совет: если вам нужен функционал RowSet, используйте его. Если нет, выбирайте по ситуации, что использовать.  
 
[к оглавлению](#SQL)

## Как используются методы setFetchSize и SetMaxRows в Statement

Для ограничения количества строк, которые может вернуть запрос, применяется метод setMaxRows(int i). 
Конечно, этот результат можно получить используя SQL запрос (например для MySQL существует команда LIMIT).

Для понимания метода setFetchSize() необходимо разобраться с работой Statement и ResultSet. 
Когда выполняется запрос к базе данных, результат обрабатывается и сохраняется в кэше базы данных и возвращается в виде ResultSet. 
ResultSet является курсором, которые ссылается на результат в базе данных. Теперь допустим мы имеем запрос, 
который возвращает 100 строк и мы установили setFetchSize(10). Теперь для каждого обращения к базе данных выделено только 10 строк 
и понадобится 10 запросов, чтобы получить все данные. Выбор оптимального количества fetchSize() может улучшить производительность 
выполнения большого кол-ва обращений к каждой строке и в случае большого количества строк в выходном результате.

Значение fetchSize можно указать внутри объекта Statement, но оно может быть переопределено в объекте ResultSet с помощью setFetchSize().

[к оглавлению](#SQL)

## Как вызвать Stored Procedures используя JDBC API

Хранимые процедуры — это группы SQL запросов, которые компилируются в базе данных и могут быть вызваны с помощью JDBC API. 
Для вызова хранимых процедур используется объект CallableStatement. Нам необходимо задать параметры выхода OUT до выполнения CallableStatement.
```sql
CallableStatement stmt = con.prepareCall("{call insertEmployee(?,?,?,?,?,?)}");
stmt.setInt(1, id);
stmt.setString(2, name);
stmt.setString(3, role);
stmt.setString(4, city);
stmt.setString(5, country);
 
//register the OUT parameter before calling the stored procedure
stmt.registerOutParameter(6, java.sql.Types.VARCHAR);
              
stmt.executeUpdate();
```
[к оглавлению](#SQL)

## Что такое JDBC Batch Processing и каковы его преимущества

Бывает необходимо выполнить сразу группу похожих запросов, например при загрузке данных из CSV файлов реляционной базы данных. 
Это можно сделать просто используя Statement или PreparedStatement для пошагового выполнения этих запросов. 
В JDBC API существует другая возможность, которая предоставляет возможность выполнить группу запросов за один раз. 
Выполнение такого рода задачи происходит с помощью JDBC API Batch Processing.  

Использование batch режима выполнения запросов обычно гораздо эффективнее. 
В этом режиме запросы не выполняются сразу, каждый по отдельности, а накапливаются и **выполняются одним большим запросом с множеством данных.** 
Например, если вы делаете несколько update запросов, то каждый запрос будет выполнен как отдельный самостоятельный запрос.
В batch режиме ваши update запросы будут отправлены одним заданием, что производительнее.

JDBC API поддерживает пакетную обработку с помощью методов addBatch() и executeBatch() у Statement и PreparedStatement. 
К преимуществам такого подхода относится более быстрая работа, т.к. вызовов к базе данных может быть существенно меньше.  
  
[подробнее](https://easyjava.ru/spring/spring-data-access/batch-operacii-v-spring-jdbc/)  

[к оглавлению](#SQL)

## Что такое JDBC Transaction Management и зачем он нужен

По умолчанию, при создании подключения к базе данных будет выбран auto-commit mode. 
Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению. 
Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения будут 
приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения какого-либо 
запроса (или групп запросов) в случае, если что-то пошло не так, то мы можем воспользоваться поддержкой транзакций в JDBC API.

С помощью метода setAutoCommit(boolean flag) можно отключить авто коммит в конкретном соединении. 
Следует отметить, что при отключении auto-commit не одно изменение не будет сохранено в базе данных до вызова 
метода commit() и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных 
до подтверждения транзакции, а так как это ресурсоёмкая задача, то подтверждать транзакцию необходимо сразу после выполнения задачи.  
  
DDL – Data Definition Language   CREATE ALTER DROP   
DML – Data Manipulation Language SELECT INSERT UPDATE DELETE   

[к оглавлению](#SQL)

## Как откатить JDBC транзакцию

Для этого предусмотрен метод объекта Connection rollback(), который откатывает транзакцию. 
Будут отменены все изменения в транзакции и отменен lock базы данных от этого объекта Connection.

[к оглавлению](#SQL)

## Что такое JDBC Savepoint и как он используется

JDBC Savepoint позволяет создавать «чекпоинты» в транзакции с помощью которых мы можем откатить не всю транзакцию целиком, 
а только часть до точки сохранения. Любая точка сохранения автоматически освобождается и становится недоступной после 
подтверждения транзакции или её роллбека. Откат к точке сохранения делает все последующие сейвы недоступными и к ним уже 
нельзя будет вернуться.

[к оглавлению](#SQL)

## Расскажите про Apache DBCP API  
Каждый Coonection - это физическое подключение к БД. Его создание и закрытие - довольно "дорогая" работа.  
JDBC предоставляет лишь API для пула соединений. Поэтому, выбор реализации остаётся за нами.  

Пул подключений необходим для WEB приложения, когда все запросы к базе данных стекаются в одно место к серверу,
а создание нового подключения к БД требует значительных ресурсоов. Использование пула подключения оправдано более экономной стратегией
- создание несколько подключений и слежение за их состояниям; по мере необходимости добавлять новые.  

apache dbcp предполагает, что имеется некоторый набор («пул») соединений к базе данных. 
Когда новый пользователь запрашивает доступ к БД, ему выдаётся уже открытое соединение из этого пула.
Если все открытые соединения уже заняты, создаётся новое. Как только пользователь освобождает одно из уже существующих соединений, 
оно становится доступно для других пользователей. Если соединение долго не используется, оно закрывается.  

Короче говоря, пул соединений - это на самом базовом уровне реализация кэша соединений с базой данных,
которая может быть настроена в соответствии с конкретными требованиями.

[к оглавлению](#SQL)

## Какие вы знаете уровни изоляции транзакций в JDBC  
[подробнее](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9)
 
Уровень изоляции транзакций - это степень обеспечиваемой защиты механизмами СУБД от несогласованности данных,
возникающих при параллельном выполнении транзакций.      
Уровень изолированности транзакций — условное значение, определяющее, 
**в какой мере** в результате выполнения логически параллельных транзакций в СУБД допускается **получение несогласованных данных.** 
Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций.
С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.  

Когда мы используем транзакции в JDBC для обеспечения целостности данных, СУБД использует блокировки, 
чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. 
Такие блокировки необходимы, чтобы предотвратить грязное чтение (Dirty Read), неповторяющееся чтение (Non-Repeatable Read) 
и фантомное чтение (Phantom-Read).  
  
При параллельном выполнении транзакций возможны следующие проблемы:  
+ потерянное обновление (англ. lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего;
+ «грязное» чтение (англ. dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
+ неповторяющееся чтение (англ. non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
+ фантомное чтение (англ. phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям.
Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, 
используемых в критериях выборки первой транзакции, и успешно заканчивается.
В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

Уровень изоляции транзакции JDBC используемый СУБД для механизма блокировки можно задать с помощью метода setTransactionIsolation(). 
Получить информацию о применяемом уровне изоляции поможет метод Connection getTransactionIsolation().

| Isolation Level| Transaction| Dirty Read| Non-Repeatable Read| Phantom Read |
| ---| ---| ---| ---| --- |
| TRANSACTION_NONE| Not Supported| Not Applicable| Not Applicable| Not Applicable |
| TRANSACTION_READ_COMMITTED| Supported| Prevented| Allowed| Allowed |
| TRANSACTION_READ_UNCOMMITTED| Supported| Allowed| Allowed| Allowed |
| TRANSACTION_REPEATABLE_READ| Supported| Prevented| Prevented| Allowed |
| TRANSACTION_SERIALIZABLE| Supported| Prevented| Prevented| Prevented |  

**Read Committed** — уровень изоляции транзакции, выбираемый в Postgres Pro по умолчанию. В транзакции, работающей на этом уровне,
запрос SELECT (без предложения FOR UPDATE/SHARE) видит только те данные, которые были зафиксированы до начала запроса;
он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями.       

[подробнее](https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso)
[к оглавлению](#SQL)  

## Приведите пример наиболее распространенных исключений в JDBC

Некоторые из наиболее распространенных исключений JDBC:

+ java.sql.SQLException — это базовый класс для исключений JDBC.
+ java.sql.BatchUpdateException — возникает при исключительных ситуациях пакетной обработки запросов.
Может зависеть от типа драйвера JDBC, который может выбросить взамен базовый SQLException.
+ java.sql.SQLWarning — для предупреждающих сообщений различных SQL операций.
+ java.sql.DataTruncation — когда значения данных неожиданно усекаются по причинам, не зависящим от превышения MaxFieldSize.

[к оглавлению](#SQL)

## Расскажите о типах данных CLOB и BLOB в JDBC  

BLOB (Binary Large Object) - тип данных предназначен для хранение больших бинарных данных, таких как картинки, аудио - видео записи и т.д.  
CLOB (Character Large Object) - тип данных предназначен для хранения больших текстовых данных заданной кодировки.  
BLOB — большой двоичный объект. Переменная этого типа содержит локатор LOB, 
указывающий на большой двоичный объект, хранящийся в базе данных.   
CLOB — большой символьный объект. Переменная этого типа содержит локатор LOB, 
указывающий на хранящийся в базе данных большой блок текстовых данных в наборе символов базы данных.  

Character Large OBjects (CLOBs) — тип данных (внутренний символьный объект), используемый для хранения больших объектов. 
При выборе значения любого LOB-типа посредством оператора SELECT возвращается указатель, а не само значение; 
кроме того, типы LOB могут быть и внешними. Этот тип данных является подходящим для хранения текстовой информации, 
которая может выходить за пределы обычного типа данных VARCHAR (верхний предел 32 Кбайт).
Внутренний большой двоичный объект (BLOB) — двоичный объект большого размера, который может содержать переменное количество данных. 
Этот тип данных может хранить данные объемом более VARBINARY (32K предел). Тип данных, предназначенный, в первую очередь, 
для хранения изображений, аудио и видео, а также компилированного программного кода.  

[к оглавлению](#SQL)

## Что вы знаете о «грязном чтении» dirty read в JDBC Какой уровень изоляции предотвращает этот тип чтения

Когда транзакция может читать несогласованные данные.  
«Грязное» чтение (англ. dirty read) — чтение данных, добавленных или изменённых транзакцией, 
которая впоследствии не подтвердится (откатится). Получение недействительного в последствии значения (после отката транзакции) 
может приводить к непредвиденным результатам.

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| UPDATE tbl1 SET f2=f2+1 WHERE f1=1; | |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| ROLLBACK WORK; | |

Dirty Read можно предотвратить, используя следующие уровни изоляции: 
TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ и TRANSACTION_SERIALIZABLE.

[к оглавлению](#SQL)

## Какие есть две фазы commit

Когда мы работаем в распределенных системах, где участвуют несколько баз данных, мы должны использовать протокол с 2 фазами фиксации. 
2 фазовый протокол фиксации является атомарным протоколом для распределенных систем. 
На первом этапе, менеджер транзакций передает commit-request всем ресурсам транзакции. 
Если все ресурсы транзакции ответили ОК, то менеджер транзакций фиксирует изменения транзакций для всех ресурсов. 
Если какой-либо из ресурсов транзакций уведомляет об отмене, то менеджер транзакций может откатить все изменения транзакций.

[к оглавлению](#SQL)

## Приведите пример различных типов блокировки в JDBC

На более широком уровне есть два типа механизма блокировки для предотвращения повреждения данных из-за одновременной 
работы с данными несколькими пользователями. По логике реализации различают два вида блокировок.  

**Пессимистическая блокировка** — накладывается перед предполагаемой модификацией данных на все строки, 
которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных 
из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. 
По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.  

**Оптимистическая блокировка** — не ограничивает модификацию обрабатываемых данных сторонними сессиями, 
однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк 
данных (обычно используется наименование VERSION и целочисленный тип с инициальным значением 0). 
Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, 
то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута 
не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута 
(например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.  

[к оглавлению](#SQL)

## Как вы понимаете DDL и DML выражения

**Data Definition Language (DDL) (язык описания данных)** — это семейство компьютерных языков, используемых в компьютерных 
программах для описания структуры баз данных. Функции языков DDL определяются первым словом в предложении (часто называемом запросом), 
которое почти всегда является глаголом. В случае с SQL это глаголы — «create» («создать»), «alter» («изменить»), «drop» («удалить»).

**Data Manipulation Language (DML) (язык управления (манипулирования) данными)** — это семейство компьютерных языков, 
используемых в компьютерных программах или пользователями баз данных для получения, вставки, удаления или изменения данных 
в базах данных. Функции языков DML определяются первым словом в предложении (часто называемом запросом), 
которое почти всегда является глаголом. В случае с SQL эти глаголы — «select» («выбрать»), «insert» («вставить»), 
«update» («обновить»), и «delete» («удалить»). Это превращает природу языка в ряд обязательных утверждений (команд) к базе данных.

[к оглавлению](#SQL)

## Какая разница между javautilDate и javasqlDate

java.util.Date содержит информацию о дате и времени, тогда как java.sql.Date содержит информацию только о дате, 
но не имеет информации о времени. Если необходимо сохранить информацию о времени в базе данных, 
то желательно использовать поля Timestamp или DateTime.

Java.util.Date — основной универсальный объект. В нем просто сохраняется дата (как long).

java.sql.Date расширяет java.util.Date и добавляет следующую функциональность:

1) toString выводит дату в качестве «yyyy-mm-dd», а не как у конкретного языкового стандарта строки (локали).

2) Добавлен метод valueOf для чтения строк формата «yyyy-mm-dd» и дальнейшего разбора ее в объект sql.Date.

[к оглавлению](#SQL)

## Как вставить изображение или необработанные данные в базу данных  
Для этого можно использовать тип данных BLOB, чтобы вставить картинку или двоичные данные в базу данных.

[к оглавлению](#SQL)

## Что вы можете рассказать о фантомном чтении Какой уровень изоляции его предотвращает  
Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк. 
Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20); | |
|  COMMIT; | |
| | SELECT SUM(f2) FROM tbl1; |

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка 
новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. 
Такая ситуация называется фантомным чтением. От неповторяющегося чтения оно отличается тем, что результат повторного 
обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.
Phantom read можно предотвратить только на уровне изоляции — TRANSACTION_SERIALIZABLE.

[к оглавлению](#SQL)

## Что такое SQL Warning Как возвратить SQL предупреждения в JDBC программе

SQLWarning это подкласс SQLException, который мы можем получить вызвав метод getWarnings() у объектов Connection, 
Statement, ResultSet. SQL Предупреждения не останавливает выполнение запроса, но показывает предупреждающие сообщения 
для пользователя.

[к оглавлению](#SQL)

## Как запустить Oracle Stored Procedure с объектами базы данных INOUT

Если хранимая процедура Oracle содержит IN / OUT параметры как DB объекты, то мы должны создать массив объектов такого 
же размера в программе, а затем использовать его для создания Oracle STRUCT объекта. Тогда мы можем установить этот 
STRUCT объект в объект базы данных, вызвав метод setSTRUCT().

[к оглавлению](#SQL)

## Приведите пример возникновения javasqlSQLException: No suitable driver found

Исключение java.sql.SQLException: No suitable driver found может быть вызвано, например, неправильно отформатированной 
строкой SQL-адреса. Вы можете получить это исключение в простом Java приложении как через DriverManager, 
так и используя JNDI DataSource. Трассировка стека исключений приведена ниже:
```java
org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot create JDBC driver of class 'com.mysql.jdbc.Driver' for connect URL ''jdbc:mysql://localhost:3306/UserDB'
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1452)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)
 
 
java.sql.SQLException: No suitable driver found for 'jdbc:mysql://localhost:3306/UserDB
    at java.sql.DriverManager.getConnection(DriverManager.java:604)
    at java.sql.DriverManager.getConnection(DriverManager.java:221)
    at com.journaldev.jdbc.DBConnection.getConnection(DBConnection.java:24)
    at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:15)
Exception in thread "main" java.lang.NullPointerException
```
[к оглавлению](#SQL)

## Best Practices в JDBC

Некоторые Best Practices в JDBC:

+ Всегда закрывайте ресурсы базы данных сразу после работы с ними. Connection, Statement, ResultSet и другие JDBC объекты имеют метод close(), 
который позволяет закрыть их.
+ Всегда явно закрывайте результирующий набор ResultSet, Statement и Connection в коде, потому что если вы используете пул соединений, 
то соединение может быть возвращено в пул, оставляя открытые result sets и statement objects и будет происходить утечка.
+ Используйте пакетную обработку (batch processing) для повторяющихся запросов.
+ Всегда используйте PreparedStatement вместо Statement, чтобы избежать SQL Injection и
 получить преимущества заранее прекомпилированного и кэшированного запроса PreparedStatement.
+ Если вы извлекаете большие массивы данных в result set, то заранее установите оптимальное значение fetchSize, что поможет получить лучшую производительность.
+ Сервер базы данных может не поддерживать все уровни изоляции, так что проверьте их заранее.
+ Более строгие уровни изоляции могут привести к снижению производительности, поэтому убедитесь, что вы используете оптимальный
 набор уровней изоляции для ваших соединений с базой данных.
+ Если вы создаете подключения к базе данных из веб-приложения, попробуйте использовать ресурсы JDBC DataSource 
с помощью применения контекста JNDI для возможности повторного использования соединений.
+ Попробуйте использовать отключенный (disconnected) RowSet, когда вам нужно работать с ResultSet в течение длительного времени.

[к оглавлению](#SQL)  

## Что такое ORM  
JDBC - чистые запросы на SQL  
JPA - ООП подход  
   
Разработчики каждый раз сталкивались с необходимостью писать однотипный и ненужный "обслуживающий" код (так называемый Boilerplate code)
для тривиальных операций по сохранению Java объектов в БД и наоборот, созданию Java объектов по данным из БД. 
И тогда для решения этих проблем на свет появилось такое понятие, как ORM.

ORM — Object-Relational Mapping (объектно-реляционное отображение)
Это концепция, которая связывает базы данных с парадигмой объектно-ориентированных языков программирования.
Если упростить, то ORM это связь Java объектов и записей в БД. ORM освобождает программиста от работы с SQL-скриптами и позволяет сосредоточиться на ООП.  
Т.е. используя ORM - фреймворки, реализующие JPA спецификацию, мы оперируем в рамках ООП парадигмы и манипулируем объектами, 
а не чистыми SQL запросами (как в JDBC). (взаимодействие с БД и SQL запросы работают уже "под капотом" JPA)     

**ORM — это по сути концепция о том, что Java объект можно представить как данные в БД (и наоборот).**
Она нашла воплощение в виде спецификации JPA — Java Persistence API.   

JPA - Java Persistence API, javax.persistence
JPA (Java Persistence API) — программный интерфейс API, входящий с версии Java 5 в состав платформ Java SE и Java EE. 
Одной из самых заметных реализаций JPA является Hibernate.  

JPA оперирует таким понятием, как сущность Entity, которая является POJO-классом и связана с БД с помощью аннотации @Entity
или через файл конфигурации XML. К такому классу предъявляются следующие требования :  
+ наличие пустого public или protected конструктора;  
+ не должен быть вложенным, являться интерфейсом или enum;  
+ не должен быть final и не должен содержать final-свойств;  
+ должен включать хотя бы одно @Id-поле.  
    
[подробнее](https://javarush.ru/groups/posts/2259-jpa--znakomstvo-s-tekhnologiey) 
[подробнее](http://java-online.ru/hibernate-jpa.xhtml)
[к оглавлению](#SQL)  